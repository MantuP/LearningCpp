/*
 *    rap105.c
 *
 *    "RAP-0105" ASN.1 module encode/decode/print/free C src.
 *
 *    This file was generated by snacc on Mon Apr  9 15:32:16 2012
 *
 *    UBC snacc written by Mike Sample
 *
 *    NOTE: This is a machine generated file - editing not recommended
 */



#include "asn-incl.h"
#include "tap312.h"
#include "rap105.h"


AsnLen
BEncMessageDescriptionInformationDefinitionContent PARAMS ((b, v),
BUF_TYPE b _AND_
MessageDescriptionInformationDefinition *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (ASNOCTS_PRESENT ((&v->messageDescription)))
    {
    itemLen = BEncMessageDescriptionContent (b, (&v->messageDescription));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 142);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->messageDescriptionCode)))
    {
    itemLen = BEncMessageDescriptionCodeContent (b, (v->messageDescriptionCode));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 141);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncMessageDescriptionInformationDefinitionContent */

void
BDecMessageDescriptionInformationDefinitionContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
MessageDescriptionInformationDefinition *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 141))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->messageDescriptionCode) = (MessageDescriptionCode*) Asn1Alloc (sizeof (MessageDescriptionCode));
    CheckAsn1Alloc ((v->messageDescriptionCode), env);
    BDecMessageDescriptionCodeContent (b, tagId1, elmtLen1, (v->messageDescriptionCode), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 142)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 142))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecMessageDescriptionContent (b, tagId1, elmtLen1, (&v->messageDescription), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -100);
    }


    if (!seqDone)
        longjmp (env, -101);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecMessageDescriptionInformationDefinitionContent */

void
PrintMessageDescriptionInformationDefinition PARAMS ((f, v, indent),
FILE* f _AND_
MessageDescriptionInformationDefinition *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->messageDescriptionCode)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"messageDescriptionCode ");
    PrintMessageDescriptionCode (f, (v->messageDescriptionCode), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->messageDescription)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"messageDescription ");
    PrintMessageDescription (f, (&v->messageDescription), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintMessageDescriptionInformationDefinition */

void
FreeMessageDescriptionInformationDefinition PARAMS ((v),
MessageDescriptionInformationDefinition *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->messageDescriptionCode)))
    {
    FreeMessageDescriptionCode ((v->messageDescriptionCode));
    Asn1Free ((v->messageDescriptionCode));
    }

    if (ASNOCTS_PRESENT ((&v->messageDescription)))
    {
    FreeMessageDescription ((&v->messageDescription));
    }

}  /* FreeMessageDescriptionInformationDefinition */




AsnLen
BEncOperatorSpecListContent PARAMS ((b, v),
BUF_TYPE b _AND_
OperatorSpecList *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    itemLen = BEncOperatorSpecInformationContent (b, component);
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 163);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncOperatorSpecListContent */

void
BDecOperatorSpecListContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
OperatorSpecList *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        OperatorSpecInformation **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 163)) ||
       (tagId1 == MAKE_TAG_ID (APPL, CONS, 163)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (OperatorSpecInformation**) AsnListAppend (v);
    (*tmpVar) = (OperatorSpecInformation*) Asn1Alloc (sizeof (OperatorSpecInformation));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecOperatorSpecInformationContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -102);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecOperatorSpecListContent */

void
PrintOperatorSpecList PARAMS ((f, v, indent),
FILE* f _AND_
OperatorSpecList *v _AND_
unsigned short int indent)
{
    OperatorSpecInformation *tmp;
    if (v == NULL)
        return;
    fprintf (f,"{ -- SEQUENCE OF -- \n");
    FOR_EACH_LIST_ELMT (tmp, v)
    {
        Indent (f, indent+ stdIndentG);
        PrintOperatorSpecInformation (f, tmp, indent + stdIndentG);
        if (tmp != (OperatorSpecInformation*)LAST_LIST_ELMT (v))
            fprintf (f,",\n");
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintOperatorSpecList */

void
FreeOperatorSpecList PARAMS ((v),
OperatorSpecList *v)
{

    AsnListNode *l;
    AsnListNode *tmp;
    if (v == NULL)
        return;
    for (l = FIRST_LIST_NODE (v); l != NULL; )
    {
        FreeOperatorSpecInformation ((l->data));
        tmp = l->next;
        Asn1Free (l->data);
        Asn1Free (l);
        l = tmp;
    }
}  /* FreeOperatorSpecList */




AsnLen
BEncAcknowledgementContent PARAMS ((b, v),
BUF_TYPE b _AND_
Acknowledgement *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->operatorSpecList)))
    {
    BEncEocIfNec (b);
    itemLen = BEncOperatorSpecListContent (b, (v->operatorSpecList));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 551);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->fileTypeIndicator)))
    {
    itemLen = BEncFileTypeIndicatorContent (b, (&v->fileTypeIndicator));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, PRIM, 110);

    totalLen += itemLen;
    }

    BEncEocIfNec (b);
    itemLen = BEncAckFileAvailableTimeStampContent (b, (v->ackFileAvailableTimeStamp));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 515);

    totalLen += itemLen;

    BEncEocIfNec (b);
    itemLen = BEncAckFileCreationTimeStampContent (b, (v->ackFileCreationTimeStamp));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 516);

    totalLen += itemLen;

    itemLen = BEncRapFileSequenceNumberContent (b, (&v->rapFileSequenceNumber));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 181);

    totalLen += itemLen;

    itemLen = BEncRecipientContent (b, (&v->recipient));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 182);

    totalLen += itemLen;

    itemLen = BEncSenderContent (b, (&v->sender));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 196);

    totalLen += itemLen;

    return totalLen;

}  /* BEncAcknowledgementContent */

void
BDecAcknowledgementContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
Acknowledgement *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (APPL, PRIM, 196)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 196))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecSenderContent (b, tagId1, elmtLen1, (&v->sender), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -103);


    if (((tagId1 == MAKE_TAG_ID (APPL, PRIM, 182)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 182))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecRecipientContent (b, tagId1, elmtLen1, (&v->recipient), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -104);


    if (((tagId1 == MAKE_TAG_ID (APPL, PRIM, 181)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 181))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecRapFileSequenceNumberContent (b, tagId1, elmtLen1, (&v->rapFileSequenceNumber), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -105);


    if (((tagId1 == MAKE_TAG_ID (APPL, CONS, 516))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->ackFileCreationTimeStamp) = (AckFileCreationTimeStamp*) Asn1Alloc (sizeof (AckFileCreationTimeStamp));
    CheckAsn1Alloc ((v->ackFileCreationTimeStamp), env);
    BDecAckFileCreationTimeStampContent (b, tagId1, elmtLen1, (v->ackFileCreationTimeStamp), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -106);


    if (((tagId1 == MAKE_TAG_ID (APPL, CONS, 515))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->ackFileAvailableTimeStamp) = (AckFileAvailableTimeStamp*) Asn1Alloc (sizeof (AckFileAvailableTimeStamp));
    CheckAsn1Alloc ((v->ackFileAvailableTimeStamp), env);
    BDecAckFileAvailableTimeStampContent (b, tagId1, elmtLen1, (v->ackFileAvailableTimeStamp), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }
    else
        longjmp (env, -107);


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 110)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 110))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecFileTypeIndicatorContent (b, tagId1, elmtLen1, (&v->fileTypeIndicator), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 551))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->operatorSpecList) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->operatorSpecList), env);
    BDecOperatorSpecListContent (b, tagId1, elmtLen1, (v->operatorSpecList), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -108);
    }


    if (!seqDone)
        longjmp (env, -109);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecAcknowledgementContent */

void
PrintAcknowledgement PARAMS ((f, v, indent),
FILE* f _AND_
Acknowledgement *v _AND_
unsigned short int indent)
{
    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    Indent (f, indent + stdIndentG);
    fprintf (f,"sender ");
    PrintSender (f, (&v->sender), indent + stdIndentG);
    fprintf (f, ",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"recipient ");
    PrintRecipient (f, (&v->recipient), indent + stdIndentG);
    fprintf (f, ",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"rapFileSequenceNumber ");
    PrintRapFileSequenceNumber (f, (&v->rapFileSequenceNumber), indent + stdIndentG);
    fprintf (f, ",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"ackFileCreationTimeStamp ");
    PrintAckFileCreationTimeStamp (f, (v->ackFileCreationTimeStamp), indent + stdIndentG);
    fprintf (f, ",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"ackFileAvailableTimeStamp ");
    PrintAckFileAvailableTimeStamp (f, (v->ackFileAvailableTimeStamp), indent + stdIndentG);
    if (ASNOCTS_PRESENT ((&v->fileTypeIndicator)))
    {
    fprintf (f,",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"fileTypeIndicator ");
    PrintFileTypeIndicator (f, (&v->fileTypeIndicator), indent + stdIndentG);
    }
    if (NOT_NULL ((v->operatorSpecList)))
    {
    fprintf (f,",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"operatorSpecList ");
    PrintOperatorSpecList (f, (v->operatorSpecList), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintAcknowledgement */

void
FreeAcknowledgement PARAMS ((v),
Acknowledgement *v)
{

    if (v == NULL)
        return;
    FreeSender ((&v->sender));

    FreeRecipient ((&v->recipient));

    FreeRapFileSequenceNumber ((&v->rapFileSequenceNumber));

    FreeAckFileCreationTimeStamp ((v->ackFileCreationTimeStamp));
    Asn1Free ((v->ackFileCreationTimeStamp));

    FreeAckFileAvailableTimeStamp ((v->ackFileAvailableTimeStamp));
    Asn1Free ((v->ackFileAvailableTimeStamp));

    if (ASNOCTS_PRESENT ((&v->fileTypeIndicator)))
    {
    FreeFileTypeIndicator ((&v->fileTypeIndicator));
    }

    if (NOT_NULL ((v->operatorSpecList)))
    {
    FreeOperatorSpecList ((v->operatorSpecList));
    Asn1Free ((v->operatorSpecList));
    }

}  /* FreeAcknowledgement */




AsnLen
BEncRapBatchControlInfoContent PARAMS ((b, v),
BUF_TYPE b _AND_
RapBatchControlInfo *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (ASNOCTS_PRESENT ((&v->tapCurrency)))
    {
    itemLen = BEncTapCurrencyContent (b, (&v->tapCurrency));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 210);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->tapDecimalPlaces)))
    {
    itemLen = BEncTapDecimalPlacesContent (b, (v->tapDecimalPlaces));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 244);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->operatorSpecList)))
    {
    BEncEocIfNec (b);
    itemLen = BEncOperatorSpecListContent (b, (v->operatorSpecList));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 551);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->roamingPartner)))
    {
    itemLen = BEncRoamingPartnerContent (b, (&v->roamingPartner));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 550);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->fileTypeIndicator)))
    {
    itemLen = BEncFileTypeIndicatorContent (b, (&v->fileTypeIndicator));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, PRIM, 110);

    totalLen += itemLen;
    }

    itemLen = BEncRapReleaseVersionNumberContent (b, (&v->rapReleaseVersionNumber));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 543);

    totalLen += itemLen;

    itemLen = BEncRapSpecificationVersionNumberContent (b, (&v->rapSpecificationVersionNumber));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 544);

    totalLen += itemLen;

    if (NOT_NULL ((v->releaseVersionNumber)))
    {
    itemLen = BEncReleaseVersionNumberContent (b, (v->releaseVersionNumber));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 189);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->specificationVersionNumber)))
    {
    itemLen = BEncSpecificationVersionNumberContent (b, (v->specificationVersionNumber));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 201);

    totalLen += itemLen;
    }

    BEncEocIfNec (b);
    itemLen = BEncRapFileAvailableTimeStampContent (b, (v->rapFileAvailableTimeStamp));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 525);

    totalLen += itemLen;

    BEncEocIfNec (b);
    itemLen = BEncRapFileCreationTimeStampContent (b, (v->rapFileCreationTimeStamp));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 526);

    totalLen += itemLen;

    itemLen = BEncRapFileSequenceNumberContent (b, (&v->rapFileSequenceNumber));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 181);

    totalLen += itemLen;

    itemLen = BEncRecipientContent (b, (&v->recipient));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 182);

    totalLen += itemLen;

    itemLen = BEncSenderContent (b, (&v->sender));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 196);

    totalLen += itemLen;

    return totalLen;

}  /* BEncRapBatchControlInfoContent */

void
BDecRapBatchControlInfoContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
RapBatchControlInfo *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (APPL, PRIM, 196)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 196))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecSenderContent (b, tagId1, elmtLen1, (&v->sender), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -110);


    if (((tagId1 == MAKE_TAG_ID (APPL, PRIM, 182)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 182))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecRecipientContent (b, tagId1, elmtLen1, (&v->recipient), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -111);


    if (((tagId1 == MAKE_TAG_ID (APPL, PRIM, 181)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 181))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecRapFileSequenceNumberContent (b, tagId1, elmtLen1, (&v->rapFileSequenceNumber), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -112);


    if (((tagId1 == MAKE_TAG_ID (APPL, CONS, 526))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->rapFileCreationTimeStamp) = (RapFileCreationTimeStamp*) Asn1Alloc (sizeof (RapFileCreationTimeStamp));
    CheckAsn1Alloc ((v->rapFileCreationTimeStamp), env);
    BDecRapFileCreationTimeStampContent (b, tagId1, elmtLen1, (v->rapFileCreationTimeStamp), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -113);


    if (((tagId1 == MAKE_TAG_ID (APPL, CONS, 525))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->rapFileAvailableTimeStamp) = (RapFileAvailableTimeStamp*) Asn1Alloc (sizeof (RapFileAvailableTimeStamp));
    CheckAsn1Alloc ((v->rapFileAvailableTimeStamp), env);
    BDecRapFileAvailableTimeStampContent (b, tagId1, elmtLen1, (v->rapFileAvailableTimeStamp), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -114);


    if (((tagId1 == MAKE_TAG_ID (APPL, PRIM, 201))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->specificationVersionNumber) = (SpecificationVersionNumber*) Asn1Alloc (sizeof (SpecificationVersionNumber));
    CheckAsn1Alloc ((v->specificationVersionNumber), env);
    BDecSpecificationVersionNumberContent (b, tagId1, elmtLen1, (v->specificationVersionNumber), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }


    if (((tagId1 == MAKE_TAG_ID (APPL, PRIM, 189))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->releaseVersionNumber) = (ReleaseVersionNumber*) Asn1Alloc (sizeof (ReleaseVersionNumber));
    CheckAsn1Alloc ((v->releaseVersionNumber), env);
    BDecReleaseVersionNumberContent (b, tagId1, elmtLen1, (v->releaseVersionNumber), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }


    if (((tagId1 == MAKE_TAG_ID (APPL, PRIM, 544))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecRapSpecificationVersionNumberContent (b, tagId1, elmtLen1, (&v->rapSpecificationVersionNumber), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -115);


    if (((tagId1 == MAKE_TAG_ID (APPL, PRIM, 543))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecRapReleaseVersionNumberContent (b, tagId1, elmtLen1, (&v->rapReleaseVersionNumber), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }
    else
        longjmp (env, -116);


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 110)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 110))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecFileTypeIndicatorContent (b, tagId1, elmtLen1, (&v->fileTypeIndicator), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 550)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 550))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecRoamingPartnerContent (b, tagId1, elmtLen1, (&v->roamingPartner), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 551))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->operatorSpecList) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->operatorSpecList), env);
    BDecOperatorSpecListContent (b, tagId1, elmtLen1, (v->operatorSpecList), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 244))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->tapDecimalPlaces) = (TapDecimalPlaces*) Asn1Alloc (sizeof (TapDecimalPlaces));
    CheckAsn1Alloc ((v->tapDecimalPlaces), env);
    BDecTapDecimalPlacesContent (b, tagId1, elmtLen1, (v->tapDecimalPlaces), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 210)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 210))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecTapCurrencyContent (b, tagId1, elmtLen1, (&v->tapCurrency), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -117);
    }


    if (!seqDone)
        longjmp (env, -118);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecRapBatchControlInfoContent */

void
PrintRapBatchControlInfo PARAMS ((f, v, indent),
FILE* f _AND_
RapBatchControlInfo *v _AND_
unsigned short int indent)
{
    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    Indent (f, indent + stdIndentG);
    fprintf (f,"sender ");
    PrintSender (f, (&v->sender), indent + stdIndentG);
    fprintf (f, ",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"recipient ");
    PrintRecipient (f, (&v->recipient), indent + stdIndentG);
    fprintf (f, ",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"rapFileSequenceNumber ");
    PrintRapFileSequenceNumber (f, (&v->rapFileSequenceNumber), indent + stdIndentG);
    fprintf (f, ",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"rapFileCreationTimeStamp ");
    PrintRapFileCreationTimeStamp (f, (v->rapFileCreationTimeStamp), indent + stdIndentG);
    fprintf (f, ",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"rapFileAvailableTimeStamp ");
    PrintRapFileAvailableTimeStamp (f, (v->rapFileAvailableTimeStamp), indent + stdIndentG);
    fprintf (f, ",\n");
    if (NOT_NULL ((v->specificationVersionNumber)))
    {
    Indent (f, indent + stdIndentG);
    fprintf (f,"specificationVersionNumber ");
    PrintSpecificationVersionNumber (f, (v->specificationVersionNumber), indent + stdIndentG);
    fprintf (f, ",\n");
    }
    if (NOT_NULL ((v->releaseVersionNumber)))
    {
    Indent (f, indent + stdIndentG);
    fprintf (f,"releaseVersionNumber ");
    PrintReleaseVersionNumber (f, (v->releaseVersionNumber), indent + stdIndentG);
    fprintf (f, ",\n");
    }
    Indent (f, indent + stdIndentG);
    fprintf (f,"rapSpecificationVersionNumber ");
    PrintRapSpecificationVersionNumber (f, (&v->rapSpecificationVersionNumber), indent + stdIndentG);
    fprintf (f, ",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"rapReleaseVersionNumber ");
    PrintRapReleaseVersionNumber (f, (&v->rapReleaseVersionNumber), indent + stdIndentG);
    if (ASNOCTS_PRESENT ((&v->fileTypeIndicator)))
    {
    fprintf (f,",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"fileTypeIndicator ");
    PrintFileTypeIndicator (f, (&v->fileTypeIndicator), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->roamingPartner)))
    {
    fprintf (f,",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"roamingPartner ");
    PrintRoamingPartner (f, (&v->roamingPartner), indent + stdIndentG);
    }
    if (NOT_NULL ((v->operatorSpecList)))
    {
    fprintf (f,",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"operatorSpecList ");
    PrintOperatorSpecList (f, (v->operatorSpecList), indent + stdIndentG);
    }
    if (NOT_NULL ((v->tapDecimalPlaces)))
    {
    fprintf (f,",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"tapDecimalPlaces ");
    PrintTapDecimalPlaces (f, (v->tapDecimalPlaces), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->tapCurrency)))
    {
    fprintf (f,",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"tapCurrency ");
    PrintTapCurrency (f, (&v->tapCurrency), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintRapBatchControlInfo */

void
FreeRapBatchControlInfo PARAMS ((v),
RapBatchControlInfo *v)
{

    if (v == NULL)
        return;
    FreeSender ((&v->sender));

    FreeRecipient ((&v->recipient));

    FreeRapFileSequenceNumber ((&v->rapFileSequenceNumber));

    FreeRapFileCreationTimeStamp ((v->rapFileCreationTimeStamp));
    Asn1Free ((v->rapFileCreationTimeStamp));

    FreeRapFileAvailableTimeStamp ((v->rapFileAvailableTimeStamp));
    Asn1Free ((v->rapFileAvailableTimeStamp));

    if (NOT_NULL ((v->specificationVersionNumber)))
    {
    FreeSpecificationVersionNumber ((v->specificationVersionNumber));
    Asn1Free ((v->specificationVersionNumber));
    }

    if (NOT_NULL ((v->releaseVersionNumber)))
    {
    FreeReleaseVersionNumber ((v->releaseVersionNumber));
    Asn1Free ((v->releaseVersionNumber));
    }

    FreeRapSpecificationVersionNumber ((&v->rapSpecificationVersionNumber));

    FreeRapReleaseVersionNumber ((&v->rapReleaseVersionNumber));

    if (ASNOCTS_PRESENT ((&v->fileTypeIndicator)))
    {
    FreeFileTypeIndicator ((&v->fileTypeIndicator));
    }

    if (ASNOCTS_PRESENT ((&v->roamingPartner)))
    {
    FreeRoamingPartner ((&v->roamingPartner));
    }

    if (NOT_NULL ((v->operatorSpecList)))
    {
    FreeOperatorSpecList ((v->operatorSpecList));
    Asn1Free ((v->operatorSpecList));
    }

    if (NOT_NULL ((v->tapDecimalPlaces)))
    {
    FreeTapDecimalPlaces ((v->tapDecimalPlaces));
    Asn1Free ((v->tapDecimalPlaces));
    }

    if (ASNOCTS_PRESENT ((&v->tapCurrency)))
    {
    FreeTapCurrency ((&v->tapCurrency));
    }

}  /* FreeRapBatchControlInfo */




AsnLen
BEncStopReturnContent PARAMS ((b, v),
BUF_TYPE b _AND_
StopReturn *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->operatorSpecList)))
    {
    BEncEocIfNec (b);
    itemLen = BEncOperatorSpecListContent (b, (v->operatorSpecList));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 551);

    totalLen += itemLen;
    }

    itemLen = BEncLastSeqNumberContent (b, (&v->lastSeqNumber));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 555);

    totalLen += itemLen;

    return totalLen;

}  /* BEncStopReturnContent */

void
BDecStopReturnContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
StopReturn *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (APPL, PRIM, 555)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 555))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecLastSeqNumberContent (b, tagId1, elmtLen1, (&v->lastSeqNumber), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }
    else
        longjmp (env, -119);


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 551))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->operatorSpecList) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->operatorSpecList), env);
    BDecOperatorSpecListContent (b, tagId1, elmtLen1, (v->operatorSpecList), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -120);
    }


    if (!seqDone)
        longjmp (env, -121);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecStopReturnContent */

void
PrintStopReturn PARAMS ((f, v, indent),
FILE* f _AND_
StopReturn *v _AND_
unsigned short int indent)
{
    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    Indent (f, indent + stdIndentG);
    fprintf (f,"lastSeqNumber ");
    PrintLastSeqNumber (f, (&v->lastSeqNumber), indent + stdIndentG);
    if (NOT_NULL ((v->operatorSpecList)))
    {
    fprintf (f,",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"operatorSpecList ");
    PrintOperatorSpecList (f, (v->operatorSpecList), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintStopReturn */

void
FreeStopReturn PARAMS ((v),
StopReturn *v)
{

    if (v == NULL)
        return;
    FreeLastSeqNumber ((&v->lastSeqNumber));

    if (NOT_NULL ((v->operatorSpecList)))
    {
    FreeOperatorSpecList ((v->operatorSpecList));
    Asn1Free ((v->operatorSpecList));
    }

}  /* FreeStopReturn */




AsnLen
BEncMissingReturnContent PARAMS ((b, v),
BUF_TYPE b _AND_
MissingReturn *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->operatorSpecList)))
    {
    BEncEocIfNec (b);
    itemLen = BEncOperatorSpecListContent (b, (v->operatorSpecList));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 551);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->endMissingSeqNumber)))
    {
    itemLen = BEncEndMissingSeqNumberContent (b, (&v->endMissingSeqNumber));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 518);

    totalLen += itemLen;
    }

    itemLen = BEncStartMissingSeqNumberContent (b, (&v->startMissingSeqNumber));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 532);

    totalLen += itemLen;

    return totalLen;

}  /* BEncMissingReturnContent */

void
BDecMissingReturnContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
MissingReturn *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (APPL, PRIM, 532)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 532))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecStartMissingSeqNumberContent (b, tagId1, elmtLen1, (&v->startMissingSeqNumber), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }
    else
        longjmp (env, -122);


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 518)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 518))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecEndMissingSeqNumberContent (b, tagId1, elmtLen1, (&v->endMissingSeqNumber), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 551))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->operatorSpecList) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->operatorSpecList), env);
    BDecOperatorSpecListContent (b, tagId1, elmtLen1, (v->operatorSpecList), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -123);
    }


    if (!seqDone)
        longjmp (env, -124);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecMissingReturnContent */

void
PrintMissingReturn PARAMS ((f, v, indent),
FILE* f _AND_
MissingReturn *v _AND_
unsigned short int indent)
{
    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    Indent (f, indent + stdIndentG);
    fprintf (f,"startMissingSeqNumber ");
    PrintStartMissingSeqNumber (f, (&v->startMissingSeqNumber), indent + stdIndentG);
    if (ASNOCTS_PRESENT ((&v->endMissingSeqNumber)))
    {
    fprintf (f,",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"endMissingSeqNumber ");
    PrintEndMissingSeqNumber (f, (&v->endMissingSeqNumber), indent + stdIndentG);
    }
    if (NOT_NULL ((v->operatorSpecList)))
    {
    fprintf (f,",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"operatorSpecList ");
    PrintOperatorSpecList (f, (v->operatorSpecList), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintMissingReturn */

void
FreeMissingReturn PARAMS ((v),
MissingReturn *v)
{

    if (v == NULL)
        return;
    FreeStartMissingSeqNumber ((&v->startMissingSeqNumber));

    if (ASNOCTS_PRESENT ((&v->endMissingSeqNumber)))
    {
    FreeEndMissingSeqNumber ((&v->endMissingSeqNumber));
    }

    if (NOT_NULL ((v->operatorSpecList)))
    {
    FreeOperatorSpecList ((v->operatorSpecList));
    Asn1Free ((v->operatorSpecList));
    }

}  /* FreeMissingReturn */




AsnLen
BEncRapAuditControlInfoContent PARAMS ((b, v),
BUF_TYPE b _AND_
RapAuditControlInfo *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->totalSevereReturnTax)))
    {
    itemLen = BEncTotalSevereReturnTaxContent (b, (v->totalSevereReturnTax));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 553);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->operatorSpecList)))
    {
    BEncEocIfNec (b);
    itemLen = BEncOperatorSpecListContent (b, (v->operatorSpecList));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 551);

    totalLen += itemLen;
    }

    itemLen = BEncReturnDetailsCountContent (b, (&v->returnDetailsCount));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 528);

    totalLen += itemLen;

    itemLen = BEncTotalSevereReturnValueContent (b, (&v->totalSevereReturnValue));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 533);

    totalLen += itemLen;

    return totalLen;

}  /* BEncRapAuditControlInfoContent */

void
BDecRapAuditControlInfoContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
RapAuditControlInfo *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (APPL, PRIM, 533))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecTotalSevereReturnValueContent (b, tagId1, elmtLen1, (&v->totalSevereReturnValue), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -125);


    if (((tagId1 == MAKE_TAG_ID (APPL, PRIM, 528))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecReturnDetailsCountContent (b, tagId1, elmtLen1, (&v->returnDetailsCount), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }
    else
        longjmp (env, -126);


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 551))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->operatorSpecList) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->operatorSpecList), env);
    BDecOperatorSpecListContent (b, tagId1, elmtLen1, (v->operatorSpecList), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 553))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->totalSevereReturnTax) = (TotalSevereReturnTax*) Asn1Alloc (sizeof (TotalSevereReturnTax));
    CheckAsn1Alloc ((v->totalSevereReturnTax), env);
    BDecTotalSevereReturnTaxContent (b, tagId1, elmtLen1, (v->totalSevereReturnTax), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -127);
    }


    if (!seqDone)
        longjmp (env, -128);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecRapAuditControlInfoContent */

void
PrintRapAuditControlInfo PARAMS ((f, v, indent),
FILE* f _AND_
RapAuditControlInfo *v _AND_
unsigned short int indent)
{
    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    Indent (f, indent + stdIndentG);
    fprintf (f,"totalSevereReturnValue ");
    PrintTotalSevereReturnValue (f, (&v->totalSevereReturnValue), indent + stdIndentG);
    fprintf (f, ",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"returnDetailsCount ");
    PrintReturnDetailsCount (f, (&v->returnDetailsCount), indent + stdIndentG);
    if (NOT_NULL ((v->operatorSpecList)))
    {
    fprintf (f,",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"operatorSpecList ");
    PrintOperatorSpecList (f, (v->operatorSpecList), indent + stdIndentG);
    }
    if (NOT_NULL ((v->totalSevereReturnTax)))
    {
    fprintf (f,",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"totalSevereReturnTax ");
    PrintTotalSevereReturnTax (f, (v->totalSevereReturnTax), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintRapAuditControlInfo */

void
FreeRapAuditControlInfo PARAMS ((v),
RapAuditControlInfo *v)
{

    if (v == NULL)
        return;
    FreeTotalSevereReturnValue ((&v->totalSevereReturnValue));

    FreeReturnDetailsCount ((&v->returnDetailsCount));

    if (NOT_NULL ((v->operatorSpecList)))
    {
    FreeOperatorSpecList ((v->operatorSpecList));
    Asn1Free ((v->operatorSpecList));
    }

    if (NOT_NULL ((v->totalSevereReturnTax)))
    {
    FreeTotalSevereReturnTax ((v->totalSevereReturnTax));
    Asn1Free ((v->totalSevereReturnTax));
    }

}  /* FreeRapAuditControlInfo */




AsnLen
BEncErrorContextContent PARAMS ((b, v),
BUF_TYPE b _AND_
ErrorContext *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncItemLevelContent (b, (&v->itemLevel));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 548);

    totalLen += itemLen;

    if (NOT_NULL ((v->itemOccurrence)))
    {
    itemLen = BEncItemOccurrenceContent (b, (v->itemOccurrence));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 547);

    totalLen += itemLen;
    }

    itemLen = BEncPathItemIdContent (b, (&v->pathItemId));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 546);

    totalLen += itemLen;

    return totalLen;

}  /* BEncErrorContextContent */

void
BDecErrorContextContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ErrorContext *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (APPL, PRIM, 546))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecPathItemIdContent (b, tagId1, elmtLen1, (&v->pathItemId), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -129);


    if (((tagId1 == MAKE_TAG_ID (APPL, PRIM, 547))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->itemOccurrence) = (ItemOccurrence*) Asn1Alloc (sizeof (ItemOccurrence));
    CheckAsn1Alloc ((v->itemOccurrence), env);
    BDecItemOccurrenceContent (b, tagId1, elmtLen1, (v->itemOccurrence), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }


    if (((tagId1 == MAKE_TAG_ID (APPL, PRIM, 548))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecItemLevelContent (b, tagId1, elmtLen1, (&v->itemLevel), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -130);
    }
    else
        longjmp (env, -131);


    if (!seqDone)
        longjmp (env, -132);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecErrorContextContent */

void
PrintErrorContext PARAMS ((f, v, indent),
FILE* f _AND_
ErrorContext *v _AND_
unsigned short int indent)
{
    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    Indent (f, indent + stdIndentG);
    fprintf (f,"pathItemId ");
    PrintPathItemId (f, (&v->pathItemId), indent + stdIndentG);
    fprintf (f, ",\n");
    if (NOT_NULL ((v->itemOccurrence)))
    {
    Indent (f, indent + stdIndentG);
    fprintf (f,"itemOccurrence ");
    PrintItemOccurrence (f, (v->itemOccurrence), indent + stdIndentG);
    fprintf (f, ",\n");
    }
    Indent (f, indent + stdIndentG);
    fprintf (f,"itemLevel ");
    PrintItemLevel (f, (&v->itemLevel), indent + stdIndentG);
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintErrorContext */

void
FreeErrorContext PARAMS ((v),
ErrorContext *v)
{

    if (v == NULL)
        return;
    FreePathItemId ((&v->pathItemId));

    if (NOT_NULL ((v->itemOccurrence)))
    {
    FreeItemOccurrence ((v->itemOccurrence));
    Asn1Free ((v->itemOccurrence));
    }

    FreeItemLevel ((&v->itemLevel));

}  /* FreeErrorContext */




AsnLen
BEncErrorContextListContent PARAMS ((b, v),
BUF_TYPE b _AND_
ErrorContextList *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    BEncEocIfNec (b);
    itemLen = BEncErrorContextContent (b, component);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 545);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncErrorContextListContent */

void
BDecErrorContextListContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ErrorContextList *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        ErrorContext **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (APPL, CONS, 545)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (ErrorContext**) AsnListAppend (v);
    (*tmpVar) = (ErrorContext*) Asn1Alloc (sizeof (ErrorContext));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecErrorContextContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -133);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecErrorContextListContent */

void
PrintErrorContextList PARAMS ((f, v, indent),
FILE* f _AND_
ErrorContextList *v _AND_
unsigned short int indent)
{
    ErrorContext *tmp;
    if (v == NULL)
        return;
    fprintf (f,"{ -- SEQUENCE OF -- \n");
    FOR_EACH_LIST_ELMT (tmp, v)
    {
        Indent (f, indent+ stdIndentG);
        PrintErrorContext (f, tmp, indent + stdIndentG);
        if (tmp != (ErrorContext*)LAST_LIST_ELMT (v))
            fprintf (f,",\n");
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintErrorContextList */

void
FreeErrorContextList PARAMS ((v),
ErrorContextList *v)
{

    AsnListNode *l;
    AsnListNode *tmp;
    if (v == NULL)
        return;
    for (l = FIRST_LIST_NODE (v); l != NULL; )
    {
        FreeErrorContext ((l->data));
        tmp = l->next;
        Asn1Free (l->data);
        Asn1Free (l);
        l = tmp;
    }
}  /* FreeErrorContextList */




AsnLen
BEncErrorDetailContent PARAMS ((b, v),
BUF_TYPE b _AND_
ErrorDetail *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncErrorCodeContent (b, (&v->errorCode));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 519);

    totalLen += itemLen;

    if (NOT_NULL ((v->itemOffset)))
    {
    itemLen = BEncItemOffsetContent (b, (v->itemOffset));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 524);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->errorContext)))
    {
    BEncEocIfNec (b);
    itemLen = BEncErrorContextListContent (b, (v->errorContext));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 549);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncErrorDetailContent */

void
BDecErrorDetailContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ErrorDetail *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (APPL, CONS, 549))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->errorContext) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->errorContext), env);
    BDecErrorContextListContent (b, tagId1, elmtLen1, (v->errorContext), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }


    if (((tagId1 == MAKE_TAG_ID (APPL, PRIM, 524))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->itemOffset) = (ItemOffset*) Asn1Alloc (sizeof (ItemOffset));
    CheckAsn1Alloc ((v->itemOffset), env);
    BDecItemOffsetContent (b, tagId1, elmtLen1, (v->itemOffset), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }


    if (((tagId1 == MAKE_TAG_ID (APPL, PRIM, 519))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecErrorCodeContent (b, tagId1, elmtLen1, (&v->errorCode), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -134);
    }
    else
        longjmp (env, -135);


    if (!seqDone)
        longjmp (env, -136);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecErrorDetailContent */

void
PrintErrorDetail PARAMS ((f, v, indent),
FILE* f _AND_
ErrorDetail *v _AND_
unsigned short int indent)
{
    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->errorContext)))
    {
    Indent (f, indent + stdIndentG);
    fprintf (f,"errorContext ");
    PrintErrorContextList (f, (v->errorContext), indent + stdIndentG);
    fprintf (f, ",\n");
    }
    if (NOT_NULL ((v->itemOffset)))
    {
    Indent (f, indent + stdIndentG);
    fprintf (f,"itemOffset ");
    PrintItemOffset (f, (v->itemOffset), indent + stdIndentG);
    fprintf (f, ",\n");
    }
    Indent (f, indent + stdIndentG);
    fprintf (f,"errorCode ");
    PrintErrorCode (f, (&v->errorCode), indent + stdIndentG);
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintErrorDetail */

void
FreeErrorDetail PARAMS ((v),
ErrorDetail *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->errorContext)))
    {
    FreeErrorContextList ((v->errorContext));
    Asn1Free ((v->errorContext));
    }

    if (NOT_NULL ((v->itemOffset)))
    {
    FreeItemOffset ((v->itemOffset));
    Asn1Free ((v->itemOffset));
    }

    FreeErrorCode ((&v->errorCode));

}  /* FreeErrorDetail */




AsnLen
BEncErrorDetailListContent PARAMS ((b, v),
BUF_TYPE b _AND_
ErrorDetailList *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    BEncEocIfNec (b);
    itemLen = BEncErrorDetailContent (b, component);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 521);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncErrorDetailListContent */

void
BDecErrorDetailListContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ErrorDetailList *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        ErrorDetail **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (APPL, CONS, 521)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (ErrorDetail**) AsnListAppend (v);
    (*tmpVar) = (ErrorDetail*) Asn1Alloc (sizeof (ErrorDetail));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecErrorDetailContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -137);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecErrorDetailListContent */

void
PrintErrorDetailList PARAMS ((f, v, indent),
FILE* f _AND_
ErrorDetailList *v _AND_
unsigned short int indent)
{
    ErrorDetail *tmp;
    if (v == NULL)
        return;
    fprintf (f,"{ -- SEQUENCE OF -- \n");
    FOR_EACH_LIST_ELMT (tmp, v)
    {
        Indent (f, indent+ stdIndentG);
        PrintErrorDetail (f, tmp, indent + stdIndentG);
        if (tmp != (ErrorDetail*)LAST_LIST_ELMT (v))
            fprintf (f,",\n");
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintErrorDetailList */

void
FreeErrorDetailList PARAMS ((v),
ErrorDetailList *v)
{

    AsnListNode *l;
    AsnListNode *tmp;
    if (v == NULL)
        return;
    for (l = FIRST_LIST_NODE (v); l != NULL; )
    {
        FreeErrorDetail ((l->data));
        tmp = l->next;
        Asn1Free (l->data);
        Asn1Free (l);
        l = tmp;
    }
}  /* FreeErrorDetailList */




AsnLen
BEncMessageDescriptionInfoList1Content PARAMS ((b, v),
BUF_TYPE b _AND_
MessageDescriptionInfoList1 *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    BEncEocIfNec (b);
    itemLen = BEncMessageDescriptionInformationDefinitionContent (b, component);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 143);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncMessageDescriptionInfoList1Content */

void
BDecMessageDescriptionInfoList1Content PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
MessageDescriptionInfoList1 *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        MessageDescriptionInformationDefinition **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (APPL, CONS, 143)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (MessageDescriptionInformationDefinition**) AsnListAppend (v);
    (*tmpVar) = (MessageDescriptionInformationDefinition*) Asn1Alloc (sizeof (MessageDescriptionInformationDefinition));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecMessageDescriptionInformationDefinitionContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -138);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecMessageDescriptionInfoList1Content */

void
PrintMessageDescriptionInfoList1 PARAMS ((f, v, indent),
FILE* f _AND_
MessageDescriptionInfoList1 *v _AND_
unsigned short int indent)
{
    MessageDescriptionInformationDefinition *tmp;
    if (v == NULL)
        return;
    fprintf (f,"{ -- SEQUENCE OF -- \n");
    FOR_EACH_LIST_ELMT (tmp, v)
    {
        Indent (f, indent+ stdIndentG);
        PrintMessageDescriptionInformationDefinition (f, tmp, indent + stdIndentG);
        if (tmp != (MessageDescriptionInformationDefinition*)LAST_LIST_ELMT (v))
            fprintf (f,",\n");
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintMessageDescriptionInfoList1 */

void
FreeMessageDescriptionInfoList1 PARAMS ((v),
MessageDescriptionInfoList1 *v)
{

    AsnListNode *l;
    AsnListNode *tmp;
    if (v == NULL)
        return;
    for (l = FIRST_LIST_NODE (v); l != NULL; )
    {
        FreeMessageDescriptionInformationDefinition ((l->data));
        tmp = l->next;
        Asn1Free (l->data);
        Asn1Free (l);
        l = tmp;
    }
}  /* FreeMessageDescriptionInfoList1 */




AsnLen
BEncNetworkInfoErrorContent PARAMS ((b, v),
BUF_TYPE b _AND_
NetworkInfoError *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    BEncEocIfNec (b);
    itemLen = BEncErrorDetailListContent (b, (v->errorDetail));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 520);

    totalLen += itemLen;

    BEncEocIfNec (b);
    itemLen = BEncNetworkInfoContent (b, (v->networkInfo));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, APPL, CONS, 6);

    totalLen += itemLen;

    return totalLen;

}  /* BEncNetworkInfoErrorContent */

void
BDecNetworkInfoErrorContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
NetworkInfoError *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (APPL, CONS, 6))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->networkInfo) = (NetworkInfo*) Asn1Alloc (sizeof (NetworkInfo));
    CheckAsn1Alloc ((v->networkInfo), env);
    BDecNetworkInfoContent (b, tagId1, elmtLen1, (v->networkInfo), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -139);


    if (((tagId1 == MAKE_TAG_ID (APPL, CONS, 520))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->errorDetail) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->errorDetail), env);
    BDecErrorDetailListContent (b, tagId1, elmtLen1, (v->errorDetail), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -140);
    }
    else
        longjmp (env, -141);


    if (!seqDone)
        longjmp (env, -142);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecNetworkInfoErrorContent */

void
PrintNetworkInfoError PARAMS ((f, v, indent),
FILE* f _AND_
NetworkInfoError *v _AND_
unsigned short int indent)
{
    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    Indent (f, indent + stdIndentG);
    fprintf (f,"networkInfo ");
    PrintNetworkInfo (f, (v->networkInfo), indent + stdIndentG);
    fprintf (f, ",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"errorDetail ");
    PrintErrorDetailList (f, (v->errorDetail), indent + stdIndentG);
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintNetworkInfoError */

void
FreeNetworkInfoError PARAMS ((v),
NetworkInfoError *v)
{

    if (v == NULL)
        return;
    FreeNetworkInfo ((v->networkInfo));
    Asn1Free ((v->networkInfo));

    FreeErrorDetailList ((v->errorDetail));
    Asn1Free ((v->errorDetail));

}  /* FreeNetworkInfoError */




AsnLen
BEncNotificationErrorContent PARAMS ((b, v),
BUF_TYPE b _AND_
NotificationError *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    BEncEocIfNec (b);
    itemLen = BEncErrorDetailListContent (b, (v->errorDetail));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 520);

    totalLen += itemLen;

    BEncEocIfNec (b);
    itemLen = BEncNotificationContent (b, (v->notification));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, APPL, CONS, 2);

    totalLen += itemLen;

    return totalLen;

}  /* BEncNotificationErrorContent */

void
BDecNotificationErrorContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
NotificationError *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (APPL, CONS, 2))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->notification) = (Notification*) Asn1Alloc (sizeof (Notification));
    CheckAsn1Alloc ((v->notification), env);
    BDecNotificationContent (b, tagId1, elmtLen1, (v->notification), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -143);


    if (((tagId1 == MAKE_TAG_ID (APPL, CONS, 520))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->errorDetail) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->errorDetail), env);
    BDecErrorDetailListContent (b, tagId1, elmtLen1, (v->errorDetail), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -144);
    }
    else
        longjmp (env, -145);


    if (!seqDone)
        longjmp (env, -146);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecNotificationErrorContent */

void
PrintNotificationError PARAMS ((f, v, indent),
FILE* f _AND_
NotificationError *v _AND_
unsigned short int indent)
{
    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    Indent (f, indent + stdIndentG);
    fprintf (f,"notification ");
    PrintNotification (f, (v->notification), indent + stdIndentG);
    fprintf (f, ",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"errorDetail ");
    PrintErrorDetailList (f, (v->errorDetail), indent + stdIndentG);
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintNotificationError */

void
FreeNotificationError PARAMS ((v),
NotificationError *v)
{

    if (v == NULL)
        return;
    FreeNotification ((v->notification));
    Asn1Free ((v->notification));

    FreeErrorDetailList ((v->errorDetail));
    Asn1Free ((v->errorDetail));

}  /* FreeNotificationError */




AsnLen
BEncTransferBatchErrorContent PARAMS ((b, v),
BUF_TYPE b _AND_
TransferBatchError *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    BEncEocIfNec (b);
    itemLen = BEncErrorDetailListContent (b, (v->errorDetail));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 520);

    totalLen += itemLen;

    return totalLen;

}  /* BEncTransferBatchErrorContent */

void
BDecTransferBatchErrorContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
TransferBatchError *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (APPL, CONS, 520))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->errorDetail) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->errorDetail), env);
    BDecErrorDetailListContent (b, tagId1, elmtLen1, (v->errorDetail), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -147);
    }
    else
        longjmp (env, -148);


    if (!seqDone)
        longjmp (env, -149);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecTransferBatchErrorContent */

void
PrintTransferBatchError PARAMS ((f, v, indent),
FILE* f _AND_
TransferBatchError *v _AND_
unsigned short int indent)
{
    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    Indent (f, indent + stdIndentG);
    fprintf (f,"errorDetail ");
    PrintErrorDetailList (f, (v->errorDetail), indent + stdIndentG);
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintTransferBatchError */

void
FreeTransferBatchError PARAMS ((v),
TransferBatchError *v)
{

    if (v == NULL)
        return;
    FreeErrorDetailList ((v->errorDetail));
    Asn1Free ((v->errorDetail));

}  /* FreeTransferBatchError */




AsnLen
BEncSevereReturnContent PARAMS ((b, v),
BUF_TYPE b _AND_
SevereReturn *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->operatorSpecList)))
    {
    BEncEocIfNec (b);
    itemLen = BEncOperatorSpecListContent (b, (v->operatorSpecList));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 551);

    totalLen += itemLen;
    }

    BEncEocIfNec (b);
    itemLen = BEncErrorDetailListContent (b, (v->errorDetail));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 520);

    totalLen += itemLen;

    itemLen = BEncCallEventDetailContent (b, (v->callEventDetail));

    totalLen += itemLen;

    itemLen = BEncFileSequenceNumberContent (b, (&v->fileSequenceNumber));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, PRIM, 109);

    totalLen += itemLen;

    return totalLen;

}  /* BEncSevereReturnContent */

void
BDecSevereReturnContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SevereReturn *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (APPL, PRIM, 109)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 109))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecFileSequenceNumberContent (b, tagId1, elmtLen1, (&v->fileSequenceNumber), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -150);


    if (((tagId1 == MAKE_TAG_ID (APPL, CONS, 9)) ||
    (tagId1 == MAKE_TAG_ID (APPL, CONS, 10)) ||
    (tagId1 == MAKE_TAG_ID (APPL, CONS, 11)) ||
    (tagId1 == MAKE_TAG_ID (APPL, CONS, 12)) ||
    (tagId1 == MAKE_TAG_ID (APPL, CONS, 14)) ||
    (tagId1 == MAKE_TAG_ID (APPL, CONS, 17)) ||
    (tagId1 == MAKE_TAG_ID (APPL, CONS, 297)) ||
    (tagId1 == MAKE_TAG_ID (APPL, CONS, 433)) ||
    (tagId1 == MAKE_TAG_ID (APPL, CONS, 434))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->callEventDetail) = (CallEventDetail*) Asn1Alloc (sizeof (CallEventDetail));
    CheckAsn1Alloc ((v->callEventDetail), env);
    BDecCallEventDetailContent (b, tagId1, elmtLen1, (v->callEventDetail), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -151);


    if (((tagId1 == MAKE_TAG_ID (APPL, CONS, 520))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->errorDetail) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->errorDetail), env);
    BDecErrorDetailListContent (b, tagId1, elmtLen1, (v->errorDetail), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }
    else
        longjmp (env, -152);


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 551))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->operatorSpecList) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->operatorSpecList), env);
    BDecOperatorSpecListContent (b, tagId1, elmtLen1, (v->operatorSpecList), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -153);
    }


    if (!seqDone)
        longjmp (env, -154);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSevereReturnContent */

void
PrintSevereReturn PARAMS ((f, v, indent),
FILE* f _AND_
SevereReturn *v _AND_
unsigned short int indent)
{
    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    Indent (f, indent + stdIndentG);
    fprintf (f,"fileSequenceNumber ");
    PrintFileSequenceNumber (f, (&v->fileSequenceNumber), indent + stdIndentG);
    fprintf (f, ",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"callEventDetail ");
    PrintCallEventDetail (f, (v->callEventDetail), indent + stdIndentG);
    fprintf (f, ",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"errorDetail ");
    PrintErrorDetailList (f, (v->errorDetail), indent + stdIndentG);
    if (NOT_NULL ((v->operatorSpecList)))
    {
    fprintf (f,",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"operatorSpecList ");
    PrintOperatorSpecList (f, (v->operatorSpecList), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintSevereReturn */

void
FreeSevereReturn PARAMS ((v),
SevereReturn *v)
{

    if (v == NULL)
        return;
    FreeFileSequenceNumber ((&v->fileSequenceNumber));

    FreeCallEventDetail ((v->callEventDetail));
    Asn1Free ((v->callEventDetail));

    FreeErrorDetailList ((v->errorDetail));
    Asn1Free ((v->errorDetail));

    if (NOT_NULL ((v->operatorSpecList)))
    {
    FreeOperatorSpecList ((v->operatorSpecList));
    Asn1Free ((v->operatorSpecList));
    }

}  /* FreeSevereReturn */




AsnLen
BEncAccountingInfoErrorContent PARAMS ((b, v),
BUF_TYPE b _AND_
AccountingInfoError *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    BEncEocIfNec (b);
    itemLen = BEncErrorDetailListContent (b, (v->errorDetail));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 520);

    totalLen += itemLen;

    BEncEocIfNec (b);
    itemLen = BEncAccountingInfoContent (b, (v->accountingInfo));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, APPL, CONS, 5);

    totalLen += itemLen;

    return totalLen;

}  /* BEncAccountingInfoErrorContent */

void
BDecAccountingInfoErrorContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
AccountingInfoError *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (APPL, CONS, 5))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->accountingInfo) = (AccountingInfo*) Asn1Alloc (sizeof (AccountingInfo));
    CheckAsn1Alloc ((v->accountingInfo), env);
    BDecAccountingInfoContent (b, tagId1, elmtLen1, (v->accountingInfo), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -155);


    if (((tagId1 == MAKE_TAG_ID (APPL, CONS, 520))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->errorDetail) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->errorDetail), env);
    BDecErrorDetailListContent (b, tagId1, elmtLen1, (v->errorDetail), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -156);
    }
    else
        longjmp (env, -157);


    if (!seqDone)
        longjmp (env, -158);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecAccountingInfoErrorContent */

void
PrintAccountingInfoError PARAMS ((f, v, indent),
FILE* f _AND_
AccountingInfoError *v _AND_
unsigned short int indent)
{
    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    Indent (f, indent + stdIndentG);
    fprintf (f,"accountingInfo ");
    PrintAccountingInfo (f, (v->accountingInfo), indent + stdIndentG);
    fprintf (f, ",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"errorDetail ");
    PrintErrorDetailList (f, (v->errorDetail), indent + stdIndentG);
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintAccountingInfoError */

void
FreeAccountingInfoError PARAMS ((v),
AccountingInfoError *v)
{

    if (v == NULL)
        return;
    FreeAccountingInfo ((v->accountingInfo));
    Asn1Free ((v->accountingInfo));

    FreeErrorDetailList ((v->errorDetail));
    Asn1Free ((v->errorDetail));

}  /* FreeAccountingInfoError */




AsnLen
BEncAuditControlInfoErrorContent PARAMS ((b, v),
BUF_TYPE b _AND_
AuditControlInfoError *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    BEncEocIfNec (b);
    itemLen = BEncErrorDetailListContent (b, (v->errorDetail));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 520);

    totalLen += itemLen;

    BEncEocIfNec (b);
    itemLen = BEncAuditControlInfoContent (b, (v->auditControlInfo));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, APPL, CONS, 15);

    totalLen += itemLen;

    return totalLen;

}  /* BEncAuditControlInfoErrorContent */

void
BDecAuditControlInfoErrorContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
AuditControlInfoError *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (APPL, CONS, 15))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->auditControlInfo) = (AuditControlInfo*) Asn1Alloc (sizeof (AuditControlInfo));
    CheckAsn1Alloc ((v->auditControlInfo), env);
    BDecAuditControlInfoContent (b, tagId1, elmtLen1, (v->auditControlInfo), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -159);


    if (((tagId1 == MAKE_TAG_ID (APPL, CONS, 520))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->errorDetail) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->errorDetail), env);
    BDecErrorDetailListContent (b, tagId1, elmtLen1, (v->errorDetail), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -160);
    }
    else
        longjmp (env, -161);


    if (!seqDone)
        longjmp (env, -162);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecAuditControlInfoErrorContent */

void
PrintAuditControlInfoError PARAMS ((f, v, indent),
FILE* f _AND_
AuditControlInfoError *v _AND_
unsigned short int indent)
{
    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    Indent (f, indent + stdIndentG);
    fprintf (f,"auditControlInfo ");
    PrintAuditControlInfo (f, (v->auditControlInfo), indent + stdIndentG);
    fprintf (f, ",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"errorDetail ");
    PrintErrorDetailList (f, (v->errorDetail), indent + stdIndentG);
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintAuditControlInfoError */

void
FreeAuditControlInfoError PARAMS ((v),
AuditControlInfoError *v)
{

    if (v == NULL)
        return;
    FreeAuditControlInfo ((v->auditControlInfo));
    Asn1Free ((v->auditControlInfo));

    FreeErrorDetailList ((v->errorDetail));
    Asn1Free ((v->errorDetail));

}  /* FreeAuditControlInfoError */




AsnLen
BEncBatchControlErrorContent PARAMS ((b, v),
BUF_TYPE b _AND_
BatchControlError *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    BEncEocIfNec (b);
    itemLen = BEncErrorDetailListContent (b, (v->errorDetail));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 520);

    totalLen += itemLen;

    BEncEocIfNec (b);
    itemLen = BEncBatchControlInfoContent (b, (v->batchControlInfo));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, APPL, CONS, 4);

    totalLen += itemLen;

    return totalLen;

}  /* BEncBatchControlErrorContent */

void
BDecBatchControlErrorContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
BatchControlError *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (APPL, CONS, 4))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->batchControlInfo) = (BatchControlInfo*) Asn1Alloc (sizeof (BatchControlInfo));
    CheckAsn1Alloc ((v->batchControlInfo), env);
    BDecBatchControlInfoContent (b, tagId1, elmtLen1, (v->batchControlInfo), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -163);


    if (((tagId1 == MAKE_TAG_ID (APPL, CONS, 520))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->errorDetail) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->errorDetail), env);
    BDecErrorDetailListContent (b, tagId1, elmtLen1, (v->errorDetail), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -164);
    }
    else
        longjmp (env, -165);


    if (!seqDone)
        longjmp (env, -166);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecBatchControlErrorContent */

void
PrintBatchControlError PARAMS ((f, v, indent),
FILE* f _AND_
BatchControlError *v _AND_
unsigned short int indent)
{
    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    Indent (f, indent + stdIndentG);
    fprintf (f,"batchControlInfo ");
    PrintBatchControlInfo (f, (v->batchControlInfo), indent + stdIndentG);
    fprintf (f, ",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"errorDetail ");
    PrintErrorDetailList (f, (v->errorDetail), indent + stdIndentG);
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintBatchControlError */

void
FreeBatchControlError PARAMS ((v),
BatchControlError *v)
{

    if (v == NULL)
        return;
    FreeBatchControlInfo ((v->batchControlInfo));
    Asn1Free ((v->batchControlInfo));

    FreeErrorDetailList ((v->errorDetail));
    Asn1Free ((v->errorDetail));

}  /* FreeBatchControlError */




AsnLen
BEncMessageDescriptionErrorContent PARAMS ((b, v),
BUF_TYPE b _AND_
MessageDescriptionError *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    BEncEocIfNec (b);
    itemLen = BEncErrorDetailListContent (b, (v->errorDetail));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 520);

    totalLen += itemLen;

    BEncEocIfNec (b);
    itemLen = BEncMessageDescriptionInfoList1Content (b, (v->messageDescriptionInfo));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, APPL, CONS, 8);

    totalLen += itemLen;

    return totalLen;

}  /* BEncMessageDescriptionErrorContent */

void
BDecMessageDescriptionErrorContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
MessageDescriptionError *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (APPL, CONS, 8))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->messageDescriptionInfo) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->messageDescriptionInfo), env);
    BDecMessageDescriptionInfoList1Content (b, tagId1, elmtLen1, (v->messageDescriptionInfo), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -167);


    if (((tagId1 == MAKE_TAG_ID (APPL, CONS, 520))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->errorDetail) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->errorDetail), env);
    BDecErrorDetailListContent (b, tagId1, elmtLen1, (v->errorDetail), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -168);
    }
    else
        longjmp (env, -169);


    if (!seqDone)
        longjmp (env, -170);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecMessageDescriptionErrorContent */

void
PrintMessageDescriptionError PARAMS ((f, v, indent),
FILE* f _AND_
MessageDescriptionError *v _AND_
unsigned short int indent)
{
    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    Indent (f, indent + stdIndentG);
    fprintf (f,"messageDescriptionInfo ");
    PrintMessageDescriptionInfoList1 (f, (v->messageDescriptionInfo), indent + stdIndentG);
    fprintf (f, ",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"errorDetail ");
    PrintErrorDetailList (f, (v->errorDetail), indent + stdIndentG);
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintMessageDescriptionError */

void
FreeMessageDescriptionError PARAMS ((v),
MessageDescriptionError *v)
{

    if (v == NULL)
        return;
    FreeMessageDescriptionInfoList1 ((v->messageDescriptionInfo));
    Asn1Free ((v->messageDescriptionInfo));

    FreeErrorDetailList ((v->errorDetail));
    Asn1Free ((v->errorDetail));

}  /* FreeMessageDescriptionError */




AsnLen
BEncFatalReturnContent PARAMS ((b, v),
BUF_TYPE b _AND_
FatalReturn *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->operatorSpecList)))
    {
    BEncEocIfNec (b);
    itemLen = BEncOperatorSpecListContent (b, (v->operatorSpecList));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 551);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->auditControlInfoError)))
    {
    BEncEocIfNec (b);
    itemLen = BEncAuditControlInfoErrorContent (b, (v->auditControlInfoError));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 513);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->messageDescriptionError)))
    {
    BEncEocIfNec (b);
    itemLen = BEncMessageDescriptionErrorContent (b, (v->messageDescriptionError));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 522);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->networkInfoError)))
    {
    BEncEocIfNec (b);
    itemLen = BEncNetworkInfoErrorContent (b, (v->networkInfoError));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 523);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->accountingInfoError)))
    {
    BEncEocIfNec (b);
    itemLen = BEncAccountingInfoErrorContent (b, (v->accountingInfoError));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 512);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->batchControlError)))
    {
    BEncEocIfNec (b);
    itemLen = BEncBatchControlErrorContent (b, (v->batchControlError));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 517);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->notificationError)))
    {
    BEncEocIfNec (b);
    itemLen = BEncNotificationErrorContent (b, (v->notificationError));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 552);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->transferBatchError)))
    {
    BEncEocIfNec (b);
    itemLen = BEncTransferBatchErrorContent (b, (v->transferBatchError));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 542);

    totalLen += itemLen;
    }

    itemLen = BEncFileSequenceNumberContent (b, (&v->fileSequenceNumber));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, PRIM, 109);

    totalLen += itemLen;

    return totalLen;

}  /* BEncFatalReturnContent */

void
BDecFatalReturnContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
FatalReturn *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (APPL, PRIM, 109)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 109))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecFileSequenceNumberContent (b, tagId1, elmtLen1, (&v->fileSequenceNumber), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }
    else
        longjmp (env, -171);


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 542))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->transferBatchError) = (TransferBatchError*) Asn1Alloc (sizeof (TransferBatchError));
    CheckAsn1Alloc ((v->transferBatchError), env);
    BDecTransferBatchErrorContent (b, tagId1, elmtLen1, (v->transferBatchError), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 552))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->notificationError) = (NotificationError*) Asn1Alloc (sizeof (NotificationError));
    CheckAsn1Alloc ((v->notificationError), env);
    BDecNotificationErrorContent (b, tagId1, elmtLen1, (v->notificationError), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 517))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->batchControlError) = (BatchControlError*) Asn1Alloc (sizeof (BatchControlError));
    CheckAsn1Alloc ((v->batchControlError), env);
    BDecBatchControlErrorContent (b, tagId1, elmtLen1, (v->batchControlError), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 512))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->accountingInfoError) = (AccountingInfoError*) Asn1Alloc (sizeof (AccountingInfoError));
    CheckAsn1Alloc ((v->accountingInfoError), env);
    BDecAccountingInfoErrorContent (b, tagId1, elmtLen1, (v->accountingInfoError), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 523))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->networkInfoError) = (NetworkInfoError*) Asn1Alloc (sizeof (NetworkInfoError));
    CheckAsn1Alloc ((v->networkInfoError), env);
    BDecNetworkInfoErrorContent (b, tagId1, elmtLen1, (v->networkInfoError), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 522))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->messageDescriptionError) = (MessageDescriptionError*) Asn1Alloc (sizeof (MessageDescriptionError));
    CheckAsn1Alloc ((v->messageDescriptionError), env);
    BDecMessageDescriptionErrorContent (b, tagId1, elmtLen1, (v->messageDescriptionError), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 513))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->auditControlInfoError) = (AuditControlInfoError*) Asn1Alloc (sizeof (AuditControlInfoError));
    CheckAsn1Alloc ((v->auditControlInfoError), env);
    BDecAuditControlInfoErrorContent (b, tagId1, elmtLen1, (v->auditControlInfoError), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 551))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->operatorSpecList) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->operatorSpecList), env);
    BDecOperatorSpecListContent (b, tagId1, elmtLen1, (v->operatorSpecList), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -172);
    }


    if (!seqDone)
        longjmp (env, -173);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecFatalReturnContent */

void
PrintFatalReturn PARAMS ((f, v, indent),
FILE* f _AND_
FatalReturn *v _AND_
unsigned short int indent)
{
    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    Indent (f, indent + stdIndentG);
    fprintf (f,"fileSequenceNumber ");
    PrintFileSequenceNumber (f, (&v->fileSequenceNumber), indent + stdIndentG);
    if (NOT_NULL ((v->transferBatchError)))
    {
    fprintf (f,",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"transferBatchError ");
    PrintTransferBatchError (f, (v->transferBatchError), indent + stdIndentG);
    }
    if (NOT_NULL ((v->notificationError)))
    {
    fprintf (f,",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"notificationError ");
    PrintNotificationError (f, (v->notificationError), indent + stdIndentG);
    }
    if (NOT_NULL ((v->batchControlError)))
    {
    fprintf (f,",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"batchControlError ");
    PrintBatchControlError (f, (v->batchControlError), indent + stdIndentG);
    }
    if (NOT_NULL ((v->accountingInfoError)))
    {
    fprintf (f,",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"accountingInfoError ");
    PrintAccountingInfoError (f, (v->accountingInfoError), indent + stdIndentG);
    }
    if (NOT_NULL ((v->networkInfoError)))
    {
    fprintf (f,",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"networkInfoError ");
    PrintNetworkInfoError (f, (v->networkInfoError), indent + stdIndentG);
    }
    if (NOT_NULL ((v->messageDescriptionError)))
    {
    fprintf (f,",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"messageDescriptionError ");
    PrintMessageDescriptionError (f, (v->messageDescriptionError), indent + stdIndentG);
    }
    if (NOT_NULL ((v->auditControlInfoError)))
    {
    fprintf (f,",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"auditControlInfoError ");
    PrintAuditControlInfoError (f, (v->auditControlInfoError), indent + stdIndentG);
    }
    if (NOT_NULL ((v->operatorSpecList)))
    {
    fprintf (f,",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"operatorSpecList ");
    PrintOperatorSpecList (f, (v->operatorSpecList), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintFatalReturn */

void
FreeFatalReturn PARAMS ((v),
FatalReturn *v)
{

    if (v == NULL)
        return;
    FreeFileSequenceNumber ((&v->fileSequenceNumber));

    if (NOT_NULL ((v->transferBatchError)))
    {
    FreeTransferBatchError ((v->transferBatchError));
    Asn1Free ((v->transferBatchError));
    }

    if (NOT_NULL ((v->notificationError)))
    {
    FreeNotificationError ((v->notificationError));
    Asn1Free ((v->notificationError));
    }

    if (NOT_NULL ((v->batchControlError)))
    {
    FreeBatchControlError ((v->batchControlError));
    Asn1Free ((v->batchControlError));
    }

    if (NOT_NULL ((v->accountingInfoError)))
    {
    FreeAccountingInfoError ((v->accountingInfoError));
    Asn1Free ((v->accountingInfoError));
    }

    if (NOT_NULL ((v->networkInfoError)))
    {
    FreeNetworkInfoError ((v->networkInfoError));
    Asn1Free ((v->networkInfoError));
    }

    if (NOT_NULL ((v->messageDescriptionError)))
    {
    FreeMessageDescriptionError ((v->messageDescriptionError));
    Asn1Free ((v->messageDescriptionError));
    }

    if (NOT_NULL ((v->auditControlInfoError)))
    {
    FreeAuditControlInfoError ((v->auditControlInfoError));
    Asn1Free ((v->auditControlInfoError));
    }

    if (NOT_NULL ((v->operatorSpecList)))
    {
    FreeOperatorSpecList ((v->operatorSpecList));
    Asn1Free ((v->operatorSpecList));
    }

}  /* FreeFatalReturn */




AsnLen
BEncReturnDetailContent PARAMS ((b, v),
BUF_TYPE b _AND_
ReturnDetail *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    switch (v->choiceId)
    {
       case RETURNDETAIL_STOPRETURN:
    BEncEocIfNec (b);
    itemLen = BEncStopReturnContent (b, (v->a.stopReturn));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 554);

    totalLen += itemLen;

    break;

       case RETURNDETAIL_MISSINGRETURN:
    BEncEocIfNec (b);
    itemLen = BEncMissingReturnContent (b, (v->a.missingReturn));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 538);

    totalLen += itemLen;

    break;

       case RETURNDETAIL_FATALRETURN:
    BEncEocIfNec (b);
    itemLen = BEncFatalReturnContent (b, (v->a.fatalReturn));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 539);

    totalLen += itemLen;

    break;

       case RETURNDETAIL_SEVERERETURN:
    BEncEocIfNec (b);
    itemLen = BEncSevereReturnContent (b, (v->a.severeReturn));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 540);

    totalLen += itemLen;

    break;

    }
    return totalLen;

}  /* BEncReturnDetailContent */

void
BDecReturnDetailContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ReturnDetail *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    switch (tagId0)
    {
       case MAKE_TAG_ID (APPL, CONS, 554):
        (v->choiceId) = RETURNDETAIL_STOPRETURN;
    (v->a.stopReturn) = (StopReturn*) Asn1Alloc (sizeof (StopReturn));
    CheckAsn1Alloc ((v->a.stopReturn), env);
    BDecStopReturnContent (b, tagId0, elmtLen0, (v->a.stopReturn), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (APPL, CONS, 538):
        (v->choiceId) = RETURNDETAIL_MISSINGRETURN;
    (v->a.missingReturn) = (MissingReturn*) Asn1Alloc (sizeof (MissingReturn));
    CheckAsn1Alloc ((v->a.missingReturn), env);
    BDecMissingReturnContent (b, tagId0, elmtLen0, (v->a.missingReturn), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (APPL, CONS, 539):
        (v->choiceId) = RETURNDETAIL_FATALRETURN;
    (v->a.fatalReturn) = (FatalReturn*) Asn1Alloc (sizeof (FatalReturn));
    CheckAsn1Alloc ((v->a.fatalReturn), env);
    BDecFatalReturnContent (b, tagId0, elmtLen0, (v->a.fatalReturn), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (APPL, CONS, 540):
        (v->choiceId) = RETURNDETAIL_SEVERERETURN;
    (v->a.severeReturn) = (SevereReturn*) Asn1Alloc (sizeof (SevereReturn));
    CheckAsn1Alloc ((v->a.severeReturn), env);
    BDecSevereReturnContent (b, tagId0, elmtLen0, (v->a.severeReturn), &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("ERROR - unexpected tag in CHOICE\n");
        longjmp (env, -174);
        break;
    } /* end switch */
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecReturnDetailContent */

void
PrintReturnDetail PARAMS ((f, v, indent),
FILE* f _AND_
ReturnDetail *v _AND_
unsigned short int indent)
{
    switch (v->choiceId)
    {
      case RETURNDETAIL_STOPRETURN:
          fprintf (f,"stopReturn ");
    PrintStopReturn (f, (v->a.stopReturn), indent + stdIndentG);
          break;

      case RETURNDETAIL_MISSINGRETURN:
          fprintf (f,"missingReturn ");
    PrintMissingReturn (f, (v->a.missingReturn), indent + stdIndentG);
          break;

      case RETURNDETAIL_FATALRETURN:
          fprintf (f,"fatalReturn ");
    PrintFatalReturn (f, (v->a.fatalReturn), indent + stdIndentG);
          break;

      case RETURNDETAIL_SEVERERETURN:
          fprintf (f,"severeReturn ");
    PrintSevereReturn (f, (v->a.severeReturn), indent + stdIndentG);
          break;

    }
}  /* PrintReturnDetail */

void
FreeReturnDetail PARAMS ((v),
ReturnDetail *v)
{

    if (v == NULL)
        return;
    switch (v->choiceId)
    {
       case RETURNDETAIL_STOPRETURN:
    FreeStopReturn ((v->a.stopReturn));
    Asn1Free ((v->a.stopReturn));

    break;

       case RETURNDETAIL_MISSINGRETURN:
    FreeMissingReturn ((v->a.missingReturn));
    Asn1Free ((v->a.missingReturn));

    break;

       case RETURNDETAIL_FATALRETURN:
    FreeFatalReturn ((v->a.fatalReturn));
    Asn1Free ((v->a.fatalReturn));

    break;

       case RETURNDETAIL_SEVERERETURN:
    FreeSevereReturn ((v->a.severeReturn));
    Asn1Free ((v->a.severeReturn));

    break;

    }
}  /* FreeReturnDetail */




AsnLen
BEncReturnDetailListContent PARAMS ((b, v),
BUF_TYPE b _AND_
ReturnDetailList *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    itemLen = BEncReturnDetailContent (b, component);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncReturnDetailListContent */

void
BDecReturnDetailListContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ReturnDetailList *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        ReturnDetail **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (ReturnDetail**) AsnListAppend (v);
    (*tmpVar) = (ReturnDetail*) Asn1Alloc (sizeof (ReturnDetail));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecReturnDetailContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecReturnDetailListContent */

void
PrintReturnDetailList PARAMS ((f, v, indent),
FILE* f _AND_
ReturnDetailList *v _AND_
unsigned short int indent)
{
    ReturnDetail *tmp;
    if (v == NULL)
        return;
    fprintf (f,"{ -- SEQUENCE OF -- \n");
    FOR_EACH_LIST_ELMT (tmp, v)
    {
        Indent (f, indent+ stdIndentG);
        PrintReturnDetail (f, tmp, indent + stdIndentG);
        if (tmp != (ReturnDetail*)LAST_LIST_ELMT (v))
            fprintf (f,",\n");
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintReturnDetailList */

void
FreeReturnDetailList PARAMS ((v),
ReturnDetailList *v)
{

    AsnListNode *l;
    AsnListNode *tmp;
    if (v == NULL)
        return;
    for (l = FIRST_LIST_NODE (v); l != NULL; )
    {
        FreeReturnDetail ((l->data));
        tmp = l->next;
        Asn1Free (l->data);
        Asn1Free (l);
        l = tmp;
    }
}  /* FreeReturnDetailList */




AsnLen
BEncReturnBatchContent PARAMS ((b, v),
BUF_TYPE b _AND_
ReturnBatch *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    BEncEocIfNec (b);
    itemLen = BEncRapAuditControlInfoContent (b, (v->rapAuditControlInfo));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 541);

    totalLen += itemLen;

    BEncEocIfNec (b);
    itemLen = BEncReturnDetailListContent (b, (v->returnDetails));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 536);

    totalLen += itemLen;

    BEncEocIfNec (b);
    itemLen = BEncRapBatchControlInfoContent (b, (v->rapBatchControlInfoRap));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 537);

    totalLen += itemLen;

    return totalLen;

}  /* BEncReturnBatchContent */

void
BDecReturnBatchContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ReturnBatch *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (APPL, CONS, 537))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->rapBatchControlInfoRap) = (RapBatchControlInfo*) Asn1Alloc (sizeof (RapBatchControlInfo));
    CheckAsn1Alloc ((v->rapBatchControlInfoRap), env);
    BDecRapBatchControlInfoContent (b, tagId1, elmtLen1, (v->rapBatchControlInfoRap), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -175);


    if (((tagId1 == MAKE_TAG_ID (APPL, CONS, 536))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->returnDetails) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->returnDetails), env);
    BDecReturnDetailListContent (b, tagId1, elmtLen1, (v->returnDetails), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -176);


    if (((tagId1 == MAKE_TAG_ID (APPL, CONS, 541))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->rapAuditControlInfo) = (RapAuditControlInfo*) Asn1Alloc (sizeof (RapAuditControlInfo));
    CheckAsn1Alloc ((v->rapAuditControlInfo), env);
    BDecRapAuditControlInfoContent (b, tagId1, elmtLen1, (v->rapAuditControlInfo), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -177);
    }
    else
        longjmp (env, -178);


    if (!seqDone)
        longjmp (env, -179);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecReturnBatchContent */

void
PrintReturnBatch PARAMS ((f, v, indent),
FILE* f _AND_
ReturnBatch *v _AND_
unsigned short int indent)
{
    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    Indent (f, indent + stdIndentG);
    fprintf (f,"rapBatchControlInfoRap ");
    PrintRapBatchControlInfo (f, (v->rapBatchControlInfoRap), indent + stdIndentG);
    fprintf (f, ",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"returnDetails ");
    PrintReturnDetailList (f, (v->returnDetails), indent + stdIndentG);
    fprintf (f, ",\n");
    Indent (f, indent + stdIndentG);
    fprintf (f,"rapAuditControlInfo ");
    PrintRapAuditControlInfo (f, (v->rapAuditControlInfo), indent + stdIndentG);
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintReturnBatch */

void
FreeReturnBatch PARAMS ((v),
ReturnBatch *v)
{

    if (v == NULL)
        return;
    FreeRapBatchControlInfo ((v->rapBatchControlInfoRap));
    Asn1Free ((v->rapBatchControlInfoRap));

    FreeReturnDetailList ((v->returnDetails));
    Asn1Free ((v->returnDetails));

    FreeRapAuditControlInfo ((v->rapAuditControlInfo));
    Asn1Free ((v->rapAuditControlInfo));

}  /* FreeReturnBatch */




AsnLen
BEncRapDataInterChangeContent PARAMS ((b, v),
BUF_TYPE b _AND_
RapDataInterChange *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    switch (v->choiceId)
    {
       case RAPDATAINTERCHANGE_RETURNBATCH:
    BEncEocIfNec (b);
    itemLen = BEncReturnBatchContent (b, (v->a.returnBatch));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 534);

    totalLen += itemLen;

    break;

       case RAPDATAINTERCHANGE_ACKNOWLEDGEMENT:
    BEncEocIfNec (b);
    itemLen = BEncAcknowledgementContent (b, (v->a.acknowledgement));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 535);

    totalLen += itemLen;

    break;

    }
    return totalLen;

}  /* BEncRapDataInterChangeContent */

void
BDecRapDataInterChangeContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
RapDataInterChange *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    switch (tagId0)
    {
       case MAKE_TAG_ID (APPL, CONS, 534):
        (v->choiceId) = RAPDATAINTERCHANGE_RETURNBATCH;
    (v->a.returnBatch) = (ReturnBatch*) Asn1Alloc (sizeof (ReturnBatch));
    CheckAsn1Alloc ((v->a.returnBatch), env);
    BDecReturnBatchContent (b, tagId0, elmtLen0, (v->a.returnBatch), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (APPL, CONS, 535):
        (v->choiceId) = RAPDATAINTERCHANGE_ACKNOWLEDGEMENT;
    (v->a.acknowledgement) = (Acknowledgement*) Asn1Alloc (sizeof (Acknowledgement));
    CheckAsn1Alloc ((v->a.acknowledgement), env);
    BDecAcknowledgementContent (b, tagId0, elmtLen0, (v->a.acknowledgement), &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("ERROR - unexpected tag in CHOICE\n");
        longjmp (env, -180);
        break;
    } /* end switch */
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecRapDataInterChangeContent */

void
PrintRapDataInterChange PARAMS ((f, v, indent),
FILE* f _AND_
RapDataInterChange *v _AND_
unsigned short int indent)
{
    switch (v->choiceId)
    {
      case RAPDATAINTERCHANGE_RETURNBATCH:
          fprintf (f,"returnBatch ");
    PrintReturnBatch (f, (v->a.returnBatch), indent + stdIndentG);
          break;

      case RAPDATAINTERCHANGE_ACKNOWLEDGEMENT:
          fprintf (f,"acknowledgement ");
    PrintAcknowledgement (f, (v->a.acknowledgement), indent + stdIndentG);
          break;

    }
}  /* PrintRapDataInterChange */

void
FreeRapDataInterChange PARAMS ((v),
RapDataInterChange *v)
{

    if (v == NULL)
        return;
    switch (v->choiceId)
    {
       case RAPDATAINTERCHANGE_RETURNBATCH:
    FreeReturnBatch ((v->a.returnBatch));
    Asn1Free ((v->a.returnBatch));

    break;

       case RAPDATAINTERCHANGE_ACKNOWLEDGEMENT:
    FreeAcknowledgement ((v->a.acknowledgement));
    Asn1Free ((v->a.acknowledgement));

    break;

    }
}  /* FreeRapDataInterChange */




