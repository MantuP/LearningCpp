/*
 *    tap312.c
 *
 *    "TAP-0312" ASN.1 module encode/decode/print/free C src.
 *
 *    This file was generated by snacc on Thu Jun 20 18:26:18 2013
 *
 *    UBC snacc written by Mike Sample
 *
 *    NOTE: This is a machine generated file - editing not recommended
 */



#include "asn-incl.h"
#include "tap312.h"


AsnLen
BEncCallTypeGroupContent PARAMS ((b, v),
BUF_TYPE b _AND_
CallTypeGroup *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->callTypeLevel3)))
    {
    itemLen = BEncCallTypeLevel3Content (b, (v->callTypeLevel3));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 256);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->callTypeLevel2)))
    {
    itemLen = BEncCallTypeLevel2Content (b, (v->callTypeLevel2));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 255);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->callTypeLevel1)))
    {
    itemLen = BEncCallTypeLevel1Content (b, (v->callTypeLevel1));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 259);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncCallTypeGroupContent */

void
BDecCallTypeGroupContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
CallTypeGroup *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 259))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->callTypeLevel1) = (CallTypeLevel1*) Asn1Alloc (sizeof (CallTypeLevel1));
    CheckAsn1Alloc ((v->callTypeLevel1), env);
    BDecCallTypeLevel1Content (b, tagId1, elmtLen1, (v->callTypeLevel1), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 255))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->callTypeLevel2) = (CallTypeLevel2*) Asn1Alloc (sizeof (CallTypeLevel2));
    CheckAsn1Alloc ((v->callTypeLevel2), env);
    BDecCallTypeLevel2Content (b, tagId1, elmtLen1, (v->callTypeLevel2), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 256))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->callTypeLevel3) = (CallTypeLevel3*) Asn1Alloc (sizeof (CallTypeLevel3));
    CheckAsn1Alloc ((v->callTypeLevel3), env);
    BDecCallTypeLevel3Content (b, tagId1, elmtLen1, (v->callTypeLevel3), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -100);
    }


    if (!seqDone)
        longjmp (env, -101);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecCallTypeGroupContent */

void
PrintCallTypeGroup PARAMS ((f, v, indent),
FILE* f _AND_
CallTypeGroup *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->callTypeLevel1)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"callTypeLevel1 ");
    PrintCallTypeLevel1 (f, (v->callTypeLevel1), indent + stdIndentG);
    }
    if (NOT_NULL ((v->callTypeLevel2)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"callTypeLevel2 ");
    PrintCallTypeLevel2 (f, (v->callTypeLevel2), indent + stdIndentG);
    }
    if (NOT_NULL ((v->callTypeLevel3)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"callTypeLevel3 ");
    PrintCallTypeLevel3 (f, (v->callTypeLevel3), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintCallTypeGroup */

void
FreeCallTypeGroup PARAMS ((v),
CallTypeGroup *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->callTypeLevel1)))
    {
    FreeCallTypeLevel1 ((v->callTypeLevel1));
    Asn1Free ((v->callTypeLevel1));
    }

    if (NOT_NULL ((v->callTypeLevel2)))
    {
    FreeCallTypeLevel2 ((v->callTypeLevel2));
    Asn1Free ((v->callTypeLevel2));
    }

    if (NOT_NULL ((v->callTypeLevel3)))
    {
    FreeCallTypeLevel3 ((v->callTypeLevel3));
    Asn1Free ((v->callTypeLevel3));
    }

}  /* FreeCallTypeGroup */




AsnLen
BEncGprsDestinationContent PARAMS ((b, v),
BUF_TYPE b _AND_
GprsDestination *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (ASNOCTS_PRESENT ((&v->accessPointNameOI)))
    {
    itemLen = BEncAccessPointNameOIContent (b, (&v->accessPointNameOI));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 262);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->accessPointNameNI)))
    {
    itemLen = BEncAccessPointNameNIContent (b, (&v->accessPointNameNI));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 261);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncGprsDestinationContent */

void
BDecGprsDestinationContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GprsDestination *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 261)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 261))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecAccessPointNameNIContent (b, tagId1, elmtLen1, (&v->accessPointNameNI), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 262)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 262))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecAccessPointNameOIContent (b, tagId1, elmtLen1, (&v->accessPointNameOI), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -102);
    }


    if (!seqDone)
        longjmp (env, -103);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGprsDestinationContent */

void
PrintGprsDestination PARAMS ((f, v, indent),
FILE* f _AND_
GprsDestination *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (ASNOCTS_PRESENT ((&v->accessPointNameNI)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"accessPointNameNI ");
    PrintAccessPointNameNI (f, (&v->accessPointNameNI), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->accessPointNameOI)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"accessPointNameOI ");
    PrintAccessPointNameOI (f, (&v->accessPointNameOI), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintGprsDestination */

void
FreeGprsDestination PARAMS ((v),
GprsDestination *v)
{

    if (v == NULL)
        return;
    if (ASNOCTS_PRESENT ((&v->accessPointNameNI)))
    {
    FreeAccessPointNameNI ((&v->accessPointNameNI));
    }

    if (ASNOCTS_PRESENT ((&v->accessPointNameOI)))
    {
    FreeAccessPointNameOI ((&v->accessPointNameOI));
    }

}  /* FreeGprsDestination */




AsnLen
BEncImeiOrEsnContent PARAMS ((b, v),
BUF_TYPE b _AND_
ImeiOrEsn *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    switch (v->choiceId)
    {
       case IMEIORESN_IMEI:
    itemLen = BEncImeiContent (b, (v->a.imei));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 128);

    totalLen += itemLen;

    break;

       case IMEIORESN_ESN:
    itemLen = BEncEsnContent (b, (v->a.esn));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, PRIM, 103);

    totalLen += itemLen;

    break;

    }
    return totalLen;

}  /* BEncImeiOrEsnContent */

void
BDecImeiOrEsnContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ImeiOrEsn *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    switch (tagId0)
    {
       case MAKE_TAG_ID (APPL, PRIM, 128):
       case MAKE_TAG_ID (APPL, CONS, 128):
        (v->choiceId) = IMEIORESN_IMEI;
    (v->a.imei) = (Imei*) Asn1Alloc (sizeof (Imei));
    CheckAsn1Alloc ((v->a.imei), env);
    BDecImeiContent (b, tagId0, elmtLen0, (v->a.imei), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (APPL, PRIM, 103):
       case MAKE_TAG_ID (APPL, CONS, 103):
        (v->choiceId) = IMEIORESN_ESN;
    (v->a.esn) = (Esn*) Asn1Alloc (sizeof (Esn));
    CheckAsn1Alloc ((v->a.esn), env);
    BDecEsnContent (b, tagId0, elmtLen0, (v->a.esn), &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("ERROR - unexpected tag in CHOICE\n");
        longjmp (env, -104);
        break;
    } /* end switch */
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecImeiOrEsnContent */

void
PrintImeiOrEsn PARAMS ((f, v, indent),
FILE* f _AND_
ImeiOrEsn *v _AND_
unsigned short int indent)
{
    switch (v->choiceId)
    {
      case IMEIORESN_IMEI:
          fprintf (f,"imei ");
    PrintImei (f, (v->a.imei), indent + stdIndentG);
          break;

      case IMEIORESN_ESN:
          fprintf (f,"esn ");
    PrintEsn (f, (v->a.esn), indent + stdIndentG);
          break;

    }
}  /* PrintImeiOrEsn */

void
FreeImeiOrEsn PARAMS ((v),
ImeiOrEsn *v)
{

    if (v == NULL)
        return;
    switch (v->choiceId)
    {
       case IMEIORESN_IMEI:
    FreeImei ((v->a.imei));
    Asn1Free ((v->a.imei));

    break;

       case IMEIORESN_ESN:
    FreeEsn ((v->a.esn));
    Asn1Free ((v->a.esn));

    break;

    }
}  /* FreeImeiOrEsn */




AsnLen
BEncNetworkContent PARAMS ((b, v),
BUF_TYPE b _AND_
Network *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (ASNOCTS_PRESENT ((&v->networkIdentifier)))
    {
    itemLen = BEncNetworkIdentifierContent (b, (&v->networkIdentifier));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 295);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->networkIdType)))
    {
    itemLen = BEncNetworkIdTypeContent (b, (v->networkIdType));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 331);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncNetworkContent */

void
BDecNetworkContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
Network *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 331))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->networkIdType) = (NetworkIdType*) Asn1Alloc (sizeof (NetworkIdType));
    CheckAsn1Alloc ((v->networkIdType), env);
    BDecNetworkIdTypeContent (b, tagId1, elmtLen1, (v->networkIdType), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 295)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 295))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecNetworkIdentifierContent (b, tagId1, elmtLen1, (&v->networkIdentifier), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -105);
    }


    if (!seqDone)
        longjmp (env, -106);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecNetworkContent */

void
PrintNetwork PARAMS ((f, v, indent),
FILE* f _AND_
Network *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->networkIdType)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"networkIdType ");
    PrintNetworkIdType (f, (v->networkIdType), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->networkIdentifier)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"networkIdentifier ");
    PrintNetworkIdentifier (f, (&v->networkIdentifier), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintNetwork */

void
FreeNetwork PARAMS ((v),
Network *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->networkIdType)))
    {
    FreeNetworkIdType ((v->networkIdType));
    Asn1Free ((v->networkIdType));
    }

    if (ASNOCTS_PRESENT ((&v->networkIdentifier)))
    {
    FreeNetworkIdentifier ((&v->networkIdentifier));
    }

}  /* FreeNetwork */




AsnLen
BEncNetworkListContent PARAMS ((b, v),
BUF_TYPE b _AND_
NetworkList *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    BEncEocIfNec (b);
    itemLen = BEncNetworkContent (b, component);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 332);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncNetworkListContent */

void
BDecNetworkListContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
NetworkList *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        Network **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (APPL, CONS, 332)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (Network**) AsnListAppend (v);
    (*tmpVar) = (Network*) Asn1Alloc (sizeof (Network));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecNetworkContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -107);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecNetworkListContent */

void
PrintNetworkList PARAMS ((f, v, indent),
FILE* f _AND_
NetworkList *v _AND_
unsigned short int indent)
{
    Network *tmp;
    if (v == NULL)
        return;
    fprintf (f,"{ -- SEQUENCE OF -- \n");
    FOR_EACH_LIST_ELMT (tmp, v)
    {
        Indent (f, indent+ stdIndentG);
        PrintNetwork (f, tmp, indent + stdIndentG);
        if (tmp != (Network*)LAST_LIST_ELMT (v))
            fprintf (f,",\n");
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintNetworkList */

void
FreeNetworkList PARAMS ((v),
NetworkList *v)
{

    AsnListNode *l;
    AsnListNode *tmp;
    if (v == NULL)
        return;
    for (l = FIRST_LIST_NODE (v); l != NULL; )
    {
        FreeNetwork ((l->data));
        tmp = l->next;
        Asn1Free (l->data);
        Asn1Free (l);
        l = tmp;
    }
}  /* FreeNetworkList */




AsnLen
BEncLCSQosDeliveredContent PARAMS ((b, v),
BUF_TYPE b _AND_
LCSQosDelivered *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->ageOfLocation)))
    {
    itemLen = BEncAgeOfLocationContent (b, (v->ageOfLocation));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 396);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->trackingFrequency)))
    {
    itemLen = BEncTrackingFrequencyContent (b, (v->trackingFrequency));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 389);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->trackingPeriod)))
    {
    itemLen = BEncTrackingPeriodContent (b, (v->trackingPeriod));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 388);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->positioningMethod)))
    {
    itemLen = BEncPositioningMethodContent (b, (v->positioningMethod));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 395);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->responseTime)))
    {
    itemLen = BEncResponseTimeContent (b, (v->responseTime));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 394);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->verticalAccuracyDelivered)))
    {
    itemLen = BEncVerticalAccuracyDeliveredContent (b, (v->verticalAccuracyDelivered));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 393);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->horizontalAccuracyDelivered)))
    {
    itemLen = BEncHorizontalAccuracyDeliveredContent (b, (v->horizontalAccuracyDelivered));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 392);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->lCSTransactionStatus)))
    {
    itemLen = BEncLCSTransactionStatusContent (b, (v->lCSTransactionStatus));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 391);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncLCSQosDeliveredContent */

void
BDecLCSQosDeliveredContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
LCSQosDelivered *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 391))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->lCSTransactionStatus) = (LCSTransactionStatus*) Asn1Alloc (sizeof (LCSTransactionStatus));
    CheckAsn1Alloc ((v->lCSTransactionStatus), env);
    BDecLCSTransactionStatusContent (b, tagId1, elmtLen1, (v->lCSTransactionStatus), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 392))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->horizontalAccuracyDelivered) = (HorizontalAccuracyDelivered*) Asn1Alloc (sizeof (HorizontalAccuracyDelivered));
    CheckAsn1Alloc ((v->horizontalAccuracyDelivered), env);
    BDecHorizontalAccuracyDeliveredContent (b, tagId1, elmtLen1, (v->horizontalAccuracyDelivered), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 393))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->verticalAccuracyDelivered) = (VerticalAccuracyDelivered*) Asn1Alloc (sizeof (VerticalAccuracyDelivered));
    CheckAsn1Alloc ((v->verticalAccuracyDelivered), env);
    BDecVerticalAccuracyDeliveredContent (b, tagId1, elmtLen1, (v->verticalAccuracyDelivered), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 394))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->responseTime) = (ResponseTime*) Asn1Alloc (sizeof (ResponseTime));
    CheckAsn1Alloc ((v->responseTime), env);
    BDecResponseTimeContent (b, tagId1, elmtLen1, (v->responseTime), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 395))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->positioningMethod) = (PositioningMethod*) Asn1Alloc (sizeof (PositioningMethod));
    CheckAsn1Alloc ((v->positioningMethod), env);
    BDecPositioningMethodContent (b, tagId1, elmtLen1, (v->positioningMethod), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 388))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->trackingPeriod) = (TrackingPeriod*) Asn1Alloc (sizeof (TrackingPeriod));
    CheckAsn1Alloc ((v->trackingPeriod), env);
    BDecTrackingPeriodContent (b, tagId1, elmtLen1, (v->trackingPeriod), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 389))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->trackingFrequency) = (TrackingFrequency*) Asn1Alloc (sizeof (TrackingFrequency));
    CheckAsn1Alloc ((v->trackingFrequency), env);
    BDecTrackingFrequencyContent (b, tagId1, elmtLen1, (v->trackingFrequency), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 396))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->ageOfLocation) = (AgeOfLocation*) Asn1Alloc (sizeof (AgeOfLocation));
    CheckAsn1Alloc ((v->ageOfLocation), env);
    BDecAgeOfLocationContent (b, tagId1, elmtLen1, (v->ageOfLocation), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -108);
    }


    if (!seqDone)
        longjmp (env, -109);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecLCSQosDeliveredContent */

void
PrintLCSQosDelivered PARAMS ((f, v, indent),
FILE* f _AND_
LCSQosDelivered *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->lCSTransactionStatus)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"lCSTransactionStatus ");
    PrintLCSTransactionStatus (f, (v->lCSTransactionStatus), indent + stdIndentG);
    }
    if (NOT_NULL ((v->horizontalAccuracyDelivered)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"horizontalAccuracyDelivered ");
    PrintHorizontalAccuracyDelivered (f, (v->horizontalAccuracyDelivered), indent + stdIndentG);
    }
    if (NOT_NULL ((v->verticalAccuracyDelivered)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"verticalAccuracyDelivered ");
    PrintVerticalAccuracyDelivered (f, (v->verticalAccuracyDelivered), indent + stdIndentG);
    }
    if (NOT_NULL ((v->responseTime)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"responseTime ");
    PrintResponseTime (f, (v->responseTime), indent + stdIndentG);
    }
    if (NOT_NULL ((v->positioningMethod)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"positioningMethod ");
    PrintPositioningMethod (f, (v->positioningMethod), indent + stdIndentG);
    }
    if (NOT_NULL ((v->trackingPeriod)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"trackingPeriod ");
    PrintTrackingPeriod (f, (v->trackingPeriod), indent + stdIndentG);
    }
    if (NOT_NULL ((v->trackingFrequency)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"trackingFrequency ");
    PrintTrackingFrequency (f, (v->trackingFrequency), indent + stdIndentG);
    }
    if (NOT_NULL ((v->ageOfLocation)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"ageOfLocation ");
    PrintAgeOfLocation (f, (v->ageOfLocation), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintLCSQosDelivered */

void
FreeLCSQosDelivered PARAMS ((v),
LCSQosDelivered *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->lCSTransactionStatus)))
    {
    FreeLCSTransactionStatus ((v->lCSTransactionStatus));
    Asn1Free ((v->lCSTransactionStatus));
    }

    if (NOT_NULL ((v->horizontalAccuracyDelivered)))
    {
    FreeHorizontalAccuracyDelivered ((v->horizontalAccuracyDelivered));
    Asn1Free ((v->horizontalAccuracyDelivered));
    }

    if (NOT_NULL ((v->verticalAccuracyDelivered)))
    {
    FreeVerticalAccuracyDelivered ((v->verticalAccuracyDelivered));
    Asn1Free ((v->verticalAccuracyDelivered));
    }

    if (NOT_NULL ((v->responseTime)))
    {
    FreeResponseTime ((v->responseTime));
    Asn1Free ((v->responseTime));
    }

    if (NOT_NULL ((v->positioningMethod)))
    {
    FreePositioningMethod ((v->positioningMethod));
    Asn1Free ((v->positioningMethod));
    }

    if (NOT_NULL ((v->trackingPeriod)))
    {
    FreeTrackingPeriod ((v->trackingPeriod));
    Asn1Free ((v->trackingPeriod));
    }

    if (NOT_NULL ((v->trackingFrequency)))
    {
    FreeTrackingFrequency ((v->trackingFrequency));
    Asn1Free ((v->trackingFrequency));
    }

    if (NOT_NULL ((v->ageOfLocation)))
    {
    FreeAgeOfLocation ((v->ageOfLocation));
    Asn1Free ((v->ageOfLocation));
    }

}  /* FreeLCSQosDelivered */




AsnLen
BEncLCSSPIdentificationContent PARAMS ((b, v),
BUF_TYPE b _AND_
LCSSPIdentification *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (ASNOCTS_PRESENT ((&v->contentProviderIdentifier)))
    {
    itemLen = BEncContentProviderIdentifierContent (b, (&v->contentProviderIdentifier));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 292);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->contentProviderIdType)))
    {
    itemLen = BEncContentProviderIdTypeContent (b, (v->contentProviderIdType));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 291);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncLCSSPIdentificationContent */

void
BDecLCSSPIdentificationContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
LCSSPIdentification *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 291))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->contentProviderIdType) = (ContentProviderIdType*) Asn1Alloc (sizeof (ContentProviderIdType));
    CheckAsn1Alloc ((v->contentProviderIdType), env);
    BDecContentProviderIdTypeContent (b, tagId1, elmtLen1, (v->contentProviderIdType), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 292)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 292))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecContentProviderIdentifierContent (b, tagId1, elmtLen1, (&v->contentProviderIdentifier), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -110);
    }


    if (!seqDone)
        longjmp (env, -111);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecLCSSPIdentificationContent */

void
PrintLCSSPIdentification PARAMS ((f, v, indent),
FILE* f _AND_
LCSSPIdentification *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->contentProviderIdType)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"contentProviderIdType ");
    PrintContentProviderIdType (f, (v->contentProviderIdType), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->contentProviderIdentifier)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"contentProviderIdentifier ");
    PrintContentProviderIdentifier (f, (&v->contentProviderIdentifier), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintLCSSPIdentification */

void
FreeLCSSPIdentification PARAMS ((v),
LCSSPIdentification *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->contentProviderIdType)))
    {
    FreeContentProviderIdType ((v->contentProviderIdType));
    Asn1Free ((v->contentProviderIdType));
    }

    if (ASNOCTS_PRESENT ((&v->contentProviderIdentifier)))
    {
    FreeContentProviderIdentifier ((&v->contentProviderIdentifier));
    }

}  /* FreeLCSSPIdentification */




AsnLen
BEncLCSSPIdentificationListContent PARAMS ((b, v),
BUF_TYPE b _AND_
LCSSPIdentificationList *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    BEncEocIfNec (b);
    itemLen = BEncLCSSPIdentificationContent (b, component);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 375);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncLCSSPIdentificationListContent */

void
BDecLCSSPIdentificationListContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
LCSSPIdentificationList *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        LCSSPIdentification **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (APPL, CONS, 375)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (LCSSPIdentification**) AsnListAppend (v);
    (*tmpVar) = (LCSSPIdentification*) Asn1Alloc (sizeof (LCSSPIdentification));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecLCSSPIdentificationContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -112);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecLCSSPIdentificationListContent */

void
PrintLCSSPIdentificationList PARAMS ((f, v, indent),
FILE* f _AND_
LCSSPIdentificationList *v _AND_
unsigned short int indent)
{
    LCSSPIdentification *tmp;
    if (v == NULL)
        return;
    fprintf (f,"{ -- SEQUENCE OF -- \n");
    FOR_EACH_LIST_ELMT (tmp, v)
    {
        Indent (f, indent+ stdIndentG);
        PrintLCSSPIdentification (f, tmp, indent + stdIndentG);
        if (tmp != (LCSSPIdentification*)LAST_LIST_ELMT (v))
            fprintf (f,",\n");
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintLCSSPIdentificationList */

void
FreeLCSSPIdentificationList PARAMS ((v),
LCSSPIdentificationList *v)
{

    AsnListNode *l;
    AsnListNode *tmp;
    if (v == NULL)
        return;
    for (l = FIRST_LIST_NODE (v); l != NULL; )
    {
        FreeLCSSPIdentification ((l->data));
        tmp = l->next;
        Asn1Free (l->data);
        Asn1Free (l);
        l = tmp;
    }
}  /* FreeLCSSPIdentificationList */




AsnLen
BEncMessageDescriptionInformationContent PARAMS ((b, v),
BUF_TYPE b _AND_
MessageDescriptionInformation *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (ASNOCTS_PRESENT ((&v->messageDescription)))
    {
    itemLen = BEncMessageDescriptionContent (b, (&v->messageDescription));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 142);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->messageDescriptionCode)))
    {
    itemLen = BEncMessageDescriptionCodeContent (b, (v->messageDescriptionCode));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 141);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncMessageDescriptionInformationContent */

void
BDecMessageDescriptionInformationContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
MessageDescriptionInformation *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 141))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->messageDescriptionCode) = (MessageDescriptionCode*) Asn1Alloc (sizeof (MessageDescriptionCode));
    CheckAsn1Alloc ((v->messageDescriptionCode), env);
    BDecMessageDescriptionCodeContent (b, tagId1, elmtLen1, (v->messageDescriptionCode), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 142)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 142))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecMessageDescriptionContent (b, tagId1, elmtLen1, (&v->messageDescription), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -113);
    }


    if (!seqDone)
        longjmp (env, -114);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecMessageDescriptionInformationContent */

void
PrintMessageDescriptionInformation PARAMS ((f, v, indent),
FILE* f _AND_
MessageDescriptionInformation *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->messageDescriptionCode)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"messageDescriptionCode ");
    PrintMessageDescriptionCode (f, (v->messageDescriptionCode), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->messageDescription)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"messageDescription ");
    PrintMessageDescription (f, (&v->messageDescription), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintMessageDescriptionInformation */

void
FreeMessageDescriptionInformation PARAMS ((v),
MessageDescriptionInformation *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->messageDescriptionCode)))
    {
    FreeMessageDescriptionCode ((v->messageDescriptionCode));
    Asn1Free ((v->messageDescriptionCode));
    }

    if (ASNOCTS_PRESENT ((&v->messageDescription)))
    {
    FreeMessageDescription ((&v->messageDescription));
    }

}  /* FreeMessageDescriptionInformation */




AsnLen
BEncMinChargeableSubscriberContent PARAMS ((b, v),
BUF_TYPE b _AND_
MinChargeableSubscriber *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (ASNOCTS_PRESENT ((&v->mdn)))
    {
    itemLen = BEncMdnContent (b, (&v->mdn));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 253);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->min)))
    {
    itemLen = BEncMinContent (b, (&v->min));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 146);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncMinChargeableSubscriberContent */

void
BDecMinChargeableSubscriberContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
MinChargeableSubscriber *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 146)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 146))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecMinContent (b, tagId1, elmtLen1, (&v->min), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 253)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 253))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecMdnContent (b, tagId1, elmtLen1, (&v->mdn), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -115);
    }


    if (!seqDone)
        longjmp (env, -116);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecMinChargeableSubscriberContent */

void
PrintMinChargeableSubscriber PARAMS ((f, v, indent),
FILE* f _AND_
MinChargeableSubscriber *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (ASNOCTS_PRESENT ((&v->min)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"min ");
    PrintMin (f, (&v->min), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->mdn)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"mdn ");
    PrintMdn (f, (&v->mdn), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintMinChargeableSubscriber */

void
FreeMinChargeableSubscriber PARAMS ((v),
MinChargeableSubscriber *v)
{

    if (v == NULL)
        return;
    if (ASNOCTS_PRESENT ((&v->min)))
    {
    FreeMin ((&v->min));
    }

    if (ASNOCTS_PRESENT ((&v->mdn)))
    {
    FreeMdn ((&v->mdn));
    }

}  /* FreeMinChargeableSubscriber */




AsnLen
BEncNetworkElementContent PARAMS ((b, v),
BUF_TYPE b _AND_
NetworkElement *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (ASNOCTS_PRESENT ((&v->elementId)))
    {
    itemLen = BEncElementIdContent (b, (&v->elementId));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 437);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->elementType)))
    {
    itemLen = BEncElementTypeContent (b, (v->elementType));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 438);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncNetworkElementContent */

void
BDecNetworkElementContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
NetworkElement *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 438))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->elementType) = (ElementType*) Asn1Alloc (sizeof (ElementType));
    CheckAsn1Alloc ((v->elementType), env);
    BDecElementTypeContent (b, tagId1, elmtLen1, (v->elementType), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 437)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 437))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecElementIdContent (b, tagId1, elmtLen1, (&v->elementId), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -117);
    }


    if (!seqDone)
        longjmp (env, -118);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecNetworkElementContent */

void
PrintNetworkElement PARAMS ((f, v, indent),
FILE* f _AND_
NetworkElement *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->elementType)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"elementType ");
    PrintElementType (f, (v->elementType), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->elementId)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"elementId ");
    PrintElementId (f, (&v->elementId), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintNetworkElement */

void
FreeNetworkElement PARAMS ((v),
NetworkElement *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->elementType)))
    {
    FreeElementType ((v->elementType));
    Asn1Free ((v->elementType));
    }

    if (ASNOCTS_PRESENT ((&v->elementId)))
    {
    FreeElementId ((&v->elementId));
    }

}  /* FreeNetworkElement */




AsnLen
BEncNetworkElementListContent PARAMS ((b, v),
BUF_TYPE b _AND_
NetworkElementList *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    BEncEocIfNec (b);
    itemLen = BEncNetworkElementContent (b, component);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 441);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncNetworkElementListContent */

void
BDecNetworkElementListContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
NetworkElementList *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        NetworkElement **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (APPL, CONS, 441)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (NetworkElement**) AsnListAppend (v);
    (*tmpVar) = (NetworkElement*) Asn1Alloc (sizeof (NetworkElement));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecNetworkElementContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -119);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecNetworkElementListContent */

void
PrintNetworkElementList PARAMS ((f, v, indent),
FILE* f _AND_
NetworkElementList *v _AND_
unsigned short int indent)
{
    NetworkElement *tmp;
    if (v == NULL)
        return;
    fprintf (f,"{ -- SEQUENCE OF -- \n");
    FOR_EACH_LIST_ELMT (tmp, v)
    {
        Indent (f, indent+ stdIndentG);
        PrintNetworkElement (f, tmp, indent + stdIndentG);
        if (tmp != (NetworkElement*)LAST_LIST_ELMT (v))
            fprintf (f,",\n");
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintNetworkElementList */

void
FreeNetworkElementList PARAMS ((v),
NetworkElementList *v)
{

    AsnListNode *l;
    AsnListNode *tmp;
    if (v == NULL)
        return;
    for (l = FIRST_LIST_NODE (v); l != NULL; )
    {
        FreeNetworkElement ((l->data));
        tmp = l->next;
        Asn1Free (l->data);
        Asn1Free (l);
        l = tmp;
    }
}  /* FreeNetworkElementList */




AsnLen
BEncRecEntityCodeListContent PARAMS ((b, v),
BUF_TYPE b _AND_
RecEntityCodeList *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    itemLen = BEncRecEntityCodeContent (b, component);
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 184);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncRecEntityCodeListContent */

void
BDecRecEntityCodeListContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
RecEntityCodeList *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        RecEntityCode **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 184)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (RecEntityCode**) AsnListAppend (v);
    (*tmpVar) = (RecEntityCode*) Asn1Alloc (sizeof (RecEntityCode));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecRecEntityCodeContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -120);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecRecEntityCodeListContent */

void
PrintRecEntityCodeList PARAMS ((f, v, indent),
FILE* f _AND_
RecEntityCodeList *v _AND_
unsigned short int indent)
{
    RecEntityCode *tmp;
    if (v == NULL)
        return;
    fprintf (f,"{ -- SEQUENCE OF -- \n");
    FOR_EACH_LIST_ELMT (tmp, v)
    {
        Indent (f, indent+ stdIndentG);
        PrintRecEntityCode (f, tmp, indent + stdIndentG);
        if (tmp != (RecEntityCode*)LAST_LIST_ELMT (v))
            fprintf (f,",\n");
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintRecEntityCodeList */

void
FreeRecEntityCodeList PARAMS ((v),
RecEntityCodeList *v)
{

    AsnListNode *l;
    AsnListNode *tmp;
    if (v == NULL)
        return;
    for (l = FIRST_LIST_NODE (v); l != NULL; )
    {
        FreeRecEntityCode ((l->data));
        tmp = l->next;
        Asn1Free (l->data);
        Asn1Free (l);
        l = tmp;
    }
}  /* FreeRecEntityCodeList */




AsnLen
BEncRecEntityInformationContent PARAMS ((b, v),
BUF_TYPE b _AND_
RecEntityInformation *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (ASNOCTS_PRESENT ((&v->recEntityId)))
    {
    itemLen = BEncRecEntityIdContent (b, (&v->recEntityId));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 400);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->recEntityType)))
    {
    itemLen = BEncRecEntityTypeContent (b, (v->recEntityType));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 186);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->recEntityCode)))
    {
    itemLen = BEncRecEntityCodeContent (b, (v->recEntityCode));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 184);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncRecEntityInformationContent */

void
BDecRecEntityInformationContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
RecEntityInformation *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 184))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->recEntityCode) = (RecEntityCode*) Asn1Alloc (sizeof (RecEntityCode));
    CheckAsn1Alloc ((v->recEntityCode), env);
    BDecRecEntityCodeContent (b, tagId1, elmtLen1, (v->recEntityCode), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 186))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->recEntityType) = (RecEntityType*) Asn1Alloc (sizeof (RecEntityType));
    CheckAsn1Alloc ((v->recEntityType), env);
    BDecRecEntityTypeContent (b, tagId1, elmtLen1, (v->recEntityType), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 400)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 400))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecRecEntityIdContent (b, tagId1, elmtLen1, (&v->recEntityId), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -121);
    }


    if (!seqDone)
        longjmp (env, -122);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecRecEntityInformationContent */

void
PrintRecEntityInformation PARAMS ((f, v, indent),
FILE* f _AND_
RecEntityInformation *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->recEntityCode)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"recEntityCode ");
    PrintRecEntityCode (f, (v->recEntityCode), indent + stdIndentG);
    }
    if (NOT_NULL ((v->recEntityType)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"recEntityType ");
    PrintRecEntityType (f, (v->recEntityType), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->recEntityId)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"recEntityId ");
    PrintRecEntityId (f, (&v->recEntityId), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintRecEntityInformation */

void
FreeRecEntityInformation PARAMS ((v),
RecEntityInformation *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->recEntityCode)))
    {
    FreeRecEntityCode ((v->recEntityCode));
    Asn1Free ((v->recEntityCode));
    }

    if (NOT_NULL ((v->recEntityType)))
    {
    FreeRecEntityType ((v->recEntityType));
    Asn1Free ((v->recEntityType));
    }

    if (ASNOCTS_PRESENT ((&v->recEntityId)))
    {
    FreeRecEntityId ((&v->recEntityId));
    }

}  /* FreeRecEntityInformation */




AsnLen
BEncScuChargeTypeContent PARAMS ((b, v),
BUF_TYPE b _AND_
ScuChargeType *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->messageDescriptionCode)))
    {
    itemLen = BEncMessageDescriptionCodeContent (b, (v->messageDescriptionCode));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 141);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->messageType)))
    {
    itemLen = BEncMessageTypeContent (b, (v->messageType));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 145);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->distanceChargeBandCode)))
    {
    itemLen = BEncDistanceChargeBandCodeContent (b, (&v->distanceChargeBandCode));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, PRIM, 98);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->priorityCode)))
    {
    itemLen = BEncPriorityCodeContent (b, (v->priorityCode));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 170);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->messageStatus)))
    {
    itemLen = BEncMessageStatusContent (b, (v->messageStatus));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 144);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncScuChargeTypeContent */

void
BDecScuChargeTypeContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ScuChargeType *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 144))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->messageStatus) = (MessageStatus*) Asn1Alloc (sizeof (MessageStatus));
    CheckAsn1Alloc ((v->messageStatus), env);
    BDecMessageStatusContent (b, tagId1, elmtLen1, (v->messageStatus), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 170))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->priorityCode) = (PriorityCode*) Asn1Alloc (sizeof (PriorityCode));
    CheckAsn1Alloc ((v->priorityCode), env);
    BDecPriorityCodeContent (b, tagId1, elmtLen1, (v->priorityCode), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 98)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 98))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecDistanceChargeBandCodeContent (b, tagId1, elmtLen1, (&v->distanceChargeBandCode), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 145))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->messageType) = (MessageType*) Asn1Alloc (sizeof (MessageType));
    CheckAsn1Alloc ((v->messageType), env);
    BDecMessageTypeContent (b, tagId1, elmtLen1, (v->messageType), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 141))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->messageDescriptionCode) = (MessageDescriptionCode*) Asn1Alloc (sizeof (MessageDescriptionCode));
    CheckAsn1Alloc ((v->messageDescriptionCode), env);
    BDecMessageDescriptionCodeContent (b, tagId1, elmtLen1, (v->messageDescriptionCode), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -123);
    }


    if (!seqDone)
        longjmp (env, -124);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecScuChargeTypeContent */

void
PrintScuChargeType PARAMS ((f, v, indent),
FILE* f _AND_
ScuChargeType *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->messageStatus)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"messageStatus ");
    PrintMessageStatus (f, (v->messageStatus), indent + stdIndentG);
    }
    if (NOT_NULL ((v->priorityCode)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"priorityCode ");
    PrintPriorityCode (f, (v->priorityCode), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->distanceChargeBandCode)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"distanceChargeBandCode ");
    PrintDistanceChargeBandCode (f, (&v->distanceChargeBandCode), indent + stdIndentG);
    }
    if (NOT_NULL ((v->messageType)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"messageType ");
    PrintMessageType (f, (v->messageType), indent + stdIndentG);
    }
    if (NOT_NULL ((v->messageDescriptionCode)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"messageDescriptionCode ");
    PrintMessageDescriptionCode (f, (v->messageDescriptionCode), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintScuChargeType */

void
FreeScuChargeType PARAMS ((v),
ScuChargeType *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->messageStatus)))
    {
    FreeMessageStatus ((v->messageStatus));
    Asn1Free ((v->messageStatus));
    }

    if (NOT_NULL ((v->priorityCode)))
    {
    FreePriorityCode ((v->priorityCode));
    Asn1Free ((v->priorityCode));
    }

    if (ASNOCTS_PRESENT ((&v->distanceChargeBandCode)))
    {
    FreeDistanceChargeBandCode ((&v->distanceChargeBandCode));
    }

    if (NOT_NULL ((v->messageType)))
    {
    FreeMessageType ((v->messageType));
    Asn1Free ((v->messageType));
    }

    if (NOT_NULL ((v->messageDescriptionCode)))
    {
    FreeMessageDescriptionCode ((v->messageDescriptionCode));
    Asn1Free ((v->messageDescriptionCode));
    }

}  /* FreeScuChargeType */




AsnLen
BEncSimChargeableSubscriberContent PARAMS ((b, v),
BUF_TYPE b _AND_
SimChargeableSubscriber *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (ASNOCTS_PRESENT ((&v->msisdn)))
    {
    itemLen = BEncMsisdnContent (b, (&v->msisdn));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 152);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->imsi)))
    {
    itemLen = BEncImsiContent (b, (&v->imsi));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 129);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncSimChargeableSubscriberContent */

void
BDecSimChargeableSubscriberContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SimChargeableSubscriber *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 129)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 129))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecImsiContent (b, tagId1, elmtLen1, (&v->imsi), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 152)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 152))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecMsisdnContent (b, tagId1, elmtLen1, (&v->msisdn), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -125);
    }


    if (!seqDone)
        longjmp (env, -126);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSimChargeableSubscriberContent */

void
PrintSimChargeableSubscriber PARAMS ((f, v, indent),
FILE* f _AND_
SimChargeableSubscriber *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (ASNOCTS_PRESENT ((&v->imsi)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"imsi ");
    PrintImsi (f, (&v->imsi), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->msisdn)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"msisdn ");
    PrintMsisdn (f, (&v->msisdn), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintSimChargeableSubscriber */

void
FreeSimChargeableSubscriber PARAMS ((v),
SimChargeableSubscriber *v)
{

    if (v == NULL)
        return;
    if (ASNOCTS_PRESENT ((&v->imsi)))
    {
    FreeImsi ((&v->imsi));
    }

    if (ASNOCTS_PRESENT ((&v->msisdn)))
    {
    FreeMsisdn ((&v->msisdn));
    }

}  /* FreeSimChargeableSubscriber */




AsnLen
BEncThreeGcamelDestinationContent PARAMS ((b, v),
BUF_TYPE b _AND_
ThreeGcamelDestination *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    switch (v->choiceId)
    {
       case THREEGCAMELDESTINATION_CAMELDESTINATIONNUMBER:
    itemLen = BEncCamelDestinationNumberContent (b, (v->a.camelDestinationNumber));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 404);

    totalLen += itemLen;

    break;

       case THREEGCAMELDESTINATION_GPRSDESTINATION:
    BEncEocIfNec (b);
    itemLen = BEncGprsDestinationContent (b, (v->a.gprsDestination));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 116);

    totalLen += itemLen;

    break;

    }
    return totalLen;

}  /* BEncThreeGcamelDestinationContent */

void
BDecThreeGcamelDestinationContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ThreeGcamelDestination *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    switch (tagId0)
    {
       case MAKE_TAG_ID (APPL, PRIM, 404):
       case MAKE_TAG_ID (APPL, CONS, 404):
        (v->choiceId) = THREEGCAMELDESTINATION_CAMELDESTINATIONNUMBER;
    (v->a.camelDestinationNumber) = (CamelDestinationNumber*) Asn1Alloc (sizeof (CamelDestinationNumber));
    CheckAsn1Alloc ((v->a.camelDestinationNumber), env);
    BDecCamelDestinationNumberContent (b, tagId0, elmtLen0, (v->a.camelDestinationNumber), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (APPL, CONS, 116):
        (v->choiceId) = THREEGCAMELDESTINATION_GPRSDESTINATION;
    (v->a.gprsDestination) = (GprsDestination*) Asn1Alloc (sizeof (GprsDestination));
    CheckAsn1Alloc ((v->a.gprsDestination), env);
    BDecGprsDestinationContent (b, tagId0, elmtLen0, (v->a.gprsDestination), &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("ERROR - unexpected tag in CHOICE\n");
        longjmp (env, -127);
        break;
    } /* end switch */
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecThreeGcamelDestinationContent */

void
PrintThreeGcamelDestination PARAMS ((f, v, indent),
FILE* f _AND_
ThreeGcamelDestination *v _AND_
unsigned short int indent)
{
    switch (v->choiceId)
    {
      case THREEGCAMELDESTINATION_CAMELDESTINATIONNUMBER:
          fprintf (f,"camelDestinationNumber ");
    PrintCamelDestinationNumber (f, (v->a.camelDestinationNumber), indent + stdIndentG);
          break;

      case THREEGCAMELDESTINATION_GPRSDESTINATION:
          fprintf (f,"gprsDestination ");
    PrintGprsDestination (f, (v->a.gprsDestination), indent + stdIndentG);
          break;

    }
}  /* PrintThreeGcamelDestination */

void
FreeThreeGcamelDestination PARAMS ((v),
ThreeGcamelDestination *v)
{

    if (v == NULL)
        return;
    switch (v->choiceId)
    {
       case THREEGCAMELDESTINATION_CAMELDESTINATIONNUMBER:
    FreeCamelDestinationNumber ((v->a.camelDestinationNumber));
    Asn1Free ((v->a.camelDestinationNumber));

    break;

       case THREEGCAMELDESTINATION_GPRSDESTINATION:
    FreeGprsDestination ((v->a.gprsDestination));
    Asn1Free ((v->a.gprsDestination));

    break;

    }
}  /* FreeThreeGcamelDestination */




AsnLen
BEncTrackedCustomerEquipmentContent PARAMS ((b, v),
BUF_TYPE b _AND_
TrackedCustomerEquipment *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (ASNOCTS_PRESENT ((&v->equipmentId)))
    {
    itemLen = BEncEquipmentIdContent (b, (&v->equipmentId));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 290);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->equipmentIdType)))
    {
    itemLen = BEncEquipmentIdTypeContent (b, (v->equipmentIdType));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 322);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncTrackedCustomerEquipmentContent */

void
BDecTrackedCustomerEquipmentContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
TrackedCustomerEquipment *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 322))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->equipmentIdType) = (EquipmentIdType*) Asn1Alloc (sizeof (EquipmentIdType));
    CheckAsn1Alloc ((v->equipmentIdType), env);
    BDecEquipmentIdTypeContent (b, tagId1, elmtLen1, (v->equipmentIdType), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 290)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 290))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecEquipmentIdContent (b, tagId1, elmtLen1, (&v->equipmentId), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -128);
    }


    if (!seqDone)
        longjmp (env, -129);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecTrackedCustomerEquipmentContent */

void
PrintTrackedCustomerEquipment PARAMS ((f, v, indent),
FILE* f _AND_
TrackedCustomerEquipment *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->equipmentIdType)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"equipmentIdType ");
    PrintEquipmentIdType (f, (v->equipmentIdType), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->equipmentId)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"equipmentId ");
    PrintEquipmentId (f, (&v->equipmentId), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintTrackedCustomerEquipment */

void
FreeTrackedCustomerEquipment PARAMS ((v),
TrackedCustomerEquipment *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->equipmentIdType)))
    {
    FreeEquipmentIdType ((v->equipmentIdType));
    Asn1Free ((v->equipmentIdType));
    }

    if (ASNOCTS_PRESENT ((&v->equipmentId)))
    {
    FreeEquipmentId ((&v->equipmentId));
    }

}  /* FreeTrackedCustomerEquipment */




AsnLen
BEncTrackedCustomerHomeIdContent PARAMS ((b, v),
BUF_TYPE b _AND_
TrackedCustomerHomeId *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (ASNOCTS_PRESENT ((&v->homeIdentifier)))
    {
    itemLen = BEncHomeIdentifierContent (b, (&v->homeIdentifier));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 288);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->homeIdType)))
    {
    itemLen = BEncHomeIdTypeContent (b, (v->homeIdType));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 311);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncTrackedCustomerHomeIdContent */

void
BDecTrackedCustomerHomeIdContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
TrackedCustomerHomeId *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 311))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->homeIdType) = (HomeIdType*) Asn1Alloc (sizeof (HomeIdType));
    CheckAsn1Alloc ((v->homeIdType), env);
    BDecHomeIdTypeContent (b, tagId1, elmtLen1, (v->homeIdType), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 288)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 288))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecHomeIdentifierContent (b, tagId1, elmtLen1, (&v->homeIdentifier), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -130);
    }


    if (!seqDone)
        longjmp (env, -131);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecTrackedCustomerHomeIdContent */

void
PrintTrackedCustomerHomeId PARAMS ((f, v, indent),
FILE* f _AND_
TrackedCustomerHomeId *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->homeIdType)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"homeIdType ");
    PrintHomeIdType (f, (v->homeIdType), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->homeIdentifier)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"homeIdentifier ");
    PrintHomeIdentifier (f, (&v->homeIdentifier), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintTrackedCustomerHomeId */

void
FreeTrackedCustomerHomeId PARAMS ((v),
TrackedCustomerHomeId *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->homeIdType)))
    {
    FreeHomeIdType ((v->homeIdType));
    Asn1Free ((v->homeIdType));
    }

    if (ASNOCTS_PRESENT ((&v->homeIdentifier)))
    {
    FreeHomeIdentifier ((&v->homeIdentifier));
    }

}  /* FreeTrackedCustomerHomeId */




AsnLen
BEncTrackedCustomerHomeIdListContent PARAMS ((b, v),
BUF_TYPE b _AND_
TrackedCustomerHomeIdList *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    BEncEocIfNec (b);
    itemLen = BEncTrackedCustomerHomeIdContent (b, component);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 377);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncTrackedCustomerHomeIdListContent */

void
BDecTrackedCustomerHomeIdListContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
TrackedCustomerHomeIdList *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        TrackedCustomerHomeId **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (APPL, CONS, 377)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (TrackedCustomerHomeId**) AsnListAppend (v);
    (*tmpVar) = (TrackedCustomerHomeId*) Asn1Alloc (sizeof (TrackedCustomerHomeId));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecTrackedCustomerHomeIdContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -132);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecTrackedCustomerHomeIdListContent */

void
PrintTrackedCustomerHomeIdList PARAMS ((f, v, indent),
FILE* f _AND_
TrackedCustomerHomeIdList *v _AND_
unsigned short int indent)
{
    TrackedCustomerHomeId *tmp;
    if (v == NULL)
        return;
    fprintf (f,"{ -- SEQUENCE OF -- \n");
    FOR_EACH_LIST_ELMT (tmp, v)
    {
        Indent (f, indent+ stdIndentG);
        PrintTrackedCustomerHomeId (f, tmp, indent + stdIndentG);
        if (tmp != (TrackedCustomerHomeId*)LAST_LIST_ELMT (v))
            fprintf (f,",\n");
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintTrackedCustomerHomeIdList */

void
FreeTrackedCustomerHomeIdList PARAMS ((v),
TrackedCustomerHomeIdList *v)
{

    AsnListNode *l;
    AsnListNode *tmp;
    if (v == NULL)
        return;
    for (l = FIRST_LIST_NODE (v); l != NULL; )
    {
        FreeTrackedCustomerHomeId ((l->data));
        tmp = l->next;
        Asn1Free (l->data);
        Asn1Free (l);
        l = tmp;
    }
}  /* FreeTrackedCustomerHomeIdList */




AsnLen
BEncTrackedCustomerIdentificationContent PARAMS ((b, v),
BUF_TYPE b _AND_
TrackedCustomerIdentification *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (ASNOCTS_PRESENT ((&v->customerIdentifier)))
    {
    itemLen = BEncCustomerIdentifierContent (b, (&v->customerIdentifier));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 364);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->customerIdType)))
    {
    itemLen = BEncCustomerIdTypeContent (b, (v->customerIdType));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 363);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncTrackedCustomerIdentificationContent */

void
BDecTrackedCustomerIdentificationContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
TrackedCustomerIdentification *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 363))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->customerIdType) = (CustomerIdType*) Asn1Alloc (sizeof (CustomerIdType));
    CheckAsn1Alloc ((v->customerIdType), env);
    BDecCustomerIdTypeContent (b, tagId1, elmtLen1, (v->customerIdType), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 364)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 364))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecCustomerIdentifierContent (b, tagId1, elmtLen1, (&v->customerIdentifier), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -133);
    }


    if (!seqDone)
        longjmp (env, -134);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecTrackedCustomerIdentificationContent */

void
PrintTrackedCustomerIdentification PARAMS ((f, v, indent),
FILE* f _AND_
TrackedCustomerIdentification *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->customerIdType)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"customerIdType ");
    PrintCustomerIdType (f, (v->customerIdType), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->customerIdentifier)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"customerIdentifier ");
    PrintCustomerIdentifier (f, (&v->customerIdentifier), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintTrackedCustomerIdentification */

void
FreeTrackedCustomerIdentification PARAMS ((v),
TrackedCustomerIdentification *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->customerIdType)))
    {
    FreeCustomerIdType ((v->customerIdType));
    Asn1Free ((v->customerIdType));
    }

    if (ASNOCTS_PRESENT ((&v->customerIdentifier)))
    {
    FreeCustomerIdentifier ((&v->customerIdentifier));
    }

}  /* FreeTrackedCustomerIdentification */




AsnLen
BEncTrackedCustomerIdListContent PARAMS ((b, v),
BUF_TYPE b _AND_
TrackedCustomerIdList *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    BEncEocIfNec (b);
    itemLen = BEncTrackedCustomerIdentificationContent (b, component);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 372);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncTrackedCustomerIdListContent */

void
BDecTrackedCustomerIdListContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
TrackedCustomerIdList *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        TrackedCustomerIdentification **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (APPL, CONS, 372)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (TrackedCustomerIdentification**) AsnListAppend (v);
    (*tmpVar) = (TrackedCustomerIdentification*) Asn1Alloc (sizeof (TrackedCustomerIdentification));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecTrackedCustomerIdentificationContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -135);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecTrackedCustomerIdListContent */

void
PrintTrackedCustomerIdList PARAMS ((f, v, indent),
FILE* f _AND_
TrackedCustomerIdList *v _AND_
unsigned short int indent)
{
    TrackedCustomerIdentification *tmp;
    if (v == NULL)
        return;
    fprintf (f,"{ -- SEQUENCE OF -- \n");
    FOR_EACH_LIST_ELMT (tmp, v)
    {
        Indent (f, indent+ stdIndentG);
        PrintTrackedCustomerIdentification (f, tmp, indent + stdIndentG);
        if (tmp != (TrackedCustomerIdentification*)LAST_LIST_ELMT (v))
            fprintf (f,",\n");
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintTrackedCustomerIdList */

void
FreeTrackedCustomerIdList PARAMS ((v),
TrackedCustomerIdList *v)
{

    AsnListNode *l;
    AsnListNode *tmp;
    if (v == NULL)
        return;
    for (l = FIRST_LIST_NODE (v); l != NULL; )
    {
        FreeTrackedCustomerIdentification ((l->data));
        tmp = l->next;
        Asn1Free (l->data);
        Asn1Free (l);
        l = tmp;
    }
}  /* FreeTrackedCustomerIdList */




AsnLen
BEncTrackedCustomerLocationContent PARAMS ((b, v),
BUF_TYPE b _AND_
TrackedCustomerLocation *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (ASNOCTS_PRESENT ((&v->locationIdentifier)))
    {
    itemLen = BEncLocationIdentifierContent (b, (&v->locationIdentifier));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 289);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->locationIdType)))
    {
    itemLen = BEncLocationIdTypeContent (b, (v->locationIdType));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 315);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncTrackedCustomerLocationContent */

void
BDecTrackedCustomerLocationContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
TrackedCustomerLocation *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 315))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->locationIdType) = (LocationIdType*) Asn1Alloc (sizeof (LocationIdType));
    CheckAsn1Alloc ((v->locationIdType), env);
    BDecLocationIdTypeContent (b, tagId1, elmtLen1, (v->locationIdType), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 289)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 289))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecLocationIdentifierContent (b, tagId1, elmtLen1, (&v->locationIdentifier), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -136);
    }


    if (!seqDone)
        longjmp (env, -137);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecTrackedCustomerLocationContent */

void
PrintTrackedCustomerLocation PARAMS ((f, v, indent),
FILE* f _AND_
TrackedCustomerLocation *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->locationIdType)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"locationIdType ");
    PrintLocationIdType (f, (v->locationIdType), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->locationIdentifier)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"locationIdentifier ");
    PrintLocationIdentifier (f, (&v->locationIdentifier), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintTrackedCustomerLocation */

void
FreeTrackedCustomerLocation PARAMS ((v),
TrackedCustomerLocation *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->locationIdType)))
    {
    FreeLocationIdType ((v->locationIdType));
    Asn1Free ((v->locationIdType));
    }

    if (ASNOCTS_PRESENT ((&v->locationIdentifier)))
    {
    FreeLocationIdentifier ((&v->locationIdentifier));
    }

}  /* FreeTrackedCustomerLocation */




AsnLen
BEncTrackedCustomerLocListContent PARAMS ((b, v),
BUF_TYPE b _AND_
TrackedCustomerLocList *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    BEncEocIfNec (b);
    itemLen = BEncTrackedCustomerLocationContent (b, component);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 380);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncTrackedCustomerLocListContent */

void
BDecTrackedCustomerLocListContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
TrackedCustomerLocList *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        TrackedCustomerLocation **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (APPL, CONS, 380)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (TrackedCustomerLocation**) AsnListAppend (v);
    (*tmpVar) = (TrackedCustomerLocation*) Asn1Alloc (sizeof (TrackedCustomerLocation));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecTrackedCustomerLocationContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -138);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecTrackedCustomerLocListContent */

void
PrintTrackedCustomerLocList PARAMS ((f, v, indent),
FILE* f _AND_
TrackedCustomerLocList *v _AND_
unsigned short int indent)
{
    TrackedCustomerLocation *tmp;
    if (v == NULL)
        return;
    fprintf (f,"{ -- SEQUENCE OF -- \n");
    FOR_EACH_LIST_ELMT (tmp, v)
    {
        Indent (f, indent+ stdIndentG);
        PrintTrackedCustomerLocation (f, tmp, indent + stdIndentG);
        if (tmp != (TrackedCustomerLocation*)LAST_LIST_ELMT (v))
            fprintf (f,",\n");
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintTrackedCustomerLocList */

void
FreeTrackedCustomerLocList PARAMS ((v),
TrackedCustomerLocList *v)
{

    AsnListNode *l;
    AsnListNode *tmp;
    if (v == NULL)
        return;
    for (l = FIRST_LIST_NODE (v); l != NULL; )
    {
        FreeTrackedCustomerLocation ((l->data));
        tmp = l->next;
        Asn1Free (l->data);
        Asn1Free (l);
        l = tmp;
    }
}  /* FreeTrackedCustomerLocList */




AsnLen
BEncTrackingCustomerEquipmentContent PARAMS ((b, v),
BUF_TYPE b _AND_
TrackingCustomerEquipment *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (ASNOCTS_PRESENT ((&v->equipmentId)))
    {
    itemLen = BEncEquipmentIdContent (b, (&v->equipmentId));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 290);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->equipmentIdType)))
    {
    itemLen = BEncEquipmentIdTypeContent (b, (v->equipmentIdType));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 322);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncTrackingCustomerEquipmentContent */

void
BDecTrackingCustomerEquipmentContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
TrackingCustomerEquipment *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 322))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->equipmentIdType) = (EquipmentIdType*) Asn1Alloc (sizeof (EquipmentIdType));
    CheckAsn1Alloc ((v->equipmentIdType), env);
    BDecEquipmentIdTypeContent (b, tagId1, elmtLen1, (v->equipmentIdType), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 290)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 290))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecEquipmentIdContent (b, tagId1, elmtLen1, (&v->equipmentId), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -139);
    }


    if (!seqDone)
        longjmp (env, -140);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecTrackingCustomerEquipmentContent */

void
PrintTrackingCustomerEquipment PARAMS ((f, v, indent),
FILE* f _AND_
TrackingCustomerEquipment *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->equipmentIdType)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"equipmentIdType ");
    PrintEquipmentIdType (f, (v->equipmentIdType), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->equipmentId)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"equipmentId ");
    PrintEquipmentId (f, (&v->equipmentId), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintTrackingCustomerEquipment */

void
FreeTrackingCustomerEquipment PARAMS ((v),
TrackingCustomerEquipment *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->equipmentIdType)))
    {
    FreeEquipmentIdType ((v->equipmentIdType));
    Asn1Free ((v->equipmentIdType));
    }

    if (ASNOCTS_PRESENT ((&v->equipmentId)))
    {
    FreeEquipmentId ((&v->equipmentId));
    }

}  /* FreeTrackingCustomerEquipment */




AsnLen
BEncTrackingCustomerHomeIdContent PARAMS ((b, v),
BUF_TYPE b _AND_
TrackingCustomerHomeId *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (ASNOCTS_PRESENT ((&v->homeIdentifier)))
    {
    itemLen = BEncHomeIdentifierContent (b, (&v->homeIdentifier));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 288);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->homeIdType)))
    {
    itemLen = BEncHomeIdTypeContent (b, (v->homeIdType));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 311);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncTrackingCustomerHomeIdContent */

void
BDecTrackingCustomerHomeIdContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
TrackingCustomerHomeId *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 311))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->homeIdType) = (HomeIdType*) Asn1Alloc (sizeof (HomeIdType));
    CheckAsn1Alloc ((v->homeIdType), env);
    BDecHomeIdTypeContent (b, tagId1, elmtLen1, (v->homeIdType), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 288)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 288))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecHomeIdentifierContent (b, tagId1, elmtLen1, (&v->homeIdentifier), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -141);
    }


    if (!seqDone)
        longjmp (env, -142);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecTrackingCustomerHomeIdContent */

void
PrintTrackingCustomerHomeId PARAMS ((f, v, indent),
FILE* f _AND_
TrackingCustomerHomeId *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->homeIdType)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"homeIdType ");
    PrintHomeIdType (f, (v->homeIdType), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->homeIdentifier)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"homeIdentifier ");
    PrintHomeIdentifier (f, (&v->homeIdentifier), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintTrackingCustomerHomeId */

void
FreeTrackingCustomerHomeId PARAMS ((v),
TrackingCustomerHomeId *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->homeIdType)))
    {
    FreeHomeIdType ((v->homeIdType));
    Asn1Free ((v->homeIdType));
    }

    if (ASNOCTS_PRESENT ((&v->homeIdentifier)))
    {
    FreeHomeIdentifier ((&v->homeIdentifier));
    }

}  /* FreeTrackingCustomerHomeId */




AsnLen
BEncTrackingCustomerHomeIdListContent PARAMS ((b, v),
BUF_TYPE b _AND_
TrackingCustomerHomeIdList *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    BEncEocIfNec (b);
    itemLen = BEncTrackingCustomerHomeIdContent (b, component);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 366);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncTrackingCustomerHomeIdListContent */

void
BDecTrackingCustomerHomeIdListContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
TrackingCustomerHomeIdList *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        TrackingCustomerHomeId **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (APPL, CONS, 366)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (TrackingCustomerHomeId**) AsnListAppend (v);
    (*tmpVar) = (TrackingCustomerHomeId*) Asn1Alloc (sizeof (TrackingCustomerHomeId));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecTrackingCustomerHomeIdContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -143);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecTrackingCustomerHomeIdListContent */

void
PrintTrackingCustomerHomeIdList PARAMS ((f, v, indent),
FILE* f _AND_
TrackingCustomerHomeIdList *v _AND_
unsigned short int indent)
{
    TrackingCustomerHomeId *tmp;
    if (v == NULL)
        return;
    fprintf (f,"{ -- SEQUENCE OF -- \n");
    FOR_EACH_LIST_ELMT (tmp, v)
    {
        Indent (f, indent+ stdIndentG);
        PrintTrackingCustomerHomeId (f, tmp, indent + stdIndentG);
        if (tmp != (TrackingCustomerHomeId*)LAST_LIST_ELMT (v))
            fprintf (f,",\n");
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintTrackingCustomerHomeIdList */

void
FreeTrackingCustomerHomeIdList PARAMS ((v),
TrackingCustomerHomeIdList *v)
{

    AsnListNode *l;
    AsnListNode *tmp;
    if (v == NULL)
        return;
    for (l = FIRST_LIST_NODE (v); l != NULL; )
    {
        FreeTrackingCustomerHomeId ((l->data));
        tmp = l->next;
        Asn1Free (l->data);
        Asn1Free (l);
        l = tmp;
    }
}  /* FreeTrackingCustomerHomeIdList */




AsnLen
BEncTrackingCustomerIdentificationContent PARAMS ((b, v),
BUF_TYPE b _AND_
TrackingCustomerIdentification *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (ASNOCTS_PRESENT ((&v->customerIdentifier)))
    {
    itemLen = BEncCustomerIdentifierContent (b, (&v->customerIdentifier));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 364);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->customerIdType)))
    {
    itemLen = BEncCustomerIdTypeContent (b, (v->customerIdType));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 363);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncTrackingCustomerIdentificationContent */

void
BDecTrackingCustomerIdentificationContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
TrackingCustomerIdentification *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 363))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->customerIdType) = (CustomerIdType*) Asn1Alloc (sizeof (CustomerIdType));
    CheckAsn1Alloc ((v->customerIdType), env);
    BDecCustomerIdTypeContent (b, tagId1, elmtLen1, (v->customerIdType), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 364)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 364))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecCustomerIdentifierContent (b, tagId1, elmtLen1, (&v->customerIdentifier), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -144);
    }


    if (!seqDone)
        longjmp (env, -145);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecTrackingCustomerIdentificationContent */

void
PrintTrackingCustomerIdentification PARAMS ((f, v, indent),
FILE* f _AND_
TrackingCustomerIdentification *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->customerIdType)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"customerIdType ");
    PrintCustomerIdType (f, (v->customerIdType), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->customerIdentifier)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"customerIdentifier ");
    PrintCustomerIdentifier (f, (&v->customerIdentifier), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintTrackingCustomerIdentification */

void
FreeTrackingCustomerIdentification PARAMS ((v),
TrackingCustomerIdentification *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->customerIdType)))
    {
    FreeCustomerIdType ((v->customerIdType));
    Asn1Free ((v->customerIdType));
    }

    if (ASNOCTS_PRESENT ((&v->customerIdentifier)))
    {
    FreeCustomerIdentifier ((&v->customerIdentifier));
    }

}  /* FreeTrackingCustomerIdentification */




AsnLen
BEncTrackingCustomerIdListContent PARAMS ((b, v),
BUF_TYPE b _AND_
TrackingCustomerIdList *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    BEncEocIfNec (b);
    itemLen = BEncTrackingCustomerIdentificationContent (b, component);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 362);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncTrackingCustomerIdListContent */

void
BDecTrackingCustomerIdListContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
TrackingCustomerIdList *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        TrackingCustomerIdentification **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (APPL, CONS, 362)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (TrackingCustomerIdentification**) AsnListAppend (v);
    (*tmpVar) = (TrackingCustomerIdentification*) Asn1Alloc (sizeof (TrackingCustomerIdentification));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecTrackingCustomerIdentificationContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -146);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecTrackingCustomerIdListContent */

void
PrintTrackingCustomerIdList PARAMS ((f, v, indent),
FILE* f _AND_
TrackingCustomerIdList *v _AND_
unsigned short int indent)
{
    TrackingCustomerIdentification *tmp;
    if (v == NULL)
        return;
    fprintf (f,"{ -- SEQUENCE OF -- \n");
    FOR_EACH_LIST_ELMT (tmp, v)
    {
        Indent (f, indent+ stdIndentG);
        PrintTrackingCustomerIdentification (f, tmp, indent + stdIndentG);
        if (tmp != (TrackingCustomerIdentification*)LAST_LIST_ELMT (v))
            fprintf (f,",\n");
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintTrackingCustomerIdList */

void
FreeTrackingCustomerIdList PARAMS ((v),
TrackingCustomerIdList *v)
{

    AsnListNode *l;
    AsnListNode *tmp;
    if (v == NULL)
        return;
    for (l = FIRST_LIST_NODE (v); l != NULL; )
    {
        FreeTrackingCustomerIdentification ((l->data));
        tmp = l->next;
        Asn1Free (l->data);
        Asn1Free (l);
        l = tmp;
    }
}  /* FreeTrackingCustomerIdList */




AsnLen
BEncTrackingCustomerLocationContent PARAMS ((b, v),
BUF_TYPE b _AND_
TrackingCustomerLocation *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (ASNOCTS_PRESENT ((&v->locationIdentifier)))
    {
    itemLen = BEncLocationIdentifierContent (b, (&v->locationIdentifier));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 289);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->locationIdType)))
    {
    itemLen = BEncLocationIdTypeContent (b, (v->locationIdType));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 315);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncTrackingCustomerLocationContent */

void
BDecTrackingCustomerLocationContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
TrackingCustomerLocation *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 315))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->locationIdType) = (LocationIdType*) Asn1Alloc (sizeof (LocationIdType));
    CheckAsn1Alloc ((v->locationIdType), env);
    BDecLocationIdTypeContent (b, tagId1, elmtLen1, (v->locationIdType), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 289)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 289))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecLocationIdentifierContent (b, tagId1, elmtLen1, (&v->locationIdentifier), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -147);
    }


    if (!seqDone)
        longjmp (env, -148);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecTrackingCustomerLocationContent */

void
PrintTrackingCustomerLocation PARAMS ((f, v, indent),
FILE* f _AND_
TrackingCustomerLocation *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->locationIdType)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"locationIdType ");
    PrintLocationIdType (f, (v->locationIdType), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->locationIdentifier)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"locationIdentifier ");
    PrintLocationIdentifier (f, (&v->locationIdentifier), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintTrackingCustomerLocation */

void
FreeTrackingCustomerLocation PARAMS ((v),
TrackingCustomerLocation *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->locationIdType)))
    {
    FreeLocationIdType ((v->locationIdType));
    Asn1Free ((v->locationIdType));
    }

    if (ASNOCTS_PRESENT ((&v->locationIdentifier)))
    {
    FreeLocationIdentifier ((&v->locationIdentifier));
    }

}  /* FreeTrackingCustomerLocation */




AsnLen
BEncTrackingCustomerLocListContent PARAMS ((b, v),
BUF_TYPE b _AND_
TrackingCustomerLocList *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    BEncEocIfNec (b);
    itemLen = BEncTrackingCustomerLocationContent (b, component);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 369);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncTrackingCustomerLocListContent */

void
BDecTrackingCustomerLocListContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
TrackingCustomerLocList *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        TrackingCustomerLocation **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (APPL, CONS, 369)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (TrackingCustomerLocation**) AsnListAppend (v);
    (*tmpVar) = (TrackingCustomerLocation*) Asn1Alloc (sizeof (TrackingCustomerLocation));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecTrackingCustomerLocationContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -149);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecTrackingCustomerLocListContent */

void
PrintTrackingCustomerLocList PARAMS ((f, v, indent),
FILE* f _AND_
TrackingCustomerLocList *v _AND_
unsigned short int indent)
{
    TrackingCustomerLocation *tmp;
    if (v == NULL)
        return;
    fprintf (f,"{ -- SEQUENCE OF -- \n");
    FOR_EACH_LIST_ELMT (tmp, v)
    {
        Indent (f, indent+ stdIndentG);
        PrintTrackingCustomerLocation (f, tmp, indent + stdIndentG);
        if (tmp != (TrackingCustomerLocation*)LAST_LIST_ELMT (v))
            fprintf (f,",\n");
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintTrackingCustomerLocList */

void
FreeTrackingCustomerLocList PARAMS ((v),
TrackingCustomerLocList *v)
{

    AsnListNode *l;
    AsnListNode *tmp;
    if (v == NULL)
        return;
    for (l = FIRST_LIST_NODE (v); l != NULL; )
    {
        FreeTrackingCustomerLocation ((l->data));
        tmp = l->next;
        Asn1Free (l->data);
        Asn1Free (l);
        l = tmp;
    }
}  /* FreeTrackingCustomerLocList */




AsnLen
BEncUtcTimeOffsetInfoContent PARAMS ((b, v),
BUF_TYPE b _AND_
UtcTimeOffsetInfo *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (ASNOCTS_PRESENT ((&v->utcTimeOffset)))
    {
    itemLen = BEncUtcTimeOffsetContent (b, (&v->utcTimeOffset));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 231);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->utcTimeOffsetCode)))
    {
    itemLen = BEncUtcTimeOffsetCodeContent (b, (v->utcTimeOffsetCode));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 232);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncUtcTimeOffsetInfoContent */

void
BDecUtcTimeOffsetInfoContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
UtcTimeOffsetInfo *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 232))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->utcTimeOffsetCode) = (UtcTimeOffsetCode*) Asn1Alloc (sizeof (UtcTimeOffsetCode));
    CheckAsn1Alloc ((v->utcTimeOffsetCode), env);
    BDecUtcTimeOffsetCodeContent (b, tagId1, elmtLen1, (v->utcTimeOffsetCode), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 231)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 231))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecUtcTimeOffsetContent (b, tagId1, elmtLen1, (&v->utcTimeOffset), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -150);
    }


    if (!seqDone)
        longjmp (env, -151);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecUtcTimeOffsetInfoContent */

void
PrintUtcTimeOffsetInfo PARAMS ((f, v, indent),
FILE* f _AND_
UtcTimeOffsetInfo *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->utcTimeOffsetCode)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"utcTimeOffsetCode ");
    PrintUtcTimeOffsetCode (f, (v->utcTimeOffsetCode), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->utcTimeOffset)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"utcTimeOffset ");
    PrintUtcTimeOffset (f, (&v->utcTimeOffset), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintUtcTimeOffsetInfo */

void
FreeUtcTimeOffsetInfo PARAMS ((v),
UtcTimeOffsetInfo *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->utcTimeOffsetCode)))
    {
    FreeUtcTimeOffsetCode ((v->utcTimeOffsetCode));
    Asn1Free ((v->utcTimeOffsetCode));
    }

    if (ASNOCTS_PRESENT ((&v->utcTimeOffset)))
    {
    FreeUtcTimeOffset ((&v->utcTimeOffset));
    }

}  /* FreeUtcTimeOffsetInfo */




AsnLen
BEncUtcTimeOffsetInfoListContent PARAMS ((b, v),
BUF_TYPE b _AND_
UtcTimeOffsetInfoList *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    BEncEocIfNec (b);
    itemLen = BEncUtcTimeOffsetInfoContent (b, component);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 233);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncUtcTimeOffsetInfoListContent */

void
BDecUtcTimeOffsetInfoListContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
UtcTimeOffsetInfoList *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        UtcTimeOffsetInfo **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (APPL, CONS, 233)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (UtcTimeOffsetInfo**) AsnListAppend (v);
    (*tmpVar) = (UtcTimeOffsetInfo*) Asn1Alloc (sizeof (UtcTimeOffsetInfo));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecUtcTimeOffsetInfoContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -152);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecUtcTimeOffsetInfoListContent */

void
PrintUtcTimeOffsetInfoList PARAMS ((f, v, indent),
FILE* f _AND_
UtcTimeOffsetInfoList *v _AND_
unsigned short int indent)
{
    UtcTimeOffsetInfo *tmp;
    if (v == NULL)
        return;
    fprintf (f,"{ -- SEQUENCE OF -- \n");
    FOR_EACH_LIST_ELMT (tmp, v)
    {
        Indent (f, indent+ stdIndentG);
        PrintUtcTimeOffsetInfo (f, tmp, indent + stdIndentG);
        if (tmp != (UtcTimeOffsetInfo*)LAST_LIST_ELMT (v))
            fprintf (f,",\n");
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintUtcTimeOffsetInfoList */

void
FreeUtcTimeOffsetInfoList PARAMS ((v),
UtcTimeOffsetInfoList *v)
{

    AsnListNode *l;
    AsnListNode *tmp;
    if (v == NULL)
        return;
    for (l = FIRST_LIST_NODE (v); l != NULL; )
    {
        FreeUtcTimeOffsetInfo ((l->data));
        tmp = l->next;
        Asn1Free (l->data);
        Asn1Free (l);
        l = tmp;
    }
}  /* FreeUtcTimeOffsetInfoList */




AsnLen
BEncMessageDescriptionInfoListContent PARAMS ((b, v),
BUF_TYPE b _AND_
MessageDescriptionInfoList *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    BEncEocIfNec (b);
    itemLen = BEncMessageDescriptionInformationContent (b, component);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 143);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncMessageDescriptionInfoListContent */

void
BDecMessageDescriptionInfoListContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
MessageDescriptionInfoList *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        MessageDescriptionInformation **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (APPL, CONS, 143)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (MessageDescriptionInformation**) AsnListAppend (v);
    (*tmpVar) = (MessageDescriptionInformation*) Asn1Alloc (sizeof (MessageDescriptionInformation));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecMessageDescriptionInformationContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -153);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecMessageDescriptionInfoListContent */

void
PrintMessageDescriptionInfoList PARAMS ((f, v, indent),
FILE* f _AND_
MessageDescriptionInfoList *v _AND_
unsigned short int indent)
{
    MessageDescriptionInformation *tmp;
    if (v == NULL)
        return;
    fprintf (f,"{ -- SEQUENCE OF -- \n");
    FOR_EACH_LIST_ELMT (tmp, v)
    {
        Indent (f, indent+ stdIndentG);
        PrintMessageDescriptionInformation (f, tmp, indent + stdIndentG);
        if (tmp != (MessageDescriptionInformation*)LAST_LIST_ELMT (v))
            fprintf (f,",\n");
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintMessageDescriptionInfoList */

void
FreeMessageDescriptionInfoList PARAMS ((v),
MessageDescriptionInfoList *v)
{

    AsnListNode *l;
    AsnListNode *tmp;
    if (v == NULL)
        return;
    for (l = FIRST_LIST_NODE (v); l != NULL; )
    {
        FreeMessageDescriptionInformation ((l->data));
        tmp = l->next;
        Asn1Free (l->data);
        Asn1Free (l);
        l = tmp;
    }
}  /* FreeMessageDescriptionInfoList */




AsnLen
BEncAdvisedChargeInformationContent PARAMS ((b, v),
BUF_TYPE b _AND_
AdvisedChargeInformation *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->commission)))
    {
    itemLen = BEncCommissionContent (b, (v->commission));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 350);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->advisedCharge)))
    {
    itemLen = BEncAdvisedChargeContent (b, (v->advisedCharge));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 349);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->advisedChargeCurrency)))
    {
    itemLen = BEncAdvisedChargeCurrencyContent (b, (&v->advisedChargeCurrency));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 348);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->paymentMethod)))
    {
    itemLen = BEncPaymentMethodContent (b, (v->paymentMethod));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 347);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->paidIndicator)))
    {
    itemLen = BEncPaidIndicatorContent (b, (v->paidIndicator));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 346);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncAdvisedChargeInformationContent */

void
BDecAdvisedChargeInformationContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
AdvisedChargeInformation *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 346))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->paidIndicator) = (PaidIndicator*) Asn1Alloc (sizeof (PaidIndicator));
    CheckAsn1Alloc ((v->paidIndicator), env);
    BDecPaidIndicatorContent (b, tagId1, elmtLen1, (v->paidIndicator), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 347))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->paymentMethod) = (PaymentMethod*) Asn1Alloc (sizeof (PaymentMethod));
    CheckAsn1Alloc ((v->paymentMethod), env);
    BDecPaymentMethodContent (b, tagId1, elmtLen1, (v->paymentMethod), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 348)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 348))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecAdvisedChargeCurrencyContent (b, tagId1, elmtLen1, (&v->advisedChargeCurrency), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 349))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->advisedCharge) = (AdvisedCharge*) Asn1Alloc (sizeof (AdvisedCharge));
    CheckAsn1Alloc ((v->advisedCharge), env);
    BDecAdvisedChargeContent (b, tagId1, elmtLen1, (v->advisedCharge), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 350))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->commission) = (Commission*) Asn1Alloc (sizeof (Commission));
    CheckAsn1Alloc ((v->commission), env);
    BDecCommissionContent (b, tagId1, elmtLen1, (v->commission), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -154);
    }


    if (!seqDone)
        longjmp (env, -155);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecAdvisedChargeInformationContent */

void
PrintAdvisedChargeInformation PARAMS ((f, v, indent),
FILE* f _AND_
AdvisedChargeInformation *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->paidIndicator)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"paidIndicator ");
    PrintPaidIndicator (f, (v->paidIndicator), indent + stdIndentG);
    }
    if (NOT_NULL ((v->paymentMethod)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"paymentMethod ");
    PrintPaymentMethod (f, (v->paymentMethod), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->advisedChargeCurrency)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"advisedChargeCurrency ");
    PrintAdvisedChargeCurrency (f, (&v->advisedChargeCurrency), indent + stdIndentG);
    }
    if (NOT_NULL ((v->advisedCharge)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"advisedCharge ");
    PrintAdvisedCharge (f, (v->advisedCharge), indent + stdIndentG);
    }
    if (NOT_NULL ((v->commission)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"commission ");
    PrintCommission (f, (v->commission), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintAdvisedChargeInformation */

void
FreeAdvisedChargeInformation PARAMS ((v),
AdvisedChargeInformation *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->paidIndicator)))
    {
    FreePaidIndicator ((v->paidIndicator));
    Asn1Free ((v->paidIndicator));
    }

    if (NOT_NULL ((v->paymentMethod)))
    {
    FreePaymentMethod ((v->paymentMethod));
    Asn1Free ((v->paymentMethod));
    }

    if (ASNOCTS_PRESENT ((&v->advisedChargeCurrency)))
    {
    FreeAdvisedChargeCurrency ((&v->advisedChargeCurrency));
    }

    if (NOT_NULL ((v->advisedCharge)))
    {
    FreeAdvisedCharge ((v->advisedCharge));
    Asn1Free ((v->advisedCharge));
    }

    if (NOT_NULL ((v->commission)))
    {
    FreeCommission ((v->commission));
    Asn1Free ((v->commission));
    }

}  /* FreeAdvisedChargeInformation */




AsnLen
BEncBasicServiceCodeContent PARAMS ((b, v),
BUF_TYPE b _AND_
BasicServiceCode *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    switch (v->choiceId)
    {
       case BASICSERVICECODE_TELESERVICECODE:
    itemLen = BEncTeleServiceCodeContent (b, (v->a.teleServiceCode));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 218);

    totalLen += itemLen;

    break;

       case BASICSERVICECODE_BEARERSERVICECODE:
    itemLen = BEncBearerServiceCodeContent (b, (v->a.bearerServiceCode));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, PRIM, 40);

    totalLen += itemLen;

    break;

    }
    return totalLen;

}  /* BEncBasicServiceCodeContent */

void
BDecBasicServiceCodeContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
BasicServiceCode *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    switch (tagId0)
    {
       case MAKE_TAG_ID (APPL, PRIM, 218):
       case MAKE_TAG_ID (APPL, CONS, 218):
        (v->choiceId) = BASICSERVICECODE_TELESERVICECODE;
    (v->a.teleServiceCode) = (TeleServiceCode*) Asn1Alloc (sizeof (TeleServiceCode));
    CheckAsn1Alloc ((v->a.teleServiceCode), env);
    BDecTeleServiceCodeContent (b, tagId0, elmtLen0, (v->a.teleServiceCode), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (APPL, PRIM, 40):
       case MAKE_TAG_ID (APPL, CONS, 40):
        (v->choiceId) = BASICSERVICECODE_BEARERSERVICECODE;
    (v->a.bearerServiceCode) = (BearerServiceCode*) Asn1Alloc (sizeof (BearerServiceCode));
    CheckAsn1Alloc ((v->a.bearerServiceCode), env);
    BDecBearerServiceCodeContent (b, tagId0, elmtLen0, (v->a.bearerServiceCode), &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("ERROR - unexpected tag in CHOICE\n");
        longjmp (env, -156);
        break;
    } /* end switch */
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecBasicServiceCodeContent */

void
PrintBasicServiceCode PARAMS ((f, v, indent),
FILE* f _AND_
BasicServiceCode *v _AND_
unsigned short int indent)
{
    switch (v->choiceId)
    {
      case BASICSERVICECODE_TELESERVICECODE:
          fprintf (f,"teleServiceCode ");
    PrintTeleServiceCode (f, (v->a.teleServiceCode), indent + stdIndentG);
          break;

      case BASICSERVICECODE_BEARERSERVICECODE:
          fprintf (f,"bearerServiceCode ");
    PrintBearerServiceCode (f, (v->a.bearerServiceCode), indent + stdIndentG);
          break;

    }
}  /* PrintBasicServiceCode */

void
FreeBasicServiceCode PARAMS ((v),
BasicServiceCode *v)
{

    if (v == NULL)
        return;
    switch (v->choiceId)
    {
       case BASICSERVICECODE_TELESERVICECODE:
    FreeTeleServiceCode ((v->a.teleServiceCode));
    Asn1Free ((v->a.teleServiceCode));

    break;

       case BASICSERVICECODE_BEARERSERVICECODE:
    FreeBearerServiceCode ((v->a.bearerServiceCode));
    Asn1Free ((v->a.bearerServiceCode));

    break;

    }
}  /* FreeBasicServiceCode */




AsnLen
BEncBasicServiceCodeListContent PARAMS ((b, v),
BUF_TYPE b _AND_
BasicServiceCodeList *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    BEncEocIfNec (b);
    itemLen = BEncBasicServiceCodeContent (b, component);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 426);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncBasicServiceCodeListContent */

void
BDecBasicServiceCodeListContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
BasicServiceCodeList *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        BasicServiceCode **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (APPL, CONS, 426)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (BasicServiceCode**) AsnListAppend (v);
    (*tmpVar) = (BasicServiceCode*) Asn1Alloc (sizeof (BasicServiceCode));
    CheckAsn1Alloc ((*tmpVar), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecBasicServiceCodeContent (b, tagId2, elmtLen2, (*tmpVar), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    /*if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);*/
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -157);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecBasicServiceCodeListContent */

void
PrintBasicServiceCodeList PARAMS ((f, v, indent),
FILE* f _AND_
BasicServiceCodeList *v _AND_
unsigned short int indent)
{
    BasicServiceCode *tmp;
    if (v == NULL)
        return;
    fprintf (f,"{ -- SEQUENCE OF -- \n");
    FOR_EACH_LIST_ELMT (tmp, v)
    {
        Indent (f, indent+ stdIndentG);
        PrintBasicServiceCode (f, tmp, indent + stdIndentG);
        if (tmp != (BasicServiceCode*)LAST_LIST_ELMT (v))
            fprintf (f,",\n");
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintBasicServiceCodeList */

void
FreeBasicServiceCodeList PARAMS ((v),
BasicServiceCodeList *v)
{

    AsnListNode *l;
    AsnListNode *tmp;
    if (v == NULL)
        return;
    for (l = FIRST_LIST_NODE (v); l != NULL; )
    {
        FreeBasicServiceCode ((l->data));
        tmp = l->next;
        Asn1Free (l->data);
        Asn1Free (l);
        l = tmp;
    }
}  /* FreeBasicServiceCodeList */




AsnLen
BEncCallOriginatorContent PARAMS ((b, v),
BUF_TYPE b _AND_
CallOriginator *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (ASNOCTS_PRESENT ((&v->sMSOriginator)))
    {
    itemLen = BEncSMSOriginatorContent (b, (&v->sMSOriginator));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 425);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->clirIndicator)))
    {
    itemLen = BEncClirIndicatorContent (b, (v->clirIndicator));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, APPL, PRIM, 75);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->callingNumber)))
    {
    itemLen = BEncCallingNumberContent (b, (&v->callingNumber));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 405);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncCallOriginatorContent */

void
BDecCallOriginatorContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
CallOriginator *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 405)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 405))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecCallingNumberContent (b, tagId1, elmtLen1, (&v->callingNumber), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 75))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->clirIndicator) = (ClirIndicator*) Asn1Alloc (sizeof (ClirIndicator));
    CheckAsn1Alloc ((v->clirIndicator), env);
    BDecClirIndicatorContent (b, tagId1, elmtLen1, (v->clirIndicator), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 425)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 425))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecSMSOriginatorContent (b, tagId1, elmtLen1, (&v->sMSOriginator), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -158);
    }


    if (!seqDone)
        longjmp (env, -159);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecCallOriginatorContent */

void
PrintCallOriginator PARAMS ((f, v, indent),
FILE* f _AND_
CallOriginator *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (ASNOCTS_PRESENT ((&v->callingNumber)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"callingNumber ");
    PrintCallingNumber (f, (&v->callingNumber), indent + stdIndentG);
    }
    if (NOT_NULL ((v->clirIndicator)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"clirIndicator ");
    PrintClirIndicator (f, (v->clirIndicator), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->sMSOriginator)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"sMSOriginator ");
    PrintSMSOriginator (f, (&v->sMSOriginator), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintCallOriginator */

void
FreeCallOriginator PARAMS ((v),
CallOriginator *v)
{

    if (v == NULL)
        return;
    if (ASNOCTS_PRESENT ((&v->callingNumber)))
    {
    FreeCallingNumber ((&v->callingNumber));
    }

    if (NOT_NULL ((v->clirIndicator)))
    {
    FreeClirIndicator ((v->clirIndicator));
    Asn1Free ((v->clirIndicator));
    }

    if (ASNOCTS_PRESENT ((&v->sMSOriginator)))
    {
    FreeSMSOriginator ((&v->sMSOriginator));
    }

}  /* FreeCallOriginator */




AsnLen
BEncChargeableSubscriberContent PARAMS ((b, v),
BUF_TYPE b _AND_
ChargeableSubscriber *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    switch (v->choiceId)
    {
       case CHARGEABLESUBSCRIBER_SIMCHARGEABLESUBSCRIBER:
    BEncEocIfNec (b);
    itemLen = BEncSimChargeableSubscriberContent (b, (v->a.simChargeableSubscriber));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 199);

    totalLen += itemLen;

    break;

       case CHARGEABLESUBSCRIBER_MINCHARGEABLESUBSCRIBER:
    BEncEocIfNec (b);
    itemLen = BEncMinChargeableSubscriberContent (b, (v->a.minChargeableSubscriber));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 254);

    totalLen += itemLen;

    break;

    }
    return totalLen;

}  /* BEncChargeableSubscriberContent */

void
BDecChargeableSubscriberContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ChargeableSubscriber *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    switch (tagId0)
    {
       case MAKE_TAG_ID (APPL, CONS, 199):
        (v->choiceId) = CHARGEABLESUBSCRIBER_SIMCHARGEABLESUBSCRIBER;
    (v->a.simChargeableSubscriber) = (SimChargeableSubscriber*) Asn1Alloc (sizeof (SimChargeableSubscriber));
    CheckAsn1Alloc ((v->a.simChargeableSubscriber), env);
    BDecSimChargeableSubscriberContent (b, tagId0, elmtLen0, (v->a.simChargeableSubscriber), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (APPL, CONS, 254):
        (v->choiceId) = CHARGEABLESUBSCRIBER_MINCHARGEABLESUBSCRIBER;
    (v->a.minChargeableSubscriber) = (MinChargeableSubscriber*) Asn1Alloc (sizeof (MinChargeableSubscriber));
    CheckAsn1Alloc ((v->a.minChargeableSubscriber), env);
    BDecMinChargeableSubscriberContent (b, tagId0, elmtLen0, (v->a.minChargeableSubscriber), &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("ERROR - unexpected tag in CHOICE\n");
        longjmp (env, -160);
        break;
    } /* end switch */
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecChargeableSubscriberContent */

void
PrintChargeableSubscriber PARAMS ((f, v, indent),
FILE* f _AND_
ChargeableSubscriber *v _AND_
unsigned short int indent)
{
    switch (v->choiceId)
    {
      case CHARGEABLESUBSCRIBER_SIMCHARGEABLESUBSCRIBER:
          fprintf (f,"simChargeableSubscriber ");
    PrintSimChargeableSubscriber (f, (v->a.simChargeableSubscriber), indent + stdIndentG);
          break;

      case CHARGEABLESUBSCRIBER_MINCHARGEABLESUBSCRIBER:
          fprintf (f,"minChargeableSubscriber ");
    PrintMinChargeableSubscriber (f, (v->a.minChargeableSubscriber), indent + stdIndentG);
          break;

    }
}  /* PrintChargeableSubscriber */

void
FreeChargeableSubscriber PARAMS ((v),
ChargeableSubscriber *v)
{

    if (v == NULL)
        return;
    switch (v->choiceId)
    {
       case CHARGEABLESUBSCRIBER_SIMCHARGEABLESUBSCRIBER:
    FreeSimChargeableSubscriber ((v->a.simChargeableSubscriber));
    Asn1Free ((v->a.simChargeableSubscriber));

    break;

       case CHARGEABLESUBSCRIBER_MINCHARGEABLESUBSCRIBER:
    FreeMinChargeableSubscriber ((v->a.minChargeableSubscriber));
    Asn1Free ((v->a.minChargeableSubscriber));

    break;

    }
}  /* FreeChargeableSubscriber */




AsnLen
BEncChargedPartyEquipmentContent PARAMS ((b, v),
BUF_TYPE b _AND_
ChargedPartyEquipment *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (ASNOCTS_PRESENT ((&v->equipmentId)))
    {
    itemLen = BEncEquipmentIdContent (b, (&v->equipmentId));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 290);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->equipmentIdType)))
    {
    itemLen = BEncEquipmentIdTypeContent (b, (v->equipmentIdType));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 322);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncChargedPartyEquipmentContent */

void
BDecChargedPartyEquipmentContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ChargedPartyEquipment *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 322))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->equipmentIdType) = (EquipmentIdType*) Asn1Alloc (sizeof (EquipmentIdType));
    CheckAsn1Alloc ((v->equipmentIdType), env);
    BDecEquipmentIdTypeContent (b, tagId1, elmtLen1, (v->equipmentIdType), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 290)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 290))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecEquipmentIdContent (b, tagId1, elmtLen1, (&v->equipmentId), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -161);
    }


    if (!seqDone)
        longjmp (env, -162);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecChargedPartyEquipmentContent */

void
PrintChargedPartyEquipment PARAMS ((f, v, indent),
FILE* f _AND_
ChargedPartyEquipment *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->equipmentIdType)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"equipmentIdType ");
    PrintEquipmentIdType (f, (v->equipmentIdType), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->equipmentId)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"equipmentId ");
    PrintEquipmentId (f, (&v->equipmentId), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintChargedPartyEquipment */

void
FreeChargedPartyEquipment PARAMS ((v),
ChargedPartyEquipment *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->equipmentIdType)))
    {
    FreeEquipmentIdType ((v->equipmentIdType));
    Asn1Free ((v->equipmentIdType));
    }

    if (ASNOCTS_PRESENT ((&v->equipmentId)))
    {
    FreeEquipmentId ((&v->equipmentId));
    }

}  /* FreeChargedPartyEquipment */




AsnLen
BEncChargedPartyHomeIdentificationContent PARAMS ((b, v),
BUF_TYPE b _AND_
ChargedPartyHomeIdentification *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (ASNOCTS_PRESENT ((&v->homeIdentifier)))
    {
    itemLen = BEncHomeIdentifierContent (b, (&v->homeIdentifier));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 288);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->homeIdType)))
    {
    itemLen = BEncHomeIdTypeContent (b, (v->homeIdType));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 311);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncChargedPartyHomeIdentificationContent */

void
BDecChargedPartyHomeIdentificationContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ChargedPartyHomeIdentification *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 311))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->homeIdType) = (HomeIdType*) Asn1Alloc (sizeof (HomeIdType));
    CheckAsn1Alloc ((v->homeIdType), env);
    BDecHomeIdTypeContent (b, tagId1, elmtLen1, (v->homeIdType), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 288)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 288))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecHomeIdentifierContent (b, tagId1, elmtLen1, (&v->homeIdentifier), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -163);
    }


    if (!seqDone)
        longjmp (env, -164);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecChargedPartyHomeIdentificationContent */

void
PrintChargedPartyHomeIdentification PARAMS ((f, v, indent),
FILE* f _AND_
ChargedPartyHomeIdentification *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->homeIdType)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"homeIdType ");
    PrintHomeIdType (f, (v->homeIdType), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->homeIdentifier)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"homeIdentifier ");
    PrintHomeIdentifier (f, (&v->homeIdentifier), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintChargedPartyHomeIdentification */

void
FreeChargedPartyHomeIdentification PARAMS ((v),
ChargedPartyHomeIdentification *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->homeIdType)))
    {
    FreeHomeIdType ((v->homeIdType));
    Asn1Free ((v->homeIdType));
    }

    if (ASNOCTS_PRESENT ((&v->homeIdentifier)))
    {
    FreeHomeIdentifier ((&v->homeIdentifier));
    }

}  /* FreeChargedPartyHomeIdentification */




AsnLen
BEncChargedPartyHomeIdListContent PARAMS ((b, v),
BUF_TYPE b _AND_
ChargedPartyHomeIdList *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    BEncEocIfNec (b);
    itemLen = BEncChargedPartyHomeIdentificationContent (b, component);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 313);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncChargedPartyHomeIdListContent */

void
BDecChargedPartyHomeIdListContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ChargedPartyHomeIdList *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        ChargedPartyHomeIdentification **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (APPL, CONS, 313)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (ChargedPartyHomeIdentification**) AsnListAppend (v);
    (*tmpVar) = (ChargedPartyHomeIdentification*) Asn1Alloc (sizeof (ChargedPartyHomeIdentification));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecChargedPartyHomeIdentificationContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -165);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecChargedPartyHomeIdListContent */

void
PrintChargedPartyHomeIdList PARAMS ((f, v, indent),
FILE* f _AND_
ChargedPartyHomeIdList *v _AND_
unsigned short int indent)
{
    ChargedPartyHomeIdentification *tmp;
    if (v == NULL)
        return;
    fprintf (f,"{ -- SEQUENCE OF -- \n");
    FOR_EACH_LIST_ELMT (tmp, v)
    {
        Indent (f, indent+ stdIndentG);
        PrintChargedPartyHomeIdentification (f, tmp, indent + stdIndentG);
        if (tmp != (ChargedPartyHomeIdentification*)LAST_LIST_ELMT (v))
            fprintf (f,",\n");
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintChargedPartyHomeIdList */

void
FreeChargedPartyHomeIdList PARAMS ((v),
ChargedPartyHomeIdList *v)
{

    AsnListNode *l;
    AsnListNode *tmp;
    if (v == NULL)
        return;
    for (l = FIRST_LIST_NODE (v); l != NULL; )
    {
        FreeChargedPartyHomeIdentification ((l->data));
        tmp = l->next;
        Asn1Free (l->data);
        Asn1Free (l);
        l = tmp;
    }
}  /* FreeChargedPartyHomeIdList */




AsnLen
BEncChargedPartyIdentificationContent PARAMS ((b, v),
BUF_TYPE b _AND_
ChargedPartyIdentification *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (ASNOCTS_PRESENT ((&v->chargedPartyIdentifier)))
    {
    itemLen = BEncChargedPartyIdentifierContent (b, (&v->chargedPartyIdentifier));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 287);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->chargedPartyIdType)))
    {
    itemLen = BEncChargedPartyIdTypeContent (b, (v->chargedPartyIdType));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 305);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncChargedPartyIdentificationContent */

void
BDecChargedPartyIdentificationContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ChargedPartyIdentification *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 305))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->chargedPartyIdType) = (ChargedPartyIdType*) Asn1Alloc (sizeof (ChargedPartyIdType));
    CheckAsn1Alloc ((v->chargedPartyIdType), env);
    BDecChargedPartyIdTypeContent (b, tagId1, elmtLen1, (v->chargedPartyIdType), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 287)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 287))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecChargedPartyIdentifierContent (b, tagId1, elmtLen1, (&v->chargedPartyIdentifier), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -166);
    }


    if (!seqDone)
        longjmp (env, -167);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecChargedPartyIdentificationContent */

void
PrintChargedPartyIdentification PARAMS ((f, v, indent),
FILE* f _AND_
ChargedPartyIdentification *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->chargedPartyIdType)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"chargedPartyIdType ");
    PrintChargedPartyIdType (f, (v->chargedPartyIdType), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->chargedPartyIdentifier)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"chargedPartyIdentifier ");
    PrintChargedPartyIdentifier (f, (&v->chargedPartyIdentifier), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintChargedPartyIdentification */

void
FreeChargedPartyIdentification PARAMS ((v),
ChargedPartyIdentification *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->chargedPartyIdType)))
    {
    FreeChargedPartyIdType ((v->chargedPartyIdType));
    Asn1Free ((v->chargedPartyIdType));
    }

    if (ASNOCTS_PRESENT ((&v->chargedPartyIdentifier)))
    {
    FreeChargedPartyIdentifier ((&v->chargedPartyIdentifier));
    }

}  /* FreeChargedPartyIdentification */




AsnLen
BEncChargedPartyIdListContent PARAMS ((b, v),
BUF_TYPE b _AND_
ChargedPartyIdList *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    BEncEocIfNec (b);
    itemLen = BEncChargedPartyIdentificationContent (b, component);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 309);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncChargedPartyIdListContent */

void
BDecChargedPartyIdListContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ChargedPartyIdList *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        ChargedPartyIdentification **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (APPL, CONS, 309)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (ChargedPartyIdentification**) AsnListAppend (v);
    (*tmpVar) = (ChargedPartyIdentification*) Asn1Alloc (sizeof (ChargedPartyIdentification));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecChargedPartyIdentificationContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -168);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecChargedPartyIdListContent */

void
PrintChargedPartyIdList PARAMS ((f, v, indent),
FILE* f _AND_
ChargedPartyIdList *v _AND_
unsigned short int indent)
{
    ChargedPartyIdentification *tmp;
    if (v == NULL)
        return;
    fprintf (f,"{ -- SEQUENCE OF -- \n");
    FOR_EACH_LIST_ELMT (tmp, v)
    {
        Indent (f, indent+ stdIndentG);
        PrintChargedPartyIdentification (f, tmp, indent + stdIndentG);
        if (tmp != (ChargedPartyIdentification*)LAST_LIST_ELMT (v))
            fprintf (f,",\n");
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintChargedPartyIdList */

void
FreeChargedPartyIdList PARAMS ((v),
ChargedPartyIdList *v)
{

    AsnListNode *l;
    AsnListNode *tmp;
    if (v == NULL)
        return;
    for (l = FIRST_LIST_NODE (v); l != NULL; )
    {
        FreeChargedPartyIdentification ((l->data));
        tmp = l->next;
        Asn1Free (l->data);
        Asn1Free (l);
        l = tmp;
    }
}  /* FreeChargedPartyIdList */




AsnLen
BEncChargedPartyLocationContent PARAMS ((b, v),
BUF_TYPE b _AND_
ChargedPartyLocation *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (ASNOCTS_PRESENT ((&v->locationIdentifier)))
    {
    itemLen = BEncLocationIdentifierContent (b, (&v->locationIdentifier));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 289);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->locationIdType)))
    {
    itemLen = BEncLocationIdTypeContent (b, (v->locationIdType));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 315);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncChargedPartyLocationContent */

void
BDecChargedPartyLocationContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ChargedPartyLocation *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 315))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->locationIdType) = (LocationIdType*) Asn1Alloc (sizeof (LocationIdType));
    CheckAsn1Alloc ((v->locationIdType), env);
    BDecLocationIdTypeContent (b, tagId1, elmtLen1, (v->locationIdType), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 289)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 289))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecLocationIdentifierContent (b, tagId1, elmtLen1, (&v->locationIdentifier), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -169);
    }


    if (!seqDone)
        longjmp (env, -170);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecChargedPartyLocationContent */

void
PrintChargedPartyLocation PARAMS ((f, v, indent),
FILE* f _AND_
ChargedPartyLocation *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->locationIdType)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"locationIdType ");
    PrintLocationIdType (f, (v->locationIdType), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->locationIdentifier)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"locationIdentifier ");
    PrintLocationIdentifier (f, (&v->locationIdentifier), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintChargedPartyLocation */

void
FreeChargedPartyLocation PARAMS ((v),
ChargedPartyLocation *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->locationIdType)))
    {
    FreeLocationIdType ((v->locationIdType));
    Asn1Free ((v->locationIdType));
    }

    if (ASNOCTS_PRESENT ((&v->locationIdentifier)))
    {
    FreeLocationIdentifier ((&v->locationIdentifier));
    }

}  /* FreeChargedPartyLocation */




AsnLen
BEncChargedPartyLocationListContent PARAMS ((b, v),
BUF_TYPE b _AND_
ChargedPartyLocationList *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    BEncEocIfNec (b);
    itemLen = BEncChargedPartyLocationContent (b, component);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 320);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncChargedPartyLocationListContent */

void
BDecChargedPartyLocationListContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ChargedPartyLocationList *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        ChargedPartyLocation **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (APPL, CONS, 320)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (ChargedPartyLocation**) AsnListAppend (v);
    (*tmpVar) = (ChargedPartyLocation*) Asn1Alloc (sizeof (ChargedPartyLocation));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecChargedPartyLocationContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -171);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecChargedPartyLocationListContent */

void
PrintChargedPartyLocationList PARAMS ((f, v, indent),
FILE* f _AND_
ChargedPartyLocationList *v _AND_
unsigned short int indent)
{
    ChargedPartyLocation *tmp;
    if (v == NULL)
        return;
    fprintf (f,"{ -- SEQUENCE OF -- \n");
    FOR_EACH_LIST_ELMT (tmp, v)
    {
        Indent (f, indent+ stdIndentG);
        PrintChargedPartyLocation (f, tmp, indent + stdIndentG);
        if (tmp != (ChargedPartyLocation*)LAST_LIST_ELMT (v))
            fprintf (f,",\n");
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintChargedPartyLocationList */

void
FreeChargedPartyLocationList PARAMS ((v),
ChargedPartyLocationList *v)
{

    AsnListNode *l;
    AsnListNode *tmp;
    if (v == NULL)
        return;
    for (l = FIRST_LIST_NODE (v); l != NULL; )
    {
        FreeChargedPartyLocation ((l->data));
        tmp = l->next;
        Asn1Free (l->data);
        Asn1Free (l);
        l = tmp;
    }
}  /* FreeChargedPartyLocationList */




AsnLen
BEncContentProviderContent PARAMS ((b, v),
BUF_TYPE b _AND_
ContentProvider *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (ASNOCTS_PRESENT ((&v->contentProviderIdentifier)))
    {
    itemLen = BEncContentProviderIdentifierContent (b, (&v->contentProviderIdentifier));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 292);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->contentProviderIdType)))
    {
    itemLen = BEncContentProviderIdTypeContent (b, (v->contentProviderIdType));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 291);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncContentProviderContent */

void
BDecContentProviderContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ContentProvider *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 291))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->contentProviderIdType) = (ContentProviderIdType*) Asn1Alloc (sizeof (ContentProviderIdType));
    CheckAsn1Alloc ((v->contentProviderIdType), env);
    BDecContentProviderIdTypeContent (b, tagId1, elmtLen1, (v->contentProviderIdType), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 292)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 292))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecContentProviderIdentifierContent (b, tagId1, elmtLen1, (&v->contentProviderIdentifier), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -172);
    }


    if (!seqDone)
        longjmp (env, -173);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecContentProviderContent */

void
PrintContentProvider PARAMS ((f, v, indent),
FILE* f _AND_
ContentProvider *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->contentProviderIdType)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"contentProviderIdType ");
    PrintContentProviderIdType (f, (v->contentProviderIdType), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->contentProviderIdentifier)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"contentProviderIdentifier ");
    PrintContentProviderIdentifier (f, (&v->contentProviderIdentifier), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintContentProvider */

void
FreeContentProvider PARAMS ((v),
ContentProvider *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->contentProviderIdType)))
    {
    FreeContentProviderIdType ((v->contentProviderIdType));
    Asn1Free ((v->contentProviderIdType));
    }

    if (ASNOCTS_PRESENT ((&v->contentProviderIdentifier)))
    {
    FreeContentProviderIdentifier ((&v->contentProviderIdentifier));
    }

}  /* FreeContentProvider */




AsnLen
BEncContentProviderIdListContent PARAMS ((b, v),
BUF_TYPE b _AND_
ContentProviderIdList *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    BEncEocIfNec (b);
    itemLen = BEncContentProviderContent (b, component);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 327);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncContentProviderIdListContent */

void
BDecContentProviderIdListContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ContentProviderIdList *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        ContentProvider **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (APPL, CONS, 327)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (ContentProvider**) AsnListAppend (v);
    (*tmpVar) = (ContentProvider*) Asn1Alloc (sizeof (ContentProvider));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecContentProviderContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -174);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecContentProviderIdListContent */

void
PrintContentProviderIdList PARAMS ((f, v, indent),
FILE* f _AND_
ContentProviderIdList *v _AND_
unsigned short int indent)
{
    ContentProvider *tmp;
    if (v == NULL)
        return;
    fprintf (f,"{ -- SEQUENCE OF -- \n");
    FOR_EACH_LIST_ELMT (tmp, v)
    {
        Indent (f, indent+ stdIndentG);
        PrintContentProvider (f, tmp, indent + stdIndentG);
        if (tmp != (ContentProvider*)LAST_LIST_ELMT (v))
            fprintf (f,",\n");
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintContentProviderIdList */

void
FreeContentProviderIdList PARAMS ((v),
ContentProviderIdList *v)
{

    AsnListNode *l;
    AsnListNode *tmp;
    if (v == NULL)
        return;
    for (l = FIRST_LIST_NODE (v); l != NULL; )
    {
        FreeContentProvider ((l->data));
        tmp = l->next;
        Asn1Free (l->data);
        Asn1Free (l);
        l = tmp;
    }
}  /* FreeContentProviderIdList */




AsnLen
BEncCurrencyConversionContent PARAMS ((b, v),
BUF_TYPE b _AND_
CurrencyConversion *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->exchangeRate)))
    {
    itemLen = BEncExchangeRateContent (b, (v->exchangeRate));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, APPL, PRIM, 104);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->numberOfDecimalPlaces)))
    {
    itemLen = BEncNumberOfDecimalPlacesContent (b, (v->numberOfDecimalPlaces));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 159);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->exchangeRateCode)))
    {
    itemLen = BEncExchangeRateCodeContent (b, (v->exchangeRateCode));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, APPL, PRIM, 105);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncCurrencyConversionContent */

void
BDecCurrencyConversionContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
CurrencyConversion *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 105))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->exchangeRateCode) = (ExchangeRateCode*) Asn1Alloc (sizeof (ExchangeRateCode));
    CheckAsn1Alloc ((v->exchangeRateCode), env);
    BDecExchangeRateCodeContent (b, tagId1, elmtLen1, (v->exchangeRateCode), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 159))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->numberOfDecimalPlaces) = (NumberOfDecimalPlaces*) Asn1Alloc (sizeof (NumberOfDecimalPlaces));
    CheckAsn1Alloc ((v->numberOfDecimalPlaces), env);
    BDecNumberOfDecimalPlacesContent (b, tagId1, elmtLen1, (v->numberOfDecimalPlaces), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 104))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->exchangeRate) = (ExchangeRate*) Asn1Alloc (sizeof (ExchangeRate));
    CheckAsn1Alloc ((v->exchangeRate), env);
    BDecExchangeRateContent (b, tagId1, elmtLen1, (v->exchangeRate), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -175);
    }


    if (!seqDone)
        longjmp (env, -176);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecCurrencyConversionContent */

void
PrintCurrencyConversion PARAMS ((f, v, indent),
FILE* f _AND_
CurrencyConversion *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->exchangeRateCode)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"exchangeRateCode ");
    PrintExchangeRateCode (f, (v->exchangeRateCode), indent + stdIndentG);
    }
    if (NOT_NULL ((v->numberOfDecimalPlaces)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"numberOfDecimalPlaces ");
    PrintNumberOfDecimalPlaces (f, (v->numberOfDecimalPlaces), indent + stdIndentG);
    }
    if (NOT_NULL ((v->exchangeRate)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"exchangeRate ");
    PrintExchangeRate (f, (v->exchangeRate), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintCurrencyConversion */

void
FreeCurrencyConversion PARAMS ((v),
CurrencyConversion *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->exchangeRateCode)))
    {
    FreeExchangeRateCode ((v->exchangeRateCode));
    Asn1Free ((v->exchangeRateCode));
    }

    if (NOT_NULL ((v->numberOfDecimalPlaces)))
    {
    FreeNumberOfDecimalPlaces ((v->numberOfDecimalPlaces));
    Asn1Free ((v->numberOfDecimalPlaces));
    }

    if (NOT_NULL ((v->exchangeRate)))
    {
    FreeExchangeRate ((v->exchangeRate));
    Asn1Free ((v->exchangeRate));
    }

}  /* FreeCurrencyConversion */




AsnLen
BEncCurrencyConversionListContent PARAMS ((b, v),
BUF_TYPE b _AND_
CurrencyConversionList *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    BEncEocIfNec (b);
    itemLen = BEncCurrencyConversionContent (b, component);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 106);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncCurrencyConversionListContent */

void
BDecCurrencyConversionListContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
CurrencyConversionList *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        CurrencyConversion **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (APPL, CONS, 106)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (CurrencyConversion**) AsnListAppend (v);
    (*tmpVar) = (CurrencyConversion*) Asn1Alloc (sizeof (CurrencyConversion));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecCurrencyConversionContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -177);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecCurrencyConversionListContent */

void
PrintCurrencyConversionList PARAMS ((f, v, indent),
FILE* f _AND_
CurrencyConversionList *v _AND_
unsigned short int indent)
{
    CurrencyConversion *tmp;
    if (v == NULL)
        return;
    fprintf (f,"{ -- SEQUENCE OF -- \n");
    FOR_EACH_LIST_ELMT (tmp, v)
    {
        Indent (f, indent+ stdIndentG);
        PrintCurrencyConversion (f, tmp, indent + stdIndentG);
        if (tmp != (CurrencyConversion*)LAST_LIST_ELMT (v))
            fprintf (f,",\n");
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintCurrencyConversionList */

void
FreeCurrencyConversionList PARAMS ((v),
CurrencyConversionList *v)
{

    AsnListNode *l;
    AsnListNode *tmp;
    if (v == NULL)
        return;
    for (l = FIRST_LIST_NODE (v); l != NULL; )
    {
        FreeCurrencyConversion ((l->data));
        tmp = l->next;
        Asn1Free (l->data);
        Asn1Free (l);
        l = tmp;
    }
}  /* FreeCurrencyConversionList */




AsnLen
BEncDateTimeContent PARAMS ((b, v),
BUF_TYPE b _AND_
DateTime *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->utcTimeOffsetCode)))
    {
    itemLen = BEncUtcTimeOffsetCodeContent (b, (v->utcTimeOffsetCode));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 232);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->localTimeStamp)))
    {
    itemLen = BEncLocalTimeStampContent (b, (&v->localTimeStamp));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag1 (b, APPL, PRIM, 16);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncDateTimeContent */

void
BDecDateTimeContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
DateTime *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 16)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 16))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecLocalTimeStampContent (b, tagId1, elmtLen1, (&v->localTimeStamp), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 232))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->utcTimeOffsetCode) = (UtcTimeOffsetCode*) Asn1Alloc (sizeof (UtcTimeOffsetCode));
    CheckAsn1Alloc ((v->utcTimeOffsetCode), env);
    BDecUtcTimeOffsetCodeContent (b, tagId1, elmtLen1, (v->utcTimeOffsetCode), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -178);
    }


    if (!seqDone)
        longjmp (env, -179);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecDateTimeContent */

void
PrintDateTime PARAMS ((f, v, indent),
FILE* f _AND_
DateTime *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (ASNOCTS_PRESENT ((&v->localTimeStamp)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"localTimeStamp ");
    PrintLocalTimeStamp (f, (&v->localTimeStamp), indent + stdIndentG);
    }
    if (NOT_NULL ((v->utcTimeOffsetCode)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"utcTimeOffsetCode ");
    PrintUtcTimeOffsetCode (f, (v->utcTimeOffsetCode), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintDateTime */

void
FreeDateTime PARAMS ((v),
DateTime *v)
{

    if (v == NULL)
        return;
    if (ASNOCTS_PRESENT ((&v->localTimeStamp)))
    {
    FreeLocalTimeStamp ((&v->localTimeStamp));
    }

    if (NOT_NULL ((v->utcTimeOffsetCode)))
    {
    FreeUtcTimeOffsetCode ((v->utcTimeOffsetCode));
    Asn1Free ((v->utcTimeOffsetCode));
    }

}  /* FreeDateTime */




AsnLen
BEncDateTimeLongContent PARAMS ((b, v),
BUF_TYPE b _AND_
DateTimeLong *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (ASNOCTS_PRESENT ((&v->utcTimeOffset)))
    {
    itemLen = BEncUtcTimeOffsetContent (b, (&v->utcTimeOffset));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 231);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->localTimeStamp)))
    {
    itemLen = BEncLocalTimeStampContent (b, (&v->localTimeStamp));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag1 (b, APPL, PRIM, 16);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncDateTimeLongContent */

void
BDecDateTimeLongContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
DateTimeLong *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 16)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 16))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecLocalTimeStampContent (b, tagId1, elmtLen1, (&v->localTimeStamp), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 231)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 231))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecUtcTimeOffsetContent (b, tagId1, elmtLen1, (&v->utcTimeOffset), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -180);
    }


    if (!seqDone)
        longjmp (env, -181);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecDateTimeLongContent */

void
PrintDateTimeLong PARAMS ((f, v, indent),
FILE* f _AND_
DateTimeLong *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (ASNOCTS_PRESENT ((&v->localTimeStamp)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"localTimeStamp ");
    PrintLocalTimeStamp (f, (&v->localTimeStamp), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->utcTimeOffset)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"utcTimeOffset ");
    PrintUtcTimeOffset (f, (&v->utcTimeOffset), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintDateTimeLong */

void
FreeDateTimeLong PARAMS ((v),
DateTimeLong *v)
{

    if (v == NULL)
        return;
    if (ASNOCTS_PRESENT ((&v->localTimeStamp)))
    {
    FreeLocalTimeStamp ((&v->localTimeStamp));
    }

    if (ASNOCTS_PRESENT ((&v->utcTimeOffset)))
    {
    FreeUtcTimeOffset ((&v->utcTimeOffset));
    }

}  /* FreeDateTimeLong */




AsnLen
BEncDestinationContent PARAMS ((b, v),
BUF_TYPE b _AND_
Destination *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (ASNOCTS_PRESENT ((&v->sMSDestinationNumber)))
    {
    itemLen = BEncSMSDestinationNumberContent (b, (&v->sMSDestinationNumber));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 419);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->calledRegion)))
    {
    itemLen = BEncCalledRegionContent (b, (&v->calledRegion));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, PRIM, 46);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->calledPlace)))
    {
    itemLen = BEncCalledPlaceContent (b, (&v->calledPlace));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, PRIM, 42);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->dialledDigits)))
    {
    itemLen = BEncDialledDigitsContent (b, (&v->dialledDigits));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 279);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->calledNumber)))
    {
    itemLen = BEncCalledNumberContent (b, (&v->calledNumber));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 407);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncDestinationContent */

void
BDecDestinationContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
Destination *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 407)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 407))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecCalledNumberContent (b, tagId1, elmtLen1, (&v->calledNumber), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 279)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 279))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecDialledDigitsContent (b, tagId1, elmtLen1, (&v->dialledDigits), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 42)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 42))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecCalledPlaceContent (b, tagId1, elmtLen1, (&v->calledPlace), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 46)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 46))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecCalledRegionContent (b, tagId1, elmtLen1, (&v->calledRegion), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 419)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 419))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecSMSDestinationNumberContent (b, tagId1, elmtLen1, (&v->sMSDestinationNumber), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -182);
    }


    if (!seqDone)
        longjmp (env, -183);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecDestinationContent */

void
PrintDestination PARAMS ((f, v, indent),
FILE* f _AND_
Destination *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (ASNOCTS_PRESENT ((&v->calledNumber)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"calledNumber ");
    PrintCalledNumber (f, (&v->calledNumber), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->dialledDigits)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"dialledDigits ");
    PrintDialledDigits (f, (&v->dialledDigits), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->calledPlace)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"calledPlace ");
    PrintCalledPlace (f, (&v->calledPlace), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->calledRegion)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"calledRegion ");
    PrintCalledRegion (f, (&v->calledRegion), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->sMSDestinationNumber)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"sMSDestinationNumber ");
    PrintSMSDestinationNumber (f, (&v->sMSDestinationNumber), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintDestination */

void
FreeDestination PARAMS ((v),
Destination *v)
{

    if (v == NULL)
        return;
    if (ASNOCTS_PRESENT ((&v->calledNumber)))
    {
    FreeCalledNumber ((&v->calledNumber));
    }

    if (ASNOCTS_PRESENT ((&v->dialledDigits)))
    {
    FreeDialledDigits ((&v->dialledDigits));
    }

    if (ASNOCTS_PRESENT ((&v->calledPlace)))
    {
    FreeCalledPlace ((&v->calledPlace));
    }

    if (ASNOCTS_PRESENT ((&v->calledRegion)))
    {
    FreeCalledRegion ((&v->calledRegion));
    }

    if (ASNOCTS_PRESENT ((&v->sMSDestinationNumber)))
    {
    FreeSMSDestinationNumber ((&v->sMSDestinationNumber));
    }

}  /* FreeDestination */




AsnLen
BEncDiscountAppliedContent PARAMS ((b, v),
BUF_TYPE b _AND_
DiscountApplied *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    switch (v->choiceId)
    {
       case DISCOUNTAPPLIED_FIXEDDISCOUNTVALUE:
    itemLen = BEncFixedDiscountValueContent (b, (&v->a.fixedDiscountValue));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 411);

    totalLen += itemLen;

    break;

       case DISCOUNTAPPLIED_DISCOUNTRATE:
    itemLen = BEncDiscountRateContent (b, (&v->a.discountRate));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, APPL, PRIM, 92);

    totalLen += itemLen;

    break;

    }
    return totalLen;

}  /* BEncDiscountAppliedContent */

void
BDecDiscountAppliedContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
DiscountApplied *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    switch (tagId0)
    {
       case MAKE_TAG_ID (APPL, PRIM, 411):
        (v->choiceId) = DISCOUNTAPPLIED_FIXEDDISCOUNTVALUE;
    BDecFixedDiscountValueContent (b, tagId0, elmtLen0, (&v->a.fixedDiscountValue), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (APPL, PRIM, 92):
        (v->choiceId) = DISCOUNTAPPLIED_DISCOUNTRATE;
    BDecDiscountRateContent (b, tagId0, elmtLen0, (&v->a.discountRate), &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("ERROR - unexpected tag in CHOICE\n");
        longjmp (env, -184);
        break;
    } /* end switch */
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecDiscountAppliedContent */

void
PrintDiscountApplied PARAMS ((f, v, indent),
FILE* f _AND_
DiscountApplied *v _AND_
unsigned short int indent)
{
    switch (v->choiceId)
    {
      case DISCOUNTAPPLIED_FIXEDDISCOUNTVALUE:
          fprintf (f,"fixedDiscountValue ");
    PrintFixedDiscountValue (f, (&v->a.fixedDiscountValue), indent + stdIndentG);
          break;

      case DISCOUNTAPPLIED_DISCOUNTRATE:
          fprintf (f,"discountRate ");
    PrintDiscountRate (f, (&v->a.discountRate), indent + stdIndentG);
          break;

    }
}  /* PrintDiscountApplied */

void
FreeDiscountApplied PARAMS ((v),
DiscountApplied *v)
{

    if (v == NULL)
        return;
    switch (v->choiceId)
    {
    }
}  /* FreeDiscountApplied */




AsnLen
BEncDiscountInformationContent PARAMS ((b, v),
BUF_TYPE b _AND_
DiscountInformation *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->discountableAmount)))
    {
    itemLen = BEncDiscountableAmountContent (b, (v->discountableAmount));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 423);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->discount)))
    {
    itemLen = BEncDiscountContent (b, (v->discount));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 412);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->discountCode)))
    {
    itemLen = BEncDiscountCodeContent (b, (v->discountCode));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, APPL, PRIM, 91);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncDiscountInformationContent */

void
BDecDiscountInformationContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
DiscountInformation *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 91))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->discountCode) = (DiscountCode*) Asn1Alloc (sizeof (DiscountCode));
    CheckAsn1Alloc ((v->discountCode), env);
    BDecDiscountCodeContent (b, tagId1, elmtLen1, (v->discountCode), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 412))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->discount) = (Discount*) Asn1Alloc (sizeof (Discount));
    CheckAsn1Alloc ((v->discount), env);
    BDecDiscountContent (b, tagId1, elmtLen1, (v->discount), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 423))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->discountableAmount) = (DiscountableAmount*) Asn1Alloc (sizeof (DiscountableAmount));
    CheckAsn1Alloc ((v->discountableAmount), env);
    BDecDiscountableAmountContent (b, tagId1, elmtLen1, (v->discountableAmount), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -185);
    }


    if (!seqDone)
        longjmp (env, -186);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecDiscountInformationContent */

void
PrintDiscountInformation PARAMS ((f, v, indent),
FILE* f _AND_
DiscountInformation *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->discountCode)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"discountCode ");
    PrintDiscountCode (f, (v->discountCode), indent + stdIndentG);
    }
    if (NOT_NULL ((v->discount)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"discount ");
    PrintDiscount (f, (v->discount), indent + stdIndentG);
    }
    if (NOT_NULL ((v->discountableAmount)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"discountableAmount ");
    PrintDiscountableAmount (f, (v->discountableAmount), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintDiscountInformation */

void
FreeDiscountInformation PARAMS ((v),
DiscountInformation *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->discountCode)))
    {
    FreeDiscountCode ((v->discountCode));
    Asn1Free ((v->discountCode));
    }

    if (NOT_NULL ((v->discount)))
    {
    FreeDiscount ((v->discount));
    Asn1Free ((v->discount));
    }

    if (NOT_NULL ((v->discountableAmount)))
    {
    FreeDiscountableAmount ((v->discountableAmount));
    Asn1Free ((v->discountableAmount));
    }

}  /* FreeDiscountInformation */




AsnLen
BEncDiscountingContent PARAMS ((b, v),
BUF_TYPE b _AND_
Discounting *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->discountApplied)))
    {
    BEncEocIfNec (b);
    itemLen = BEncDiscountAppliedContent (b, (v->discountApplied));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 428);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->discountCode)))
    {
    itemLen = BEncDiscountCodeContent (b, (v->discountCode));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, APPL, PRIM, 91);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncDiscountingContent */

void
BDecDiscountingContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
Discounting *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 91))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->discountCode) = (DiscountCode*) Asn1Alloc (sizeof (DiscountCode));
    CheckAsn1Alloc ((v->discountCode), env);
    BDecDiscountCodeContent (b, tagId1, elmtLen1, (v->discountCode), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 428))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->discountApplied) = (DiscountApplied*) Asn1Alloc (sizeof (DiscountApplied));
    CheckAsn1Alloc ((v->discountApplied), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecDiscountAppliedContent (b, tagId2, elmtLen2, (v->discountApplied), &totalElmtsLen1, env);
    /*if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);*/
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -187);
    }


    if (!seqDone)
        longjmp (env, -188);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecDiscountingContent */

void
PrintDiscounting PARAMS ((f, v, indent),
FILE* f _AND_
Discounting *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->discountCode)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"discountCode ");
    PrintDiscountCode (f, (v->discountCode), indent + stdIndentG);
    }
    if (NOT_NULL ((v->discountApplied)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"discountApplied ");
    PrintDiscountApplied (f, (v->discountApplied), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintDiscounting */

void
FreeDiscounting PARAMS ((v),
Discounting *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->discountCode)))
    {
    FreeDiscountCode ((v->discountCode));
    Asn1Free ((v->discountCode));
    }

    if (NOT_NULL ((v->discountApplied)))
    {
    FreeDiscountApplied ((v->discountApplied));
    Asn1Free ((v->discountApplied));
    }

}  /* FreeDiscounting */




AsnLen
BEncDiscountingListContent PARAMS ((b, v),
BUF_TYPE b _AND_
DiscountingList *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    BEncEocIfNec (b);
    itemLen = BEncDiscountingContent (b, component);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 94);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncDiscountingListContent */

void
BDecDiscountingListContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
DiscountingList *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        Discounting **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (APPL, CONS, 94)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (Discounting**) AsnListAppend (v);
    (*tmpVar) = (Discounting*) Asn1Alloc (sizeof (Discounting));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecDiscountingContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -189);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecDiscountingListContent */

void
PrintDiscountingList PARAMS ((f, v, indent),
FILE* f _AND_
DiscountingList *v _AND_
unsigned short int indent)
{
    Discounting *tmp;
    if (v == NULL)
        return;
    fprintf (f,"{ -- SEQUENCE OF -- \n");
    FOR_EACH_LIST_ELMT (tmp, v)
    {
        Indent (f, indent+ stdIndentG);
        PrintDiscounting (f, tmp, indent + stdIndentG);
        if (tmp != (Discounting*)LAST_LIST_ELMT (v))
            fprintf (f,",\n");
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintDiscountingList */

void
FreeDiscountingList PARAMS ((v),
DiscountingList *v)
{

    AsnListNode *l;
    AsnListNode *tmp;
    if (v == NULL)
        return;
    for (l = FIRST_LIST_NODE (v); l != NULL; )
    {
        FreeDiscounting ((l->data));
        tmp = l->next;
        Asn1Free (l->data);
        Asn1Free (l);
        l = tmp;
    }
}  /* FreeDiscountingList */




AsnLen
BEncGprsChargeableSubscriberContent PARAMS ((b, v),
BUF_TYPE b _AND_
GprsChargeableSubscriber *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (ASNOCTS_PRESENT ((&v->networkAccessIdentifier)))
    {
    itemLen = BEncNetworkAccessIdentifierContent (b, (&v->networkAccessIdentifier));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 417);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->pdpAddress)))
    {
    itemLen = BEncPdpAddressContent (b, (&v->pdpAddress));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 167);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->chargeableSubscriber)))
    {
    BEncEocIfNec (b);
    itemLen = BEncChargeableSubscriberContent (b, (v->chargeableSubscriber));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 427);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncGprsChargeableSubscriberContent */

void
BDecGprsChargeableSubscriberContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GprsChargeableSubscriber *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 427))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->chargeableSubscriber) = (ChargeableSubscriber*) Asn1Alloc (sizeof (ChargeableSubscriber));
    CheckAsn1Alloc ((v->chargeableSubscriber), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecChargeableSubscriberContent (b, tagId2, elmtLen2, (v->chargeableSubscriber), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    /*if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);*/
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 167)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 167))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecPdpAddressContent (b, tagId1, elmtLen1, (&v->pdpAddress), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 417)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 417))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecNetworkAccessIdentifierContent (b, tagId1, elmtLen1, (&v->networkAccessIdentifier), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -190);
    }


    if (!seqDone)
        longjmp (env, -191);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGprsChargeableSubscriberContent */

void
PrintGprsChargeableSubscriber PARAMS ((f, v, indent),
FILE* f _AND_
GprsChargeableSubscriber *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->chargeableSubscriber)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"chargeableSubscriber ");
    PrintChargeableSubscriber (f, (v->chargeableSubscriber), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->pdpAddress)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"pdpAddress ");
    PrintPdpAddress (f, (&v->pdpAddress), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->networkAccessIdentifier)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"networkAccessIdentifier ");
    PrintNetworkAccessIdentifier (f, (&v->networkAccessIdentifier), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintGprsChargeableSubscriber */

void
FreeGprsChargeableSubscriber PARAMS ((v),
GprsChargeableSubscriber *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->chargeableSubscriber)))
    {
    FreeChargeableSubscriber ((v->chargeableSubscriber));
    Asn1Free ((v->chargeableSubscriber));
    }

    if (ASNOCTS_PRESENT ((&v->pdpAddress)))
    {
    FreePdpAddress ((&v->pdpAddress));
    }

    if (ASNOCTS_PRESENT ((&v->networkAccessIdentifier)))
    {
    FreeNetworkAccessIdentifier ((&v->networkAccessIdentifier));
    }

}  /* FreeGprsChargeableSubscriber */




AsnLen
BEncGprsNetworkLocationContent PARAMS ((b, v),
BUF_TYPE b _AND_
GprsNetworkLocation *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->cellId)))
    {
    itemLen = BEncCellIdContent (b, (v->cellId));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, APPL, PRIM, 59);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->locationArea)))
    {
    itemLen = BEncLocationAreaContent (b, (v->locationArea));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 136);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->recEntity)))
    {
    BEncEocIfNec (b);
    itemLen = BEncRecEntityCodeListContent (b, (v->recEntity));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 185);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncGprsNetworkLocationContent */

void
BDecGprsNetworkLocationContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GprsNetworkLocation *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 185))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->recEntity) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->recEntity), env);
    BDecRecEntityCodeListContent (b, tagId1, elmtLen1, (v->recEntity), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 136))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->locationArea) = (LocationArea*) Asn1Alloc (sizeof (LocationArea));
    CheckAsn1Alloc ((v->locationArea), env);
    BDecLocationAreaContent (b, tagId1, elmtLen1, (v->locationArea), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 59))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->cellId) = (CellId*) Asn1Alloc (sizeof (CellId));
    CheckAsn1Alloc ((v->cellId), env);
    BDecCellIdContent (b, tagId1, elmtLen1, (v->cellId), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -192);
    }


    if (!seqDone)
        longjmp (env, -193);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGprsNetworkLocationContent */

void
PrintGprsNetworkLocation PARAMS ((f, v, indent),
FILE* f _AND_
GprsNetworkLocation *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->recEntity)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"recEntity ");
    PrintRecEntityCodeList (f, (v->recEntity), indent + stdIndentG);
    }
    if (NOT_NULL ((v->locationArea)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"locationArea ");
    PrintLocationArea (f, (v->locationArea), indent + stdIndentG);
    }
    if (NOT_NULL ((v->cellId)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"cellId ");
    PrintCellId (f, (v->cellId), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintGprsNetworkLocation */

void
FreeGprsNetworkLocation PARAMS ((v),
GprsNetworkLocation *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->recEntity)))
    {
    FreeRecEntityCodeList ((v->recEntity));
    Asn1Free ((v->recEntity));
    }

    if (NOT_NULL ((v->locationArea)))
    {
    FreeLocationArea ((v->locationArea));
    Asn1Free ((v->locationArea));
    }

    if (NOT_NULL ((v->cellId)))
    {
    FreeCellId ((v->cellId));
    Asn1Free ((v->cellId));
    }

}  /* FreeGprsNetworkLocation */




AsnLen
BEncGsmChargeableSubscriberContent PARAMS ((b, v),
BUF_TYPE b _AND_
GsmChargeableSubscriber *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (ASNOCTS_PRESENT ((&v->msisdn)))
    {
    itemLen = BEncMsisdnContent (b, (&v->msisdn));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 152);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->imsi)))
    {
    itemLen = BEncImsiContent (b, (&v->imsi));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 129);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncGsmChargeableSubscriberContent */

void
BDecGsmChargeableSubscriberContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GsmChargeableSubscriber *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 129)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 129))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecImsiContent (b, tagId1, elmtLen1, (&v->imsi), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 152)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 152))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecMsisdnContent (b, tagId1, elmtLen1, (&v->msisdn), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -194);
    }


    if (!seqDone)
        longjmp (env, -195);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGsmChargeableSubscriberContent */

void
PrintGsmChargeableSubscriber PARAMS ((f, v, indent),
FILE* f _AND_
GsmChargeableSubscriber *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (ASNOCTS_PRESENT ((&v->imsi)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"imsi ");
    PrintImsi (f, (&v->imsi), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->msisdn)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"msisdn ");
    PrintMsisdn (f, (&v->msisdn), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintGsmChargeableSubscriber */

void
FreeGsmChargeableSubscriber PARAMS ((v),
GsmChargeableSubscriber *v)
{

    if (v == NULL)
        return;
    if (ASNOCTS_PRESENT ((&v->imsi)))
    {
    FreeImsi ((&v->imsi));
    }

    if (ASNOCTS_PRESENT ((&v->msisdn)))
    {
    FreeMsisdn ((&v->msisdn));
    }

}  /* FreeGsmChargeableSubscriber */




AsnLen
BEncHomeLocationInformationContent PARAMS ((b, v),
BUF_TYPE b _AND_
HomeLocationInformation *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (ASNOCTS_PRESENT ((&v->homeLocationDescription)))
    {
    itemLen = BEncHomeLocationDescriptionContent (b, (&v->homeLocationDescription));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 413);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->homeBid)))
    {
    itemLen = BEncHomeBidContent (b, (&v->homeBid));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, PRIM, 122);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncHomeLocationInformationContent */

void
BDecHomeLocationInformationContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
HomeLocationInformation *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 122)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 122))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecHomeBidContent (b, tagId1, elmtLen1, (&v->homeBid), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 413)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 413))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecHomeLocationDescriptionContent (b, tagId1, elmtLen1, (&v->homeLocationDescription), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -196);
    }


    if (!seqDone)
        longjmp (env, -197);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecHomeLocationInformationContent */

void
PrintHomeLocationInformation PARAMS ((f, v, indent),
FILE* f _AND_
HomeLocationInformation *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (ASNOCTS_PRESENT ((&v->homeBid)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"homeBid ");
    PrintHomeBid (f, (&v->homeBid), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->homeLocationDescription)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"homeLocationDescription ");
    PrintHomeLocationDescription (f, (&v->homeLocationDescription), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintHomeLocationInformation */

void
FreeHomeLocationInformation PARAMS ((v),
HomeLocationInformation *v)
{

    if (v == NULL)
        return;
    if (ASNOCTS_PRESENT ((&v->homeBid)))
    {
    FreeHomeBid ((&v->homeBid));
    }

    if (ASNOCTS_PRESENT ((&v->homeLocationDescription)))
    {
    FreeHomeLocationDescription ((&v->homeLocationDescription));
    }

}  /* FreeHomeLocationInformation */




AsnLen
BEncInternetServiceProviderContent PARAMS ((b, v),
BUF_TYPE b _AND_
InternetServiceProvider *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (ASNOCTS_PRESENT ((&v->ispIdentifier)))
    {
    itemLen = BEncIspIdentifierContent (b, (&v->ispIdentifier));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 294);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->ispIdType)))
    {
    itemLen = BEncIspIdTypeContent (b, (v->ispIdType));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 293);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncInternetServiceProviderContent */

void
BDecInternetServiceProviderContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
InternetServiceProvider *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 293))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->ispIdType) = (IspIdType*) Asn1Alloc (sizeof (IspIdType));
    CheckAsn1Alloc ((v->ispIdType), env);
    BDecIspIdTypeContent (b, tagId1, elmtLen1, (v->ispIdType), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 294)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 294))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecIspIdentifierContent (b, tagId1, elmtLen1, (&v->ispIdentifier), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -198);
    }


    if (!seqDone)
        longjmp (env, -199);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecInternetServiceProviderContent */

void
PrintInternetServiceProvider PARAMS ((f, v, indent),
FILE* f _AND_
InternetServiceProvider *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->ispIdType)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"ispIdType ");
    PrintIspIdType (f, (v->ispIdType), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->ispIdentifier)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"ispIdentifier ");
    PrintIspIdentifier (f, (&v->ispIdentifier), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintInternetServiceProvider */

void
FreeInternetServiceProvider PARAMS ((v),
InternetServiceProvider *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->ispIdType)))
    {
    FreeIspIdType ((v->ispIdType));
    Asn1Free ((v->ispIdType));
    }

    if (ASNOCTS_PRESENT ((&v->ispIdentifier)))
    {
    FreeIspIdentifier ((&v->ispIdentifier));
    }

}  /* FreeInternetServiceProvider */




AsnLen
BEncInternetServiceProviderIdListContent PARAMS ((b, v),
BUF_TYPE b _AND_
InternetServiceProviderIdList *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    BEncEocIfNec (b);
    itemLen = BEncInternetServiceProviderContent (b, component);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 329);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncInternetServiceProviderIdListContent */

void
BDecInternetServiceProviderIdListContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
InternetServiceProviderIdList *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        InternetServiceProvider **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (APPL, CONS, 329)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (InternetServiceProvider**) AsnListAppend (v);
    (*tmpVar) = (InternetServiceProvider*) Asn1Alloc (sizeof (InternetServiceProvider));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecInternetServiceProviderContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -200);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecInternetServiceProviderIdListContent */

void
PrintInternetServiceProviderIdList PARAMS ((f, v, indent),
FILE* f _AND_
InternetServiceProviderIdList *v _AND_
unsigned short int indent)
{
    InternetServiceProvider *tmp;
    if (v == NULL)
        return;
    fprintf (f,"{ -- SEQUENCE OF -- \n");
    FOR_EACH_LIST_ELMT (tmp, v)
    {
        Indent (f, indent+ stdIndentG);
        PrintInternetServiceProvider (f, tmp, indent + stdIndentG);
        if (tmp != (InternetServiceProvider*)LAST_LIST_ELMT (v))
            fprintf (f,",\n");
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintInternetServiceProviderIdList */

void
FreeInternetServiceProviderIdList PARAMS ((v),
InternetServiceProviderIdList *v)
{

    AsnListNode *l;
    AsnListNode *tmp;
    if (v == NULL)
        return;
    for (l = FIRST_LIST_NODE (v); l != NULL; )
    {
        FreeInternetServiceProvider ((l->data));
        tmp = l->next;
        Asn1Free (l->data);
        Asn1Free (l);
        l = tmp;
    }
}  /* FreeInternetServiceProviderIdList */




AsnLen
BEncISPListContent PARAMS ((b, v),
BUF_TYPE b _AND_
ISPList *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    BEncEocIfNec (b);
    itemLen = BEncInternetServiceProviderContent (b, component);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 329);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncISPListContent */

void
BDecISPListContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ISPList *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        InternetServiceProvider **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (APPL, CONS, 329)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (InternetServiceProvider**) AsnListAppend (v);
    (*tmpVar) = (InternetServiceProvider*) Asn1Alloc (sizeof (InternetServiceProvider));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecInternetServiceProviderContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -201);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecISPListContent */

void
PrintISPList PARAMS ((f, v, indent),
FILE* f _AND_
ISPList *v _AND_
unsigned short int indent)
{
    InternetServiceProvider *tmp;
    if (v == NULL)
        return;
    fprintf (f,"{ -- SEQUENCE OF -- \n");
    FOR_EACH_LIST_ELMT (tmp, v)
    {
        Indent (f, indent+ stdIndentG);
        PrintInternetServiceProvider (f, tmp, indent + stdIndentG);
        if (tmp != (InternetServiceProvider*)LAST_LIST_ELMT (v))
            fprintf (f,",\n");
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintISPList */

void
FreeISPList PARAMS ((v),
ISPList *v)
{

    AsnListNode *l;
    AsnListNode *tmp;
    if (v == NULL)
        return;
    for (l = FIRST_LIST_NODE (v); l != NULL; )
    {
        FreeInternetServiceProvider ((l->data));
        tmp = l->next;
        Asn1Free (l->data);
        Asn1Free (l);
        l = tmp;
    }
}  /* FreeISPList */




AsnLen
BEncLCSSPInformationContent PARAMS ((b, v),
BUF_TYPE b _AND_
LCSSPInformation *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->networkList)))
    {
    BEncEocIfNec (b);
    itemLen = BEncNetworkListContent (b, (v->networkList));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 333);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->iSPList)))
    {
    BEncEocIfNec (b);
    itemLen = BEncISPListContent (b, (v->iSPList));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 378);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->lCSSPIdentificationList)))
    {
    BEncEocIfNec (b);
    itemLen = BEncLCSSPIdentificationListContent (b, (v->lCSSPIdentificationList));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 374);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncLCSSPInformationContent */

void
BDecLCSSPInformationContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
LCSSPInformation *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 374))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->lCSSPIdentificationList) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->lCSSPIdentificationList), env);
    BDecLCSSPIdentificationListContent (b, tagId1, elmtLen1, (v->lCSSPIdentificationList), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 378))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->iSPList) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->iSPList), env);
    BDecISPListContent (b, tagId1, elmtLen1, (v->iSPList), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 333))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->networkList) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->networkList), env);
    BDecNetworkListContent (b, tagId1, elmtLen1, (v->networkList), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -202);
    }


    if (!seqDone)
        longjmp (env, -203);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecLCSSPInformationContent */

void
PrintLCSSPInformation PARAMS ((f, v, indent),
FILE* f _AND_
LCSSPInformation *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->lCSSPIdentificationList)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"lCSSPIdentificationList ");
    PrintLCSSPIdentificationList (f, (v->lCSSPIdentificationList), indent + stdIndentG);
    }
    if (NOT_NULL ((v->iSPList)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"iSPList ");
    PrintISPList (f, (v->iSPList), indent + stdIndentG);
    }
    if (NOT_NULL ((v->networkList)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"networkList ");
    PrintNetworkList (f, (v->networkList), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintLCSSPInformation */

void
FreeLCSSPInformation PARAMS ((v),
LCSSPInformation *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->lCSSPIdentificationList)))
    {
    FreeLCSSPIdentificationList ((v->lCSSPIdentificationList));
    Asn1Free ((v->lCSSPIdentificationList));
    }

    if (NOT_NULL ((v->iSPList)))
    {
    FreeISPList ((v->iSPList));
    Asn1Free ((v->iSPList));
    }

    if (NOT_NULL ((v->networkList)))
    {
    FreeNetworkList ((v->networkList));
    Asn1Free ((v->networkList));
    }

}  /* FreeLCSSPInformation */




AsnLen
BEncNetworkLocationContent PARAMS ((b, v),
BUF_TYPE b _AND_
NetworkLocation *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->cellId)))
    {
    itemLen = BEncCellIdContent (b, (v->cellId));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, APPL, PRIM, 59);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->locationArea)))
    {
    itemLen = BEncLocationAreaContent (b, (v->locationArea));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 136);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->callReference)))
    {
    itemLen = BEncCallReferenceContent (b, (&v->callReference));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, PRIM, 45);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->recEntityCode)))
    {
    itemLen = BEncRecEntityCodeContent (b, (v->recEntityCode));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 184);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncNetworkLocationContent */

void
BDecNetworkLocationContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
NetworkLocation *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 184))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->recEntityCode) = (RecEntityCode*) Asn1Alloc (sizeof (RecEntityCode));
    CheckAsn1Alloc ((v->recEntityCode), env);
    BDecRecEntityCodeContent (b, tagId1, elmtLen1, (v->recEntityCode), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 45)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 45))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecCallReferenceContent (b, tagId1, elmtLen1, (&v->callReference), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 136))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->locationArea) = (LocationArea*) Asn1Alloc (sizeof (LocationArea));
    CheckAsn1Alloc ((v->locationArea), env);
    BDecLocationAreaContent (b, tagId1, elmtLen1, (v->locationArea), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 59))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->cellId) = (CellId*) Asn1Alloc (sizeof (CellId));
    CheckAsn1Alloc ((v->cellId), env);
    BDecCellIdContent (b, tagId1, elmtLen1, (v->cellId), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -204);
    }


    if (!seqDone)
        longjmp (env, -205);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecNetworkLocationContent */

void
PrintNetworkLocation PARAMS ((f, v, indent),
FILE* f _AND_
NetworkLocation *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->recEntityCode)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"recEntityCode ");
    PrintRecEntityCode (f, (v->recEntityCode), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->callReference)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"callReference ");
    PrintCallReference (f, (&v->callReference), indent + stdIndentG);
    }
    if (NOT_NULL ((v->locationArea)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"locationArea ");
    PrintLocationArea (f, (v->locationArea), indent + stdIndentG);
    }
    if (NOT_NULL ((v->cellId)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"cellId ");
    PrintCellId (f, (v->cellId), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintNetworkLocation */

void
FreeNetworkLocation PARAMS ((v),
NetworkLocation *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->recEntityCode)))
    {
    FreeRecEntityCode ((v->recEntityCode));
    Asn1Free ((v->recEntityCode));
    }

    if (ASNOCTS_PRESENT ((&v->callReference)))
    {
    FreeCallReference ((&v->callReference));
    }

    if (NOT_NULL ((v->locationArea)))
    {
    FreeLocationArea ((v->locationArea));
    Asn1Free ((v->locationArea));
    }

    if (NOT_NULL ((v->cellId)))
    {
    FreeCellId ((v->cellId));
    Asn1Free ((v->cellId));
    }

}  /* FreeNetworkLocation */




AsnLen
BEncNonChargedPartyContent PARAMS ((b, v),
BUF_TYPE b _AND_
NonChargedParty *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (ASNOCTS_PRESENT ((&v->nonChargedPublicUserId)))
    {
    itemLen = BEncNonChargedPublicUserIdContent (b, (&v->nonChargedPublicUserId));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 445);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->nonChargedPartyNumber)))
    {
    itemLen = BEncNonChargedPartyNumberContent (b, (&v->nonChargedPartyNumber));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 444);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncNonChargedPartyContent */

void
BDecNonChargedPartyContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
NonChargedParty *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 444)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 444))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecNonChargedPartyNumberContent (b, tagId1, elmtLen1, (&v->nonChargedPartyNumber), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 445)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 445))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecNonChargedPublicUserIdContent (b, tagId1, elmtLen1, (&v->nonChargedPublicUserId), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -206);
    }


    if (!seqDone)
        longjmp (env, -207);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecNonChargedPartyContent */

void
PrintNonChargedParty PARAMS ((f, v, indent),
FILE* f _AND_
NonChargedParty *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (ASNOCTS_PRESENT ((&v->nonChargedPartyNumber)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"nonChargedPartyNumber ");
    PrintNonChargedPartyNumber (f, (&v->nonChargedPartyNumber), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->nonChargedPublicUserId)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"nonChargedPublicUserId ");
    PrintNonChargedPublicUserId (f, (&v->nonChargedPublicUserId), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintNonChargedParty */

void
FreeNonChargedParty PARAMS ((v),
NonChargedParty *v)
{

    if (v == NULL)
        return;
    if (ASNOCTS_PRESENT ((&v->nonChargedPartyNumber)))
    {
    FreeNonChargedPartyNumber ((&v->nonChargedPartyNumber));
    }

    if (ASNOCTS_PRESENT ((&v->nonChargedPublicUserId)))
    {
    FreeNonChargedPublicUserId ((&v->nonChargedPublicUserId));
    }

}  /* FreeNonChargedParty */




AsnLen
BEncOperatorSpecInfoListContent PARAMS ((b, v),
BUF_TYPE b _AND_
OperatorSpecInfoList *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    itemLen = BEncOperatorSpecInformationContent (b, component);
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 163);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncOperatorSpecInfoListContent */

void
BDecOperatorSpecInfoListContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
OperatorSpecInfoList *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        OperatorSpecInformation **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 163)) ||
       (tagId1 == MAKE_TAG_ID (APPL, CONS, 163)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (OperatorSpecInformation**) AsnListAppend (v);
    (*tmpVar) = (OperatorSpecInformation*) Asn1Alloc (sizeof (OperatorSpecInformation));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecOperatorSpecInformationContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -208);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecOperatorSpecInfoListContent */

void
PrintOperatorSpecInfoList PARAMS ((f, v, indent),
FILE* f _AND_
OperatorSpecInfoList *v _AND_
unsigned short int indent)
{
    OperatorSpecInformation *tmp;
    if (v == NULL)
        return;
    fprintf (f,"{ -- SEQUENCE OF -- \n");
    FOR_EACH_LIST_ELMT (tmp, v)
    {
        Indent (f, indent+ stdIndentG);
        PrintOperatorSpecInformation (f, tmp, indent + stdIndentG);
        if (tmp != (OperatorSpecInformation*)LAST_LIST_ELMT (v))
            fprintf (f,",\n");
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintOperatorSpecInfoList */

void
FreeOperatorSpecInfoList PARAMS ((v),
OperatorSpecInfoList *v)
{

    AsnListNode *l;
    AsnListNode *tmp;
    if (v == NULL)
        return;
    for (l = FIRST_LIST_NODE (v); l != NULL; )
    {
        FreeOperatorSpecInformation ((l->data));
        tmp = l->next;
        Asn1Free (l->data);
        Asn1Free (l);
        l = tmp;
    }
}  /* FreeOperatorSpecInfoList */




AsnLen
BEncRecEntityInfoListContent PARAMS ((b, v),
BUF_TYPE b _AND_
RecEntityInfoList *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    BEncEocIfNec (b);
    itemLen = BEncRecEntityInformationContent (b, component);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 183);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncRecEntityInfoListContent */

void
BDecRecEntityInfoListContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
RecEntityInfoList *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        RecEntityInformation **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (APPL, CONS, 183)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (RecEntityInformation**) AsnListAppend (v);
    (*tmpVar) = (RecEntityInformation*) Asn1Alloc (sizeof (RecEntityInformation));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecRecEntityInformationContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -209);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecRecEntityInfoListContent */

void
PrintRecEntityInfoList PARAMS ((f, v, indent),
FILE* f _AND_
RecEntityInfoList *v _AND_
unsigned short int indent)
{
    RecEntityInformation *tmp;
    if (v == NULL)
        return;
    fprintf (f,"{ -- SEQUENCE OF -- \n");
    FOR_EACH_LIST_ELMT (tmp, v)
    {
        Indent (f, indent+ stdIndentG);
        PrintRecEntityInformation (f, tmp, indent + stdIndentG);
        if (tmp != (RecEntityInformation*)LAST_LIST_ELMT (v))
            fprintf (f,",\n");
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintRecEntityInfoList */

void
FreeRecEntityInfoList PARAMS ((v),
RecEntityInfoList *v)
{

    AsnListNode *l;
    AsnListNode *tmp;
    if (v == NULL)
        return;
    for (l = FIRST_LIST_NODE (v); l != NULL; )
    {
        FreeRecEntityInformation ((l->data));
        tmp = l->next;
        Asn1Free (l->data);
        Asn1Free (l);
        l = tmp;
    }
}  /* FreeRecEntityInfoList */




AsnLen
BEncScuChargeableSubscriberContent PARAMS ((b, v),
BUF_TYPE b _AND_
ScuChargeableSubscriber *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    switch (v->choiceId)
    {
       case SCUCHARGEABLESUBSCRIBER_GSMCHARGEABLESUBSCRIBER:
    BEncEocIfNec (b);
    itemLen = BEncGsmChargeableSubscriberContent (b, (v->a.gsmChargeableSubscriber));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 286);

    totalLen += itemLen;

    break;

       case SCUCHARGEABLESUBSCRIBER_MINCHARGEABLESUBSCRIBER:
    BEncEocIfNec (b);
    itemLen = BEncMinChargeableSubscriberContent (b, (v->a.minChargeableSubscriber));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 254);

    totalLen += itemLen;

    break;

    }
    return totalLen;

}  /* BEncScuChargeableSubscriberContent */

void
BDecScuChargeableSubscriberContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ScuChargeableSubscriber *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    switch (tagId0)
    {
       case MAKE_TAG_ID (APPL, CONS, 286):
        (v->choiceId) = SCUCHARGEABLESUBSCRIBER_GSMCHARGEABLESUBSCRIBER;
    (v->a.gsmChargeableSubscriber) = (GsmChargeableSubscriber*) Asn1Alloc (sizeof (GsmChargeableSubscriber));
    CheckAsn1Alloc ((v->a.gsmChargeableSubscriber), env);
    BDecGsmChargeableSubscriberContent (b, tagId0, elmtLen0, (v->a.gsmChargeableSubscriber), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (APPL, CONS, 254):
        (v->choiceId) = SCUCHARGEABLESUBSCRIBER_MINCHARGEABLESUBSCRIBER;
    (v->a.minChargeableSubscriber) = (MinChargeableSubscriber*) Asn1Alloc (sizeof (MinChargeableSubscriber));
    CheckAsn1Alloc ((v->a.minChargeableSubscriber), env);
    BDecMinChargeableSubscriberContent (b, tagId0, elmtLen0, (v->a.minChargeableSubscriber), &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("ERROR - unexpected tag in CHOICE\n");
        longjmp (env, -210);
        break;
    } /* end switch */
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecScuChargeableSubscriberContent */

void
PrintScuChargeableSubscriber PARAMS ((f, v, indent),
FILE* f _AND_
ScuChargeableSubscriber *v _AND_
unsigned short int indent)
{
    switch (v->choiceId)
    {
      case SCUCHARGEABLESUBSCRIBER_GSMCHARGEABLESUBSCRIBER:
          fprintf (f,"gsmChargeableSubscriber ");
    PrintGsmChargeableSubscriber (f, (v->a.gsmChargeableSubscriber), indent + stdIndentG);
          break;

      case SCUCHARGEABLESUBSCRIBER_MINCHARGEABLESUBSCRIBER:
          fprintf (f,"minChargeableSubscriber ");
    PrintMinChargeableSubscriber (f, (v->a.minChargeableSubscriber), indent + stdIndentG);
          break;

    }
}  /* PrintScuChargeableSubscriber */

void
FreeScuChargeableSubscriber PARAMS ((v),
ScuChargeableSubscriber *v)
{

    if (v == NULL)
        return;
    switch (v->choiceId)
    {
       case SCUCHARGEABLESUBSCRIBER_GSMCHARGEABLESUBSCRIBER:
    FreeGsmChargeableSubscriber ((v->a.gsmChargeableSubscriber));
    Asn1Free ((v->a.gsmChargeableSubscriber));

    break;

       case SCUCHARGEABLESUBSCRIBER_MINCHARGEABLESUBSCRIBER:
    FreeMinChargeableSubscriber ((v->a.minChargeableSubscriber));
    Asn1Free ((v->a.minChargeableSubscriber));

    break;

    }
}  /* FreeScuChargeableSubscriber */




AsnLen
BEncServingPartiesInformationContent PARAMS ((b, v),
BUF_TYPE b _AND_
ServingPartiesInformation *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->networkList)))
    {
    BEncEocIfNec (b);
    itemLen = BEncNetworkListContent (b, (v->networkList));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 333);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->internetServiceProviderIdList)))
    {
    BEncEocIfNec (b);
    itemLen = BEncInternetServiceProviderIdListContent (b, (v->internetServiceProviderIdList));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 330);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->contentProviderIdList)))
    {
    BEncEocIfNec (b);
    itemLen = BEncContentProviderIdListContent (b, (v->contentProviderIdList));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 328);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->contentProviderName)))
    {
    itemLen = BEncContentProviderNameContent (b, (&v->contentProviderName));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 334);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncServingPartiesInformationContent */

void
BDecServingPartiesInformationContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ServingPartiesInformation *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 334)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 334))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecContentProviderNameContent (b, tagId1, elmtLen1, (&v->contentProviderName), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 328))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->contentProviderIdList) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->contentProviderIdList), env);
    BDecContentProviderIdListContent (b, tagId1, elmtLen1, (v->contentProviderIdList), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 330))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->internetServiceProviderIdList) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->internetServiceProviderIdList), env);
    BDecInternetServiceProviderIdListContent (b, tagId1, elmtLen1, (v->internetServiceProviderIdList), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 333))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->networkList) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->networkList), env);
    BDecNetworkListContent (b, tagId1, elmtLen1, (v->networkList), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -211);
    }


    if (!seqDone)
        longjmp (env, -212);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecServingPartiesInformationContent */

void
PrintServingPartiesInformation PARAMS ((f, v, indent),
FILE* f _AND_
ServingPartiesInformation *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (ASNOCTS_PRESENT ((&v->contentProviderName)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"contentProviderName ");
    PrintContentProviderName (f, (&v->contentProviderName), indent + stdIndentG);
    }
    if (NOT_NULL ((v->contentProviderIdList)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"contentProviderIdList ");
    PrintContentProviderIdList (f, (v->contentProviderIdList), indent + stdIndentG);
    }
    if (NOT_NULL ((v->internetServiceProviderIdList)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"internetServiceProviderIdList ");
    PrintInternetServiceProviderIdList (f, (v->internetServiceProviderIdList), indent + stdIndentG);
    }
    if (NOT_NULL ((v->networkList)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"networkList ");
    PrintNetworkList (f, (v->networkList), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintServingPartiesInformation */

void
FreeServingPartiesInformation PARAMS ((v),
ServingPartiesInformation *v)
{

    if (v == NULL)
        return;
    if (ASNOCTS_PRESENT ((&v->contentProviderName)))
    {
    FreeContentProviderName ((&v->contentProviderName));
    }

    if (NOT_NULL ((v->contentProviderIdList)))
    {
    FreeContentProviderIdList ((v->contentProviderIdList));
    Asn1Free ((v->contentProviderIdList));
    }

    if (NOT_NULL ((v->internetServiceProviderIdList)))
    {
    FreeInternetServiceProviderIdList ((v->internetServiceProviderIdList));
    Asn1Free ((v->internetServiceProviderIdList));
    }

    if (NOT_NULL ((v->networkList)))
    {
    FreeNetworkList ((v->networkList));
    Asn1Free ((v->networkList));
    }

}  /* FreeServingPartiesInformation */




AsnLen
BEncTaxationContent PARAMS ((b, v),
BUF_TYPE b _AND_
Taxation *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (ASNOCTS_PRESENT ((&v->taxIndicator)))
    {
    itemLen = BEncTaxIndicatorContent (b, (&v->taxIndicator));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 432);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->chargeType)))
    {
    itemLen = BEncChargeTypeContent (b, (&v->chargeType));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, PRIM, 71);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->taxRate)))
    {
    itemLen = BEncTaxRateContent (b, (&v->taxRate));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 215);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->taxType)))
    {
    itemLen = BEncTaxTypeContent (b, (&v->taxType));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 217);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->taxCode)))
    {
    itemLen = BEncTaxCodeContent (b, (v->taxCode));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 212);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncTaxationContent */

void
BDecTaxationContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
Taxation *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 212))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->taxCode) = (TaxCode*) Asn1Alloc (sizeof (TaxCode));
    CheckAsn1Alloc ((v->taxCode), env);
    BDecTaxCodeContent (b, tagId1, elmtLen1, (v->taxCode), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 217)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 217))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecTaxTypeContent (b, tagId1, elmtLen1, (&v->taxType), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 215)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 215))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecTaxRateContent (b, tagId1, elmtLen1, (&v->taxRate), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 71)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 71))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecChargeTypeContent (b, tagId1, elmtLen1, (&v->chargeType), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 432)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 432))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecTaxIndicatorContent (b, tagId1, elmtLen1, (&v->taxIndicator), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -213);
    }


    if (!seqDone)
        longjmp (env, -214);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecTaxationContent */

void
PrintTaxation PARAMS ((f, v, indent),
FILE* f _AND_
Taxation *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->taxCode)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"taxCode ");
    PrintTaxCode (f, (v->taxCode), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->taxType)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"taxType ");
    PrintTaxType (f, (&v->taxType), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->taxRate)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"taxRate ");
    PrintTaxRate (f, (&v->taxRate), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->chargeType)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"chargeType ");
    PrintChargeType (f, (&v->chargeType), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->taxIndicator)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"taxIndicator ");
    PrintTaxIndicator (f, (&v->taxIndicator), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintTaxation */

void
FreeTaxation PARAMS ((v),
Taxation *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->taxCode)))
    {
    FreeTaxCode ((v->taxCode));
    Asn1Free ((v->taxCode));
    }

    if (ASNOCTS_PRESENT ((&v->taxType)))
    {
    FreeTaxType ((&v->taxType));
    }

    if (ASNOCTS_PRESENT ((&v->taxRate)))
    {
    FreeTaxRate ((&v->taxRate));
    }

    if (ASNOCTS_PRESENT ((&v->chargeType)))
    {
    FreeChargeType ((&v->chargeType));
    }

    if (ASNOCTS_PRESENT ((&v->taxIndicator)))
    {
    FreeTaxIndicator ((&v->taxIndicator));
    }

}  /* FreeTaxation */




AsnLen
BEncTaxationListContent PARAMS ((b, v),
BUF_TYPE b _AND_
TaxationList *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    BEncEocIfNec (b);
    itemLen = BEncTaxationContent (b, component);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 216);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncTaxationListContent */

void
BDecTaxationListContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
TaxationList *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        Taxation **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (APPL, CONS, 216)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (Taxation**) AsnListAppend (v);
    (*tmpVar) = (Taxation*) Asn1Alloc (sizeof (Taxation));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecTaxationContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -215);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecTaxationListContent */

void
PrintTaxationList PARAMS ((f, v, indent),
FILE* f _AND_
TaxationList *v _AND_
unsigned short int indent)
{
    Taxation *tmp;
    if (v == NULL)
        return;
    fprintf (f,"{ -- SEQUENCE OF -- \n");
    FOR_EACH_LIST_ELMT (tmp, v)
    {
        Indent (f, indent+ stdIndentG);
        PrintTaxation (f, tmp, indent + stdIndentG);
        if (tmp != (Taxation*)LAST_LIST_ELMT (v))
            fprintf (f,",\n");
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintTaxationList */

void
FreeTaxationList PARAMS ((v),
TaxationList *v)
{

    AsnListNode *l;
    AsnListNode *tmp;
    if (v == NULL)
        return;
    for (l = FIRST_LIST_NODE (v); l != NULL; )
    {
        FreeTaxation ((l->data));
        tmp = l->next;
        Asn1Free (l->data);
        Asn1Free (l);
        l = tmp;
    }
}  /* FreeTaxationList */




AsnLen
BEncTaxInformationContent PARAMS ((b, v),
BUF_TYPE b _AND_
TaxInformation *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->taxableAmount)))
    {
    itemLen = BEncTaxableAmountContent (b, (v->taxableAmount));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 398);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->taxValue)))
    {
    itemLen = BEncTaxValueContent (b, (v->taxValue));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 397);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->taxCode)))
    {
    itemLen = BEncTaxCodeContent (b, (v->taxCode));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 212);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncTaxInformationContent */

void
BDecTaxInformationContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
TaxInformation *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 212))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->taxCode) = (TaxCode*) Asn1Alloc (sizeof (TaxCode));
    CheckAsn1Alloc ((v->taxCode), env);
    BDecTaxCodeContent (b, tagId1, elmtLen1, (v->taxCode), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 397))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->taxValue) = (TaxValue*) Asn1Alloc (sizeof (TaxValue));
    CheckAsn1Alloc ((v->taxValue), env);
    BDecTaxValueContent (b, tagId1, elmtLen1, (v->taxValue), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 398))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->taxableAmount) = (TaxableAmount*) Asn1Alloc (sizeof (TaxableAmount));
    CheckAsn1Alloc ((v->taxableAmount), env);
    BDecTaxableAmountContent (b, tagId1, elmtLen1, (v->taxableAmount), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -216);
    }


    if (!seqDone)
        longjmp (env, -217);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecTaxInformationContent */

void
PrintTaxInformation PARAMS ((f, v, indent),
FILE* f _AND_
TaxInformation *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->taxCode)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"taxCode ");
    PrintTaxCode (f, (v->taxCode), indent + stdIndentG);
    }
    if (NOT_NULL ((v->taxValue)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"taxValue ");
    PrintTaxValue (f, (v->taxValue), indent + stdIndentG);
    }
    if (NOT_NULL ((v->taxableAmount)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"taxableAmount ");
    PrintTaxableAmount (f, (v->taxableAmount), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintTaxInformation */

void
FreeTaxInformation PARAMS ((v),
TaxInformation *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->taxCode)))
    {
    FreeTaxCode ((v->taxCode));
    Asn1Free ((v->taxCode));
    }

    if (NOT_NULL ((v->taxValue)))
    {
    FreeTaxValue ((v->taxValue));
    Asn1Free ((v->taxValue));
    }

    if (NOT_NULL ((v->taxableAmount)))
    {
    FreeTaxableAmount ((v->taxableAmount));
    Asn1Free ((v->taxableAmount));
    }

}  /* FreeTaxInformation */




AsnLen
BEncTaxInformationListContent PARAMS ((b, v),
BUF_TYPE b _AND_
TaxInformationList *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    BEncEocIfNec (b);
    itemLen = BEncTaxInformationContent (b, component);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 213);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncTaxInformationListContent */

void
BDecTaxInformationListContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
TaxInformationList *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        TaxInformation **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (APPL, CONS, 213)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (TaxInformation**) AsnListAppend (v);
    (*tmpVar) = (TaxInformation*) Asn1Alloc (sizeof (TaxInformation));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecTaxInformationContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -218);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecTaxInformationListContent */

void
PrintTaxInformationList PARAMS ((f, v, indent),
FILE* f _AND_
TaxInformationList *v _AND_
unsigned short int indent)
{
    TaxInformation *tmp;
    if (v == NULL)
        return;
    fprintf (f,"{ -- SEQUENCE OF -- \n");
    FOR_EACH_LIST_ELMT (tmp, v)
    {
        Indent (f, indent+ stdIndentG);
        PrintTaxInformation (f, tmp, indent + stdIndentG);
        if (tmp != (TaxInformation*)LAST_LIST_ELMT (v))
            fprintf (f,",\n");
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintTaxInformationList */

void
FreeTaxInformationList PARAMS ((v),
TaxInformationList *v)
{

    AsnListNode *l;
    AsnListNode *tmp;
    if (v == NULL)
        return;
    for (l = FIRST_LIST_NODE (v); l != NULL; )
    {
        FreeTaxInformation ((l->data));
        tmp = l->next;
        Asn1Free (l->data);
        Asn1Free (l);
        l = tmp;
    }
}  /* FreeTaxInformationList */




AsnLen
BEncThirdPartyInformationContent PARAMS ((b, v),
BUF_TYPE b _AND_
ThirdPartyInformation *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->clirIndicator)))
    {
    itemLen = BEncClirIndicatorContent (b, (v->clirIndicator));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, APPL, PRIM, 75);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->thirdPartyNumber)))
    {
    itemLen = BEncThirdPartyNumberContent (b, (&v->thirdPartyNumber));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 403);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncThirdPartyInformationContent */

void
BDecThirdPartyInformationContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ThirdPartyInformation *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 403)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 403))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecThirdPartyNumberContent (b, tagId1, elmtLen1, (&v->thirdPartyNumber), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 75))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->clirIndicator) = (ClirIndicator*) Asn1Alloc (sizeof (ClirIndicator));
    CheckAsn1Alloc ((v->clirIndicator), env);
    BDecClirIndicatorContent (b, tagId1, elmtLen1, (v->clirIndicator), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -219);
    }


    if (!seqDone)
        longjmp (env, -220);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecThirdPartyInformationContent */

void
PrintThirdPartyInformation PARAMS ((f, v, indent),
FILE* f _AND_
ThirdPartyInformation *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (ASNOCTS_PRESENT ((&v->thirdPartyNumber)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"thirdPartyNumber ");
    PrintThirdPartyNumber (f, (&v->thirdPartyNumber), indent + stdIndentG);
    }
    if (NOT_NULL ((v->clirIndicator)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"clirIndicator ");
    PrintClirIndicator (f, (v->clirIndicator), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintThirdPartyInformation */

void
FreeThirdPartyInformation PARAMS ((v),
ThirdPartyInformation *v)
{

    if (v == NULL)
        return;
    if (ASNOCTS_PRESENT ((&v->thirdPartyNumber)))
    {
    FreeThirdPartyNumber ((&v->thirdPartyNumber));
    }

    if (NOT_NULL ((v->clirIndicator)))
    {
    FreeClirIndicator ((v->clirIndicator));
    Asn1Free ((v->clirIndicator));
    }

}  /* FreeThirdPartyInformation */




AsnLen
BEncTotalAdvisedChargeValueContent PARAMS ((b, v),
BUF_TYPE b _AND_
TotalAdvisedChargeValue *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->totalCommissionRefund)))
    {
    itemLen = BEncTotalCommissionRefundContent (b, (v->totalCommissionRefund));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 359);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->totalCommission)))
    {
    itemLen = BEncTotalCommissionContent (b, (v->totalCommission));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 358);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->totalAdvisedChargeRefund)))
    {
    itemLen = BEncTotalAdvisedChargeRefundContent (b, (v->totalAdvisedChargeRefund));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 357);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->totalAdvisedCharge)))
    {
    itemLen = BEncTotalAdvisedChargeContent (b, (v->totalAdvisedCharge));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 356);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->advisedChargeCurrency)))
    {
    itemLen = BEncAdvisedChargeCurrencyContent (b, (&v->advisedChargeCurrency));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 348);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncTotalAdvisedChargeValueContent */

void
BDecTotalAdvisedChargeValueContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
TotalAdvisedChargeValue *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 348)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 348))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecAdvisedChargeCurrencyContent (b, tagId1, elmtLen1, (&v->advisedChargeCurrency), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 356))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->totalAdvisedCharge) = (TotalAdvisedCharge*) Asn1Alloc (sizeof (TotalAdvisedCharge));
    CheckAsn1Alloc ((v->totalAdvisedCharge), env);
    BDecTotalAdvisedChargeContent (b, tagId1, elmtLen1, (v->totalAdvisedCharge), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 357))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->totalAdvisedChargeRefund) = (TotalAdvisedChargeRefund*) Asn1Alloc (sizeof (TotalAdvisedChargeRefund));
    CheckAsn1Alloc ((v->totalAdvisedChargeRefund), env);
    BDecTotalAdvisedChargeRefundContent (b, tagId1, elmtLen1, (v->totalAdvisedChargeRefund), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 358))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->totalCommission) = (TotalCommission*) Asn1Alloc (sizeof (TotalCommission));
    CheckAsn1Alloc ((v->totalCommission), env);
    BDecTotalCommissionContent (b, tagId1, elmtLen1, (v->totalCommission), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 359))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->totalCommissionRefund) = (TotalCommissionRefund*) Asn1Alloc (sizeof (TotalCommissionRefund));
    CheckAsn1Alloc ((v->totalCommissionRefund), env);
    BDecTotalCommissionRefundContent (b, tagId1, elmtLen1, (v->totalCommissionRefund), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -221);
    }


    if (!seqDone)
        longjmp (env, -222);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecTotalAdvisedChargeValueContent */

void
PrintTotalAdvisedChargeValue PARAMS ((f, v, indent),
FILE* f _AND_
TotalAdvisedChargeValue *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (ASNOCTS_PRESENT ((&v->advisedChargeCurrency)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"advisedChargeCurrency ");
    PrintAdvisedChargeCurrency (f, (&v->advisedChargeCurrency), indent + stdIndentG);
    }
    if (NOT_NULL ((v->totalAdvisedCharge)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"totalAdvisedCharge ");
    PrintTotalAdvisedCharge (f, (v->totalAdvisedCharge), indent + stdIndentG);
    }
    if (NOT_NULL ((v->totalAdvisedChargeRefund)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"totalAdvisedChargeRefund ");
    PrintTotalAdvisedChargeRefund (f, (v->totalAdvisedChargeRefund), indent + stdIndentG);
    }
    if (NOT_NULL ((v->totalCommission)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"totalCommission ");
    PrintTotalCommission (f, (v->totalCommission), indent + stdIndentG);
    }
    if (NOT_NULL ((v->totalCommissionRefund)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"totalCommissionRefund ");
    PrintTotalCommissionRefund (f, (v->totalCommissionRefund), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintTotalAdvisedChargeValue */

void
FreeTotalAdvisedChargeValue PARAMS ((v),
TotalAdvisedChargeValue *v)
{

    if (v == NULL)
        return;
    if (ASNOCTS_PRESENT ((&v->advisedChargeCurrency)))
    {
    FreeAdvisedChargeCurrency ((&v->advisedChargeCurrency));
    }

    if (NOT_NULL ((v->totalAdvisedCharge)))
    {
    FreeTotalAdvisedCharge ((v->totalAdvisedCharge));
    Asn1Free ((v->totalAdvisedCharge));
    }

    if (NOT_NULL ((v->totalAdvisedChargeRefund)))
    {
    FreeTotalAdvisedChargeRefund ((v->totalAdvisedChargeRefund));
    Asn1Free ((v->totalAdvisedChargeRefund));
    }

    if (NOT_NULL ((v->totalCommission)))
    {
    FreeTotalCommission ((v->totalCommission));
    Asn1Free ((v->totalCommission));
    }

    if (NOT_NULL ((v->totalCommissionRefund)))
    {
    FreeTotalCommissionRefund ((v->totalCommissionRefund));
    Asn1Free ((v->totalCommissionRefund));
    }

}  /* FreeTotalAdvisedChargeValue */




AsnLen
BEncTotalAdvisedChargeValueListContent PARAMS ((b, v),
BUF_TYPE b _AND_
TotalAdvisedChargeValueList *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    BEncEocIfNec (b);
    itemLen = BEncTotalAdvisedChargeValueContent (b, component);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 360);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncTotalAdvisedChargeValueListContent */

void
BDecTotalAdvisedChargeValueListContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
TotalAdvisedChargeValueList *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        TotalAdvisedChargeValue **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (APPL, CONS, 360)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (TotalAdvisedChargeValue**) AsnListAppend (v);
    (*tmpVar) = (TotalAdvisedChargeValue*) Asn1Alloc (sizeof (TotalAdvisedChargeValue));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecTotalAdvisedChargeValueContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -223);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecTotalAdvisedChargeValueListContent */

void
PrintTotalAdvisedChargeValueList PARAMS ((f, v, indent),
FILE* f _AND_
TotalAdvisedChargeValueList *v _AND_
unsigned short int indent)
{
    TotalAdvisedChargeValue *tmp;
    if (v == NULL)
        return;
    fprintf (f,"{ -- SEQUENCE OF -- \n");
    FOR_EACH_LIST_ELMT (tmp, v)
    {
        Indent (f, indent+ stdIndentG);
        PrintTotalAdvisedChargeValue (f, tmp, indent + stdIndentG);
        if (tmp != (TotalAdvisedChargeValue*)LAST_LIST_ELMT (v))
            fprintf (f,",\n");
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintTotalAdvisedChargeValueList */

void
FreeTotalAdvisedChargeValueList PARAMS ((v),
TotalAdvisedChargeValueList *v)
{

    AsnListNode *l;
    AsnListNode *tmp;
    if (v == NULL)
        return;
    for (l = FIRST_LIST_NODE (v); l != NULL; )
    {
        FreeTotalAdvisedChargeValue ((l->data));
        tmp = l->next;
        Asn1Free (l->data);
        Asn1Free (l);
        l = tmp;
    }
}  /* FreeTotalAdvisedChargeValueList */




AsnLen
BEncTrackedCustomerInformationContent PARAMS ((b, v),
BUF_TYPE b _AND_
TrackedCustomerInformation *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->trackedCustomerEquipment)))
    {
    BEncEocIfNec (b);
    itemLen = BEncTrackedCustomerEquipmentContent (b, (v->trackedCustomerEquipment));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 381);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->trackedCustomerLocList)))
    {
    BEncEocIfNec (b);
    itemLen = BEncTrackedCustomerLocListContent (b, (v->trackedCustomerLocList));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 379);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->trackedCustomerHomeIdList)))
    {
    BEncEocIfNec (b);
    itemLen = BEncTrackedCustomerHomeIdListContent (b, (v->trackedCustomerHomeIdList));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 376);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->trackedCustomerIdList)))
    {
    BEncEocIfNec (b);
    itemLen = BEncTrackedCustomerIdListContent (b, (v->trackedCustomerIdList));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 370);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncTrackedCustomerInformationContent */

void
BDecTrackedCustomerInformationContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
TrackedCustomerInformation *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 370))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->trackedCustomerIdList) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->trackedCustomerIdList), env);
    BDecTrackedCustomerIdListContent (b, tagId1, elmtLen1, (v->trackedCustomerIdList), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 376))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->trackedCustomerHomeIdList) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->trackedCustomerHomeIdList), env);
    BDecTrackedCustomerHomeIdListContent (b, tagId1, elmtLen1, (v->trackedCustomerHomeIdList), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 379))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->trackedCustomerLocList) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->trackedCustomerLocList), env);
    BDecTrackedCustomerLocListContent (b, tagId1, elmtLen1, (v->trackedCustomerLocList), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 381))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->trackedCustomerEquipment) = (TrackedCustomerEquipment*) Asn1Alloc (sizeof (TrackedCustomerEquipment));
    CheckAsn1Alloc ((v->trackedCustomerEquipment), env);
    BDecTrackedCustomerEquipmentContent (b, tagId1, elmtLen1, (v->trackedCustomerEquipment), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -224);
    }


    if (!seqDone)
        longjmp (env, -225);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecTrackedCustomerInformationContent */

void
PrintTrackedCustomerInformation PARAMS ((f, v, indent),
FILE* f _AND_
TrackedCustomerInformation *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->trackedCustomerIdList)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"trackedCustomerIdList ");
    PrintTrackedCustomerIdList (f, (v->trackedCustomerIdList), indent + stdIndentG);
    }
    if (NOT_NULL ((v->trackedCustomerHomeIdList)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"trackedCustomerHomeIdList ");
    PrintTrackedCustomerHomeIdList (f, (v->trackedCustomerHomeIdList), indent + stdIndentG);
    }
    if (NOT_NULL ((v->trackedCustomerLocList)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"trackedCustomerLocList ");
    PrintTrackedCustomerLocList (f, (v->trackedCustomerLocList), indent + stdIndentG);
    }
    if (NOT_NULL ((v->trackedCustomerEquipment)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"trackedCustomerEquipment ");
    PrintTrackedCustomerEquipment (f, (v->trackedCustomerEquipment), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintTrackedCustomerInformation */

void
FreeTrackedCustomerInformation PARAMS ((v),
TrackedCustomerInformation *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->trackedCustomerIdList)))
    {
    FreeTrackedCustomerIdList ((v->trackedCustomerIdList));
    Asn1Free ((v->trackedCustomerIdList));
    }

    if (NOT_NULL ((v->trackedCustomerHomeIdList)))
    {
    FreeTrackedCustomerHomeIdList ((v->trackedCustomerHomeIdList));
    Asn1Free ((v->trackedCustomerHomeIdList));
    }

    if (NOT_NULL ((v->trackedCustomerLocList)))
    {
    FreeTrackedCustomerLocList ((v->trackedCustomerLocList));
    Asn1Free ((v->trackedCustomerLocList));
    }

    if (NOT_NULL ((v->trackedCustomerEquipment)))
    {
    FreeTrackedCustomerEquipment ((v->trackedCustomerEquipment));
    Asn1Free ((v->trackedCustomerEquipment));
    }

}  /* FreeTrackedCustomerInformation */




AsnLen
BEncTrackingCustomerInformationContent PARAMS ((b, v),
BUF_TYPE b _AND_
TrackingCustomerInformation *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->trackingCustomerEquipment)))
    {
    BEncEocIfNec (b);
    itemLen = BEncTrackingCustomerEquipmentContent (b, (v->trackingCustomerEquipment));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 371);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->trackingCustomerLocList)))
    {
    BEncEocIfNec (b);
    itemLen = BEncTrackingCustomerLocListContent (b, (v->trackingCustomerLocList));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 368);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->trackingCustomerHomeIdList)))
    {
    BEncEocIfNec (b);
    itemLen = BEncTrackingCustomerHomeIdListContent (b, (v->trackingCustomerHomeIdList));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 365);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->trackingCustomerIdList)))
    {
    BEncEocIfNec (b);
    itemLen = BEncTrackingCustomerIdListContent (b, (v->trackingCustomerIdList));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 299);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncTrackingCustomerInformationContent */

void
BDecTrackingCustomerInformationContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
TrackingCustomerInformation *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 299))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->trackingCustomerIdList) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->trackingCustomerIdList), env);
    BDecTrackingCustomerIdListContent (b, tagId1, elmtLen1, (v->trackingCustomerIdList), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 365))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->trackingCustomerHomeIdList) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->trackingCustomerHomeIdList), env);
    BDecTrackingCustomerHomeIdListContent (b, tagId1, elmtLen1, (v->trackingCustomerHomeIdList), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 368))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->trackingCustomerLocList) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->trackingCustomerLocList), env);
    BDecTrackingCustomerLocListContent (b, tagId1, elmtLen1, (v->trackingCustomerLocList), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 371))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->trackingCustomerEquipment) = (TrackingCustomerEquipment*) Asn1Alloc (sizeof (TrackingCustomerEquipment));
    CheckAsn1Alloc ((v->trackingCustomerEquipment), env);
    BDecTrackingCustomerEquipmentContent (b, tagId1, elmtLen1, (v->trackingCustomerEquipment), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -226);
    }


    if (!seqDone)
        longjmp (env, -227);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecTrackingCustomerInformationContent */

void
PrintTrackingCustomerInformation PARAMS ((f, v, indent),
FILE* f _AND_
TrackingCustomerInformation *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->trackingCustomerIdList)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"trackingCustomerIdList ");
    PrintTrackingCustomerIdList (f, (v->trackingCustomerIdList), indent + stdIndentG);
    }
    if (NOT_NULL ((v->trackingCustomerHomeIdList)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"trackingCustomerHomeIdList ");
    PrintTrackingCustomerHomeIdList (f, (v->trackingCustomerHomeIdList), indent + stdIndentG);
    }
    if (NOT_NULL ((v->trackingCustomerLocList)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"trackingCustomerLocList ");
    PrintTrackingCustomerLocList (f, (v->trackingCustomerLocList), indent + stdIndentG);
    }
    if (NOT_NULL ((v->trackingCustomerEquipment)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"trackingCustomerEquipment ");
    PrintTrackingCustomerEquipment (f, (v->trackingCustomerEquipment), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintTrackingCustomerInformation */

void
FreeTrackingCustomerInformation PARAMS ((v),
TrackingCustomerInformation *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->trackingCustomerIdList)))
    {
    FreeTrackingCustomerIdList ((v->trackingCustomerIdList));
    Asn1Free ((v->trackingCustomerIdList));
    }

    if (NOT_NULL ((v->trackingCustomerHomeIdList)))
    {
    FreeTrackingCustomerHomeIdList ((v->trackingCustomerHomeIdList));
    Asn1Free ((v->trackingCustomerHomeIdList));
    }

    if (NOT_NULL ((v->trackingCustomerLocList)))
    {
    FreeTrackingCustomerLocList ((v->trackingCustomerLocList));
    Asn1Free ((v->trackingCustomerLocList));
    }

    if (NOT_NULL ((v->trackingCustomerEquipment)))
    {
    FreeTrackingCustomerEquipment ((v->trackingCustomerEquipment));
    Asn1Free ((v->trackingCustomerEquipment));
    }

}  /* FreeTrackingCustomerInformation */




AsnLen
BEncNotificationContent PARAMS ((b, v),
BUF_TYPE b _AND_
Notification *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->operatorSpecInformation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncOperatorSpecInfoListContent (b, (v->operatorSpecInformation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 162);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->fileTypeIndicator)))
    {
    itemLen = BEncFileTypeIndicatorContent (b, (&v->fileTypeIndicator));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, PRIM, 110);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->releaseVersionNumber)))
    {
    itemLen = BEncReleaseVersionNumberContent (b, (v->releaseVersionNumber));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 189);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->specificationVersionNumber)))
    {
    itemLen = BEncSpecificationVersionNumberContent (b, (v->specificationVersionNumber));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 201);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->transferCutOffTimeStamp)))
    {
    BEncEocIfNec (b);
    itemLen = BEncTransferCutOffTimeStampContent (b, (v->transferCutOffTimeStamp));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 227);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->fileAvailableTimeStamp)))
    {
    BEncEocIfNec (b);
    itemLen = BEncFileAvailableTimeStampContent (b, (v->fileAvailableTimeStamp));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 107);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->fileCreationTimeStamp)))
    {
    BEncEocIfNec (b);
    itemLen = BEncFileCreationTimeStampContent (b, (v->fileCreationTimeStamp));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 108);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->rapFileSequenceNumber)))
    {
    itemLen = BEncRapFileSequenceNumberContent (b, (&v->rapFileSequenceNumber));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 181);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->fileSequenceNumber)))
    {
    itemLen = BEncFileSequenceNumberContent (b, (&v->fileSequenceNumber));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, PRIM, 109);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->recipient)))
    {
    itemLen = BEncRecipientContent (b, (&v->recipient));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 182);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->sender)))
    {
    itemLen = BEncSenderContent (b, (&v->sender));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 196);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncNotificationContent */

void
BDecNotificationContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
Notification *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 196)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 196))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecSenderContent (b, tagId1, elmtLen1, (&v->sender), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 182)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 182))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecRecipientContent (b, tagId1, elmtLen1, (&v->recipient), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 109)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 109))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecFileSequenceNumberContent (b, tagId1, elmtLen1, (&v->fileSequenceNumber), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 181)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 181))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecRapFileSequenceNumberContent (b, tagId1, elmtLen1, (&v->rapFileSequenceNumber), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 108))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->fileCreationTimeStamp) = (FileCreationTimeStamp*) Asn1Alloc (sizeof (FileCreationTimeStamp));
    CheckAsn1Alloc ((v->fileCreationTimeStamp), env);
    BDecFileCreationTimeStampContent (b, tagId1, elmtLen1, (v->fileCreationTimeStamp), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 107))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->fileAvailableTimeStamp) = (FileAvailableTimeStamp*) Asn1Alloc (sizeof (FileAvailableTimeStamp));
    CheckAsn1Alloc ((v->fileAvailableTimeStamp), env);
    BDecFileAvailableTimeStampContent (b, tagId1, elmtLen1, (v->fileAvailableTimeStamp), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 227))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->transferCutOffTimeStamp) = (TransferCutOffTimeStamp*) Asn1Alloc (sizeof (TransferCutOffTimeStamp));
    CheckAsn1Alloc ((v->transferCutOffTimeStamp), env);
    BDecTransferCutOffTimeStampContent (b, tagId1, elmtLen1, (v->transferCutOffTimeStamp), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 201))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->specificationVersionNumber) = (SpecificationVersionNumber*) Asn1Alloc (sizeof (SpecificationVersionNumber));
    CheckAsn1Alloc ((v->specificationVersionNumber), env);
    BDecSpecificationVersionNumberContent (b, tagId1, elmtLen1, (v->specificationVersionNumber), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 189))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->releaseVersionNumber) = (ReleaseVersionNumber*) Asn1Alloc (sizeof (ReleaseVersionNumber));
    CheckAsn1Alloc ((v->releaseVersionNumber), env);
    BDecReleaseVersionNumberContent (b, tagId1, elmtLen1, (v->releaseVersionNumber), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 110)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 110))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecFileTypeIndicatorContent (b, tagId1, elmtLen1, (&v->fileTypeIndicator), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 162))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->operatorSpecInformation) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->operatorSpecInformation), env);
    BDecOperatorSpecInfoListContent (b, tagId1, elmtLen1, (v->operatorSpecInformation), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -228);
    }


    if (!seqDone)
        longjmp (env, -229);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecNotificationContent */

void
PrintNotification PARAMS ((f, v, indent),
FILE* f _AND_
Notification *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (ASNOCTS_PRESENT ((&v->sender)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"sender ");
    PrintSender (f, (&v->sender), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->recipient)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"recipient ");
    PrintRecipient (f, (&v->recipient), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->fileSequenceNumber)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"fileSequenceNumber ");
    PrintFileSequenceNumber (f, (&v->fileSequenceNumber), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->rapFileSequenceNumber)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"rapFileSequenceNumber ");
    PrintRapFileSequenceNumber (f, (&v->rapFileSequenceNumber), indent + stdIndentG);
    }
    if (NOT_NULL ((v->fileCreationTimeStamp)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"fileCreationTimeStamp ");
    PrintFileCreationTimeStamp (f, (v->fileCreationTimeStamp), indent + stdIndentG);
    }
    if (NOT_NULL ((v->fileAvailableTimeStamp)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"fileAvailableTimeStamp ");
    PrintFileAvailableTimeStamp (f, (v->fileAvailableTimeStamp), indent + stdIndentG);
    }
    if (NOT_NULL ((v->transferCutOffTimeStamp)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"transferCutOffTimeStamp ");
    PrintTransferCutOffTimeStamp (f, (v->transferCutOffTimeStamp), indent + stdIndentG);
    }
    if (NOT_NULL ((v->specificationVersionNumber)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"specificationVersionNumber ");
    PrintSpecificationVersionNumber (f, (v->specificationVersionNumber), indent + stdIndentG);
    }
    if (NOT_NULL ((v->releaseVersionNumber)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"releaseVersionNumber ");
    PrintReleaseVersionNumber (f, (v->releaseVersionNumber), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->fileTypeIndicator)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"fileTypeIndicator ");
    PrintFileTypeIndicator (f, (&v->fileTypeIndicator), indent + stdIndentG);
    }
    if (NOT_NULL ((v->operatorSpecInformation)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"operatorSpecInformation ");
    PrintOperatorSpecInfoList (f, (v->operatorSpecInformation), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintNotification */

void
FreeNotification PARAMS ((v),
Notification *v)
{

    if (v == NULL)
        return;
    if (ASNOCTS_PRESENT ((&v->sender)))
    {
    FreeSender ((&v->sender));
    }

    if (ASNOCTS_PRESENT ((&v->recipient)))
    {
    FreeRecipient ((&v->recipient));
    }

    if (ASNOCTS_PRESENT ((&v->fileSequenceNumber)))
    {
    FreeFileSequenceNumber ((&v->fileSequenceNumber));
    }

    if (ASNOCTS_PRESENT ((&v->rapFileSequenceNumber)))
    {
    FreeRapFileSequenceNumber ((&v->rapFileSequenceNumber));
    }

    if (NOT_NULL ((v->fileCreationTimeStamp)))
    {
    FreeFileCreationTimeStamp ((v->fileCreationTimeStamp));
    Asn1Free ((v->fileCreationTimeStamp));
    }

    if (NOT_NULL ((v->fileAvailableTimeStamp)))
    {
    FreeFileAvailableTimeStamp ((v->fileAvailableTimeStamp));
    Asn1Free ((v->fileAvailableTimeStamp));
    }

    if (NOT_NULL ((v->transferCutOffTimeStamp)))
    {
    FreeTransferCutOffTimeStamp ((v->transferCutOffTimeStamp));
    Asn1Free ((v->transferCutOffTimeStamp));
    }

    if (NOT_NULL ((v->specificationVersionNumber)))
    {
    FreeSpecificationVersionNumber ((v->specificationVersionNumber));
    Asn1Free ((v->specificationVersionNumber));
    }

    if (NOT_NULL ((v->releaseVersionNumber)))
    {
    FreeReleaseVersionNumber ((v->releaseVersionNumber));
    Asn1Free ((v->releaseVersionNumber));
    }

    if (ASNOCTS_PRESENT ((&v->fileTypeIndicator)))
    {
    FreeFileTypeIndicator ((&v->fileTypeIndicator));
    }

    if (NOT_NULL ((v->operatorSpecInformation)))
    {
    FreeOperatorSpecInfoList ((v->operatorSpecInformation));
    Asn1Free ((v->operatorSpecInformation));
    }

}  /* FreeNotification */




AsnLen
BEncBatchControlInfoContent PARAMS ((b, v),
BUF_TYPE b _AND_
BatchControlInfo *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->operatorSpecInformation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncOperatorSpecInfoListContent (b, (v->operatorSpecInformation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 162);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->rapFileSequenceNumber)))
    {
    itemLen = BEncRapFileSequenceNumberContent (b, (&v->rapFileSequenceNumber));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 181);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->fileTypeIndicator)))
    {
    itemLen = BEncFileTypeIndicatorContent (b, (&v->fileTypeIndicator));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, PRIM, 110);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->releaseVersionNumber)))
    {
    itemLen = BEncReleaseVersionNumberContent (b, (v->releaseVersionNumber));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 189);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->specificationVersionNumber)))
    {
    itemLen = BEncSpecificationVersionNumberContent (b, (v->specificationVersionNumber));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 201);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->fileAvailableTimeStamp)))
    {
    BEncEocIfNec (b);
    itemLen = BEncFileAvailableTimeStampContent (b, (v->fileAvailableTimeStamp));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 107);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->transferCutOffTimeStamp)))
    {
    BEncEocIfNec (b);
    itemLen = BEncTransferCutOffTimeStampContent (b, (v->transferCutOffTimeStamp));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 227);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->fileCreationTimeStamp)))
    {
    BEncEocIfNec (b);
    itemLen = BEncFileCreationTimeStampContent (b, (v->fileCreationTimeStamp));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 108);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->fileSequenceNumber)))
    {
    itemLen = BEncFileSequenceNumberContent (b, (&v->fileSequenceNumber));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, PRIM, 109);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->recipient)))
    {
    itemLen = BEncRecipientContent (b, (&v->recipient));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 182);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->sender)))
    {
    itemLen = BEncSenderContent (b, (&v->sender));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 196);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncBatchControlInfoContent */

void
BDecBatchControlInfoContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
BatchControlInfo *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 196)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 196))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecSenderContent (b, tagId1, elmtLen1, (&v->sender), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 182)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 182))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecRecipientContent (b, tagId1, elmtLen1, (&v->recipient), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 109)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 109))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecFileSequenceNumberContent (b, tagId1, elmtLen1, (&v->fileSequenceNumber), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 108))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->fileCreationTimeStamp) = (FileCreationTimeStamp*) Asn1Alloc (sizeof (FileCreationTimeStamp));
    CheckAsn1Alloc ((v->fileCreationTimeStamp), env);
    BDecFileCreationTimeStampContent (b, tagId1, elmtLen1, (v->fileCreationTimeStamp), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 227))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->transferCutOffTimeStamp) = (TransferCutOffTimeStamp*) Asn1Alloc (sizeof (TransferCutOffTimeStamp));
    CheckAsn1Alloc ((v->transferCutOffTimeStamp), env);
    BDecTransferCutOffTimeStampContent (b, tagId1, elmtLen1, (v->transferCutOffTimeStamp), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 107))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->fileAvailableTimeStamp) = (FileAvailableTimeStamp*) Asn1Alloc (sizeof (FileAvailableTimeStamp));
    CheckAsn1Alloc ((v->fileAvailableTimeStamp), env);
    BDecFileAvailableTimeStampContent (b, tagId1, elmtLen1, (v->fileAvailableTimeStamp), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 201))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->specificationVersionNumber) = (SpecificationVersionNumber*) Asn1Alloc (sizeof (SpecificationVersionNumber));
    CheckAsn1Alloc ((v->specificationVersionNumber), env);
    BDecSpecificationVersionNumberContent (b, tagId1, elmtLen1, (v->specificationVersionNumber), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 189))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->releaseVersionNumber) = (ReleaseVersionNumber*) Asn1Alloc (sizeof (ReleaseVersionNumber));
    CheckAsn1Alloc ((v->releaseVersionNumber), env);
    BDecReleaseVersionNumberContent (b, tagId1, elmtLen1, (v->releaseVersionNumber), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 110)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 110))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecFileTypeIndicatorContent (b, tagId1, elmtLen1, (&v->fileTypeIndicator), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 181)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 181))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecRapFileSequenceNumberContent (b, tagId1, elmtLen1, (&v->rapFileSequenceNumber), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 162))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->operatorSpecInformation) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->operatorSpecInformation), env);
    BDecOperatorSpecInfoListContent (b, tagId1, elmtLen1, (v->operatorSpecInformation), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -230);
    }


    if (!seqDone)
        longjmp (env, -231);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecBatchControlInfoContent */

void
PrintBatchControlInfo PARAMS ((f, v, indent),
FILE* f _AND_
BatchControlInfo *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (ASNOCTS_PRESENT ((&v->sender)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"sender ");
    PrintSender (f, (&v->sender), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->recipient)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"recipient ");
    PrintRecipient (f, (&v->recipient), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->fileSequenceNumber)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"fileSequenceNumber ");
    PrintFileSequenceNumber (f, (&v->fileSequenceNumber), indent + stdIndentG);
    }
    if (NOT_NULL ((v->fileCreationTimeStamp)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"fileCreationTimeStamp ");
    PrintFileCreationTimeStamp (f, (v->fileCreationTimeStamp), indent + stdIndentG);
    }
    if (NOT_NULL ((v->transferCutOffTimeStamp)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"transferCutOffTimeStamp ");
    PrintTransferCutOffTimeStamp (f, (v->transferCutOffTimeStamp), indent + stdIndentG);
    }
    if (NOT_NULL ((v->fileAvailableTimeStamp)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"fileAvailableTimeStamp ");
    PrintFileAvailableTimeStamp (f, (v->fileAvailableTimeStamp), indent + stdIndentG);
    }
    if (NOT_NULL ((v->specificationVersionNumber)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"specificationVersionNumber ");
    PrintSpecificationVersionNumber (f, (v->specificationVersionNumber), indent + stdIndentG);
    }
    if (NOT_NULL ((v->releaseVersionNumber)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"releaseVersionNumber ");
    PrintReleaseVersionNumber (f, (v->releaseVersionNumber), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->fileTypeIndicator)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"fileTypeIndicator ");
    PrintFileTypeIndicator (f, (&v->fileTypeIndicator), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->rapFileSequenceNumber)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"rapFileSequenceNumber ");
    PrintRapFileSequenceNumber (f, (&v->rapFileSequenceNumber), indent + stdIndentG);
    }
    if (NOT_NULL ((v->operatorSpecInformation)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"operatorSpecInformation ");
    PrintOperatorSpecInfoList (f, (v->operatorSpecInformation), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintBatchControlInfo */

void
FreeBatchControlInfo PARAMS ((v),
BatchControlInfo *v)
{

    if (v == NULL)
        return;
    if (ASNOCTS_PRESENT ((&v->sender)))
    {
    FreeSender ((&v->sender));
    }

    if (ASNOCTS_PRESENT ((&v->recipient)))
    {
    FreeRecipient ((&v->recipient));
    }

    if (ASNOCTS_PRESENT ((&v->fileSequenceNumber)))
    {
    FreeFileSequenceNumber ((&v->fileSequenceNumber));
    }

    if (NOT_NULL ((v->fileCreationTimeStamp)))
    {
    FreeFileCreationTimeStamp ((v->fileCreationTimeStamp));
    Asn1Free ((v->fileCreationTimeStamp));
    }

    if (NOT_NULL ((v->transferCutOffTimeStamp)))
    {
    FreeTransferCutOffTimeStamp ((v->transferCutOffTimeStamp));
    Asn1Free ((v->transferCutOffTimeStamp));
    }

    if (NOT_NULL ((v->fileAvailableTimeStamp)))
    {
    FreeFileAvailableTimeStamp ((v->fileAvailableTimeStamp));
    Asn1Free ((v->fileAvailableTimeStamp));
    }

    if (NOT_NULL ((v->specificationVersionNumber)))
    {
    FreeSpecificationVersionNumber ((v->specificationVersionNumber));
    Asn1Free ((v->specificationVersionNumber));
    }

    if (NOT_NULL ((v->releaseVersionNumber)))
    {
    FreeReleaseVersionNumber ((v->releaseVersionNumber));
    Asn1Free ((v->releaseVersionNumber));
    }

    if (ASNOCTS_PRESENT ((&v->fileTypeIndicator)))
    {
    FreeFileTypeIndicator ((&v->fileTypeIndicator));
    }

    if (ASNOCTS_PRESENT ((&v->rapFileSequenceNumber)))
    {
    FreeRapFileSequenceNumber ((&v->rapFileSequenceNumber));
    }

    if (NOT_NULL ((v->operatorSpecInformation)))
    {
    FreeOperatorSpecInfoList ((v->operatorSpecInformation));
    Asn1Free ((v->operatorSpecInformation));
    }

}  /* FreeBatchControlInfo */




AsnLen
BEncAccountingInfoContent PARAMS ((b, v),
BUF_TYPE b _AND_
AccountingInfo *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->tapDecimalPlaces)))
    {
    itemLen = BEncTapDecimalPlacesContent (b, (v->tapDecimalPlaces));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 244);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->currencyConversionInfo)))
    {
    BEncEocIfNec (b);
    itemLen = BEncCurrencyConversionListContent (b, (v->currencyConversionInfo));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 80);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->tapCurrency)))
    {
    itemLen = BEncTapCurrencyContent (b, (&v->tapCurrency));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 210);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->localCurrency)))
    {
    itemLen = BEncLocalCurrencyContent (b, (&v->localCurrency));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 135);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->discounting)))
    {
    BEncEocIfNec (b);
    itemLen = BEncDiscountingListContent (b, (v->discounting));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 95);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->taxation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncTaxationListContent (b, (v->taxation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 211);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncAccountingInfoContent */

void
BDecAccountingInfoContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
AccountingInfo *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 211))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->taxation) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->taxation), env);
    BDecTaxationListContent (b, tagId1, elmtLen1, (v->taxation), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 95))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->discounting) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->discounting), env);
    BDecDiscountingListContent (b, tagId1, elmtLen1, (v->discounting), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 135)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 135))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecLocalCurrencyContent (b, tagId1, elmtLen1, (&v->localCurrency), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 210)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 210))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecTapCurrencyContent (b, tagId1, elmtLen1, (&v->tapCurrency), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 80))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->currencyConversionInfo) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->currencyConversionInfo), env);
    BDecCurrencyConversionListContent (b, tagId1, elmtLen1, (v->currencyConversionInfo), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 244))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->tapDecimalPlaces) = (TapDecimalPlaces*) Asn1Alloc (sizeof (TapDecimalPlaces));
    CheckAsn1Alloc ((v->tapDecimalPlaces), env);
    BDecTapDecimalPlacesContent (b, tagId1, elmtLen1, (v->tapDecimalPlaces), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -232);
    }


    if (!seqDone)
        longjmp (env, -233);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecAccountingInfoContent */

void
PrintAccountingInfo PARAMS ((f, v, indent),
FILE* f _AND_
AccountingInfo *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->taxation)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"taxation ");
    PrintTaxationList (f, (v->taxation), indent + stdIndentG);
    }
    if (NOT_NULL ((v->discounting)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"discounting ");
    PrintDiscountingList (f, (v->discounting), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->localCurrency)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"localCurrency ");
    PrintLocalCurrency (f, (&v->localCurrency), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->tapCurrency)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"tapCurrency ");
    PrintTapCurrency (f, (&v->tapCurrency), indent + stdIndentG);
    }
    if (NOT_NULL ((v->currencyConversionInfo)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"currencyConversionInfo ");
    PrintCurrencyConversionList (f, (v->currencyConversionInfo), indent + stdIndentG);
    }
    if (NOT_NULL ((v->tapDecimalPlaces)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"tapDecimalPlaces ");
    PrintTapDecimalPlaces (f, (v->tapDecimalPlaces), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintAccountingInfo */

void
FreeAccountingInfo PARAMS ((v),
AccountingInfo *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->taxation)))
    {
    FreeTaxationList ((v->taxation));
    Asn1Free ((v->taxation));
    }

    if (NOT_NULL ((v->discounting)))
    {
    FreeDiscountingList ((v->discounting));
    Asn1Free ((v->discounting));
    }

    if (ASNOCTS_PRESENT ((&v->localCurrency)))
    {
    FreeLocalCurrency ((&v->localCurrency));
    }

    if (ASNOCTS_PRESENT ((&v->tapCurrency)))
    {
    FreeTapCurrency ((&v->tapCurrency));
    }

    if (NOT_NULL ((v->currencyConversionInfo)))
    {
    FreeCurrencyConversionList ((v->currencyConversionInfo));
    Asn1Free ((v->currencyConversionInfo));
    }

    if (NOT_NULL ((v->tapDecimalPlaces)))
    {
    FreeTapDecimalPlaces ((v->tapDecimalPlaces));
    Asn1Free ((v->tapDecimalPlaces));
    }

}  /* FreeAccountingInfo */




AsnLen
BEncNetworkInfoContent PARAMS ((b, v),
BUF_TYPE b _AND_
NetworkInfo *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->recEntityInfo)))
    {
    BEncEocIfNec (b);
    itemLen = BEncRecEntityInfoListContent (b, (v->recEntityInfo));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 188);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->utcTimeOffsetInfo)))
    {
    BEncEocIfNec (b);
    itemLen = BEncUtcTimeOffsetInfoListContent (b, (v->utcTimeOffsetInfo));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 234);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncNetworkInfoContent */

void
BDecNetworkInfoContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
NetworkInfo *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 234))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->utcTimeOffsetInfo) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->utcTimeOffsetInfo), env);
    BDecUtcTimeOffsetInfoListContent (b, tagId1, elmtLen1, (v->utcTimeOffsetInfo), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 188))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->recEntityInfo) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->recEntityInfo), env);
    BDecRecEntityInfoListContent (b, tagId1, elmtLen1, (v->recEntityInfo), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -234);
    }


    if (!seqDone)
        longjmp (env, -235);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecNetworkInfoContent */

void
PrintNetworkInfo PARAMS ((f, v, indent),
FILE* f _AND_
NetworkInfo *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->utcTimeOffsetInfo)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"utcTimeOffsetInfo ");
    PrintUtcTimeOffsetInfoList (f, (v->utcTimeOffsetInfo), indent + stdIndentG);
    }
    if (NOT_NULL ((v->recEntityInfo)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"recEntityInfo ");
    PrintRecEntityInfoList (f, (v->recEntityInfo), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintNetworkInfo */

void
FreeNetworkInfo PARAMS ((v),
NetworkInfo *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->utcTimeOffsetInfo)))
    {
    FreeUtcTimeOffsetInfoList ((v->utcTimeOffsetInfo));
    Asn1Free ((v->utcTimeOffsetInfo));
    }

    if (NOT_NULL ((v->recEntityInfo)))
    {
    FreeRecEntityInfoList ((v->recEntityInfo));
    Asn1Free ((v->recEntityInfo));
    }

}  /* FreeNetworkInfo */




AsnLen
BEncAuditControlInfoContent PARAMS ((b, v),
BUF_TYPE b _AND_
AuditControlInfo *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->operatorSpecInformation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncOperatorSpecInfoListContent (b, (v->operatorSpecInformation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 162);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->callEventDetailsCount)))
    {
    itemLen = BEncCallEventDetailsCountContent (b, (v->callEventDetailsCount));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, APPL, PRIM, 43);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->totalAdvisedChargeValueList)))
    {
    BEncEocIfNec (b);
    itemLen = BEncTotalAdvisedChargeValueListContent (b, (v->totalAdvisedChargeValueList));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 361);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->totalDiscountRefund)))
    {
    itemLen = BEncTotalDiscountRefundContent (b, (v->totalDiscountRefund));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 354);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->totalDiscountValue)))
    {
    itemLen = BEncTotalDiscountValueContent (b, (v->totalDiscountValue));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 225);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->totalTaxValue)))
    {
    itemLen = BEncTotalTaxValueContent (b, (v->totalTaxValue));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 226);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->totalTaxRefund)))
    {
    itemLen = BEncTotalTaxRefundContent (b, (v->totalTaxRefund));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 353);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->totalChargeRefund)))
    {
    itemLen = BEncTotalChargeRefundContent (b, (v->totalChargeRefund));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 355);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->totalCharge)))
    {
    itemLen = BEncTotalChargeContent (b, (v->totalCharge));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 415);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->latestCallTimeStamp)))
    {
    BEncEocIfNec (b);
    itemLen = BEncLatestCallTimeStampContent (b, (v->latestCallTimeStamp));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 133);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->earliestCallTimeStamp)))
    {
    BEncEocIfNec (b);
    itemLen = BEncEarliestCallTimeStampContent (b, (v->earliestCallTimeStamp));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 101);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncAuditControlInfoContent */

void
BDecAuditControlInfoContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
AuditControlInfo *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 101))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->earliestCallTimeStamp) = (EarliestCallTimeStamp*) Asn1Alloc (sizeof (EarliestCallTimeStamp));
    CheckAsn1Alloc ((v->earliestCallTimeStamp), env);
    BDecEarliestCallTimeStampContent (b, tagId1, elmtLen1, (v->earliestCallTimeStamp), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 133))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->latestCallTimeStamp) = (LatestCallTimeStamp*) Asn1Alloc (sizeof (LatestCallTimeStamp));
    CheckAsn1Alloc ((v->latestCallTimeStamp), env);
    BDecLatestCallTimeStampContent (b, tagId1, elmtLen1, (v->latestCallTimeStamp), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 415))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->totalCharge) = (TotalCharge*) Asn1Alloc (sizeof (TotalCharge));
    CheckAsn1Alloc ((v->totalCharge), env);
    BDecTotalChargeContent (b, tagId1, elmtLen1, (v->totalCharge), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 355))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->totalChargeRefund) = (TotalChargeRefund*) Asn1Alloc (sizeof (TotalChargeRefund));
    CheckAsn1Alloc ((v->totalChargeRefund), env);
    BDecTotalChargeRefundContent (b, tagId1, elmtLen1, (v->totalChargeRefund), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 353))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->totalTaxRefund) = (TotalTaxRefund*) Asn1Alloc (sizeof (TotalTaxRefund));
    CheckAsn1Alloc ((v->totalTaxRefund), env);
    BDecTotalTaxRefundContent (b, tagId1, elmtLen1, (v->totalTaxRefund), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 226))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->totalTaxValue) = (TotalTaxValue*) Asn1Alloc (sizeof (TotalTaxValue));
    CheckAsn1Alloc ((v->totalTaxValue), env);
    BDecTotalTaxValueContent (b, tagId1, elmtLen1, (v->totalTaxValue), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 225))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->totalDiscountValue) = (TotalDiscountValue*) Asn1Alloc (sizeof (TotalDiscountValue));
    CheckAsn1Alloc ((v->totalDiscountValue), env);
    BDecTotalDiscountValueContent (b, tagId1, elmtLen1, (v->totalDiscountValue), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 354))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->totalDiscountRefund) = (TotalDiscountRefund*) Asn1Alloc (sizeof (TotalDiscountRefund));
    CheckAsn1Alloc ((v->totalDiscountRefund), env);
    BDecTotalDiscountRefundContent (b, tagId1, elmtLen1, (v->totalDiscountRefund), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 361))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->totalAdvisedChargeValueList) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->totalAdvisedChargeValueList), env);
    BDecTotalAdvisedChargeValueListContent (b, tagId1, elmtLen1, (v->totalAdvisedChargeValueList), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 43))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->callEventDetailsCount) = (CallEventDetailsCount*) Asn1Alloc (sizeof (CallEventDetailsCount));
    CheckAsn1Alloc ((v->callEventDetailsCount), env);
    BDecCallEventDetailsCountContent (b, tagId1, elmtLen1, (v->callEventDetailsCount), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 162))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->operatorSpecInformation) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->operatorSpecInformation), env);
    BDecOperatorSpecInfoListContent (b, tagId1, elmtLen1, (v->operatorSpecInformation), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -236);
    }


    if (!seqDone)
        longjmp (env, -237);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecAuditControlInfoContent */

void
PrintAuditControlInfo PARAMS ((f, v, indent),
FILE* f _AND_
AuditControlInfo *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->earliestCallTimeStamp)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"earliestCallTimeStamp ");
    PrintEarliestCallTimeStamp (f, (v->earliestCallTimeStamp), indent + stdIndentG);
    }
    if (NOT_NULL ((v->latestCallTimeStamp)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"latestCallTimeStamp ");
    PrintLatestCallTimeStamp (f, (v->latestCallTimeStamp), indent + stdIndentG);
    }
    if (NOT_NULL ((v->totalCharge)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"totalCharge ");
    PrintTotalCharge (f, (v->totalCharge), indent + stdIndentG);
    }
    if (NOT_NULL ((v->totalChargeRefund)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"totalChargeRefund ");
    PrintTotalChargeRefund (f, (v->totalChargeRefund), indent + stdIndentG);
    }
    if (NOT_NULL ((v->totalTaxRefund)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"totalTaxRefund ");
    PrintTotalTaxRefund (f, (v->totalTaxRefund), indent + stdIndentG);
    }
    if (NOT_NULL ((v->totalTaxValue)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"totalTaxValue ");
    PrintTotalTaxValue (f, (v->totalTaxValue), indent + stdIndentG);
    }
    if (NOT_NULL ((v->totalDiscountValue)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"totalDiscountValue ");
    PrintTotalDiscountValue (f, (v->totalDiscountValue), indent + stdIndentG);
    }
    if (NOT_NULL ((v->totalDiscountRefund)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"totalDiscountRefund ");
    PrintTotalDiscountRefund (f, (v->totalDiscountRefund), indent + stdIndentG);
    }
    if (NOT_NULL ((v->totalAdvisedChargeValueList)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"totalAdvisedChargeValueList ");
    PrintTotalAdvisedChargeValueList (f, (v->totalAdvisedChargeValueList), indent + stdIndentG);
    }
    if (NOT_NULL ((v->callEventDetailsCount)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"callEventDetailsCount ");
    PrintCallEventDetailsCount (f, (v->callEventDetailsCount), indent + stdIndentG);
    }
    if (NOT_NULL ((v->operatorSpecInformation)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"operatorSpecInformation ");
    PrintOperatorSpecInfoList (f, (v->operatorSpecInformation), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintAuditControlInfo */

void
FreeAuditControlInfo PARAMS ((v),
AuditControlInfo *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->earliestCallTimeStamp)))
    {
    FreeEarliestCallTimeStamp ((v->earliestCallTimeStamp));
    Asn1Free ((v->earliestCallTimeStamp));
    }

    if (NOT_NULL ((v->latestCallTimeStamp)))
    {
    FreeLatestCallTimeStamp ((v->latestCallTimeStamp));
    Asn1Free ((v->latestCallTimeStamp));
    }

    if (NOT_NULL ((v->totalCharge)))
    {
    FreeTotalCharge ((v->totalCharge));
    Asn1Free ((v->totalCharge));
    }

    if (NOT_NULL ((v->totalChargeRefund)))
    {
    FreeTotalChargeRefund ((v->totalChargeRefund));
    Asn1Free ((v->totalChargeRefund));
    }

    if (NOT_NULL ((v->totalTaxRefund)))
    {
    FreeTotalTaxRefund ((v->totalTaxRefund));
    Asn1Free ((v->totalTaxRefund));
    }

    if (NOT_NULL ((v->totalTaxValue)))
    {
    FreeTotalTaxValue ((v->totalTaxValue));
    Asn1Free ((v->totalTaxValue));
    }

    if (NOT_NULL ((v->totalDiscountValue)))
    {
    FreeTotalDiscountValue ((v->totalDiscountValue));
    Asn1Free ((v->totalDiscountValue));
    }

    if (NOT_NULL ((v->totalDiscountRefund)))
    {
    FreeTotalDiscountRefund ((v->totalDiscountRefund));
    Asn1Free ((v->totalDiscountRefund));
    }

    if (NOT_NULL ((v->totalAdvisedChargeValueList)))
    {
    FreeTotalAdvisedChargeValueList ((v->totalAdvisedChargeValueList));
    Asn1Free ((v->totalAdvisedChargeValueList));
    }

    if (NOT_NULL ((v->callEventDetailsCount)))
    {
    FreeCallEventDetailsCount ((v->callEventDetailsCount));
    Asn1Free ((v->callEventDetailsCount));
    }

    if (NOT_NULL ((v->operatorSpecInformation)))
    {
    FreeOperatorSpecInfoList ((v->operatorSpecInformation));
    Asn1Free ((v->operatorSpecInformation));
    }

}  /* FreeAuditControlInfo */




AsnLen
BEncBasicServiceContent PARAMS ((b, v),
BUF_TYPE b _AND_
BasicService *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (ASNOCTS_PRESENT ((&v->maximumBitRate)))
    {
    itemLen = BEncMaximumBitRateContent (b, (&v->maximumBitRate));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 421);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->guaranteedBitRate)))
    {
    itemLen = BEncGuaranteedBitRateContent (b, (&v->guaranteedBitRate));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 420);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->userProtocolIndicator)))
    {
    itemLen = BEncUserProtocolIndicatorContent (b, (v->userProtocolIndicator));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 280);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->fnur)))
    {
    itemLen = BEncFnurContent (b, (v->fnur));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, APPL, PRIM, 111);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->transparencyIndicator)))
    {
    itemLen = BEncTransparencyIndicatorContent (b, (v->transparencyIndicator));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 228);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->serviceCode)))
    {
    BEncEocIfNec (b);
    itemLen = BEncBasicServiceCodeContent (b, (v->serviceCode));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 426);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncBasicServiceContent */

void
BDecBasicServiceContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
BasicService *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 426))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->serviceCode) = (BasicServiceCode*) Asn1Alloc (sizeof (BasicServiceCode));
    CheckAsn1Alloc ((v->serviceCode), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecBasicServiceCodeContent (b, tagId2, elmtLen2, (v->serviceCode), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    /*if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);*/
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 228))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->transparencyIndicator) = (TransparencyIndicator*) Asn1Alloc (sizeof (TransparencyIndicator));
    CheckAsn1Alloc ((v->transparencyIndicator), env);
    BDecTransparencyIndicatorContent (b, tagId1, elmtLen1, (v->transparencyIndicator), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 111))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->fnur) = (Fnur*) Asn1Alloc (sizeof (Fnur));
    CheckAsn1Alloc ((v->fnur), env);
    BDecFnurContent (b, tagId1, elmtLen1, (v->fnur), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 280))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->userProtocolIndicator) = (UserProtocolIndicator*) Asn1Alloc (sizeof (UserProtocolIndicator));
    CheckAsn1Alloc ((v->userProtocolIndicator), env);
    BDecUserProtocolIndicatorContent (b, tagId1, elmtLen1, (v->userProtocolIndicator), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 420)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 420))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecGuaranteedBitRateContent (b, tagId1, elmtLen1, (&v->guaranteedBitRate), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 421)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 421))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecMaximumBitRateContent (b, tagId1, elmtLen1, (&v->maximumBitRate), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -238);
    }


    if (!seqDone)
        longjmp (env, -239);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecBasicServiceContent */

void
PrintBasicService PARAMS ((f, v, indent),
FILE* f _AND_
BasicService *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->serviceCode)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"serviceCode ");
    PrintBasicServiceCode (f, (v->serviceCode), indent + stdIndentG);
    }
    if (NOT_NULL ((v->transparencyIndicator)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"transparencyIndicator ");
    PrintTransparencyIndicator (f, (v->transparencyIndicator), indent + stdIndentG);
    }
    if (NOT_NULL ((v->fnur)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"fnur ");
    PrintFnur (f, (v->fnur), indent + stdIndentG);
    }
    if (NOT_NULL ((v->userProtocolIndicator)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"userProtocolIndicator ");
    PrintUserProtocolIndicator (f, (v->userProtocolIndicator), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->guaranteedBitRate)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"guaranteedBitRate ");
    PrintGuaranteedBitRate (f, (&v->guaranteedBitRate), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->maximumBitRate)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"maximumBitRate ");
    PrintMaximumBitRate (f, (&v->maximumBitRate), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintBasicService */

void
FreeBasicService PARAMS ((v),
BasicService *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->serviceCode)))
    {
    FreeBasicServiceCode ((v->serviceCode));
    Asn1Free ((v->serviceCode));
    }

    if (NOT_NULL ((v->transparencyIndicator)))
    {
    FreeTransparencyIndicator ((v->transparencyIndicator));
    Asn1Free ((v->transparencyIndicator));
    }

    if (NOT_NULL ((v->fnur)))
    {
    FreeFnur ((v->fnur));
    Asn1Free ((v->fnur));
    }

    if (NOT_NULL ((v->userProtocolIndicator)))
    {
    FreeUserProtocolIndicator ((v->userProtocolIndicator));
    Asn1Free ((v->userProtocolIndicator));
    }

    if (ASNOCTS_PRESENT ((&v->guaranteedBitRate)))
    {
    FreeGuaranteedBitRate ((&v->guaranteedBitRate));
    }

    if (ASNOCTS_PRESENT ((&v->maximumBitRate)))
    {
    FreeMaximumBitRate ((&v->maximumBitRate));
    }

}  /* FreeBasicService */




AsnLen
BEncCamelServiceUsedContent PARAMS ((b, v),
BUF_TYPE b _AND_
CamelServiceUsed *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (ASNOCTS_PRESENT ((&v->cseInformation)))
    {
    itemLen = BEncCseInformationContent (b, (&v->cseInformation));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, PRIM, 79);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->threeGcamelDestination)))
    {
    BEncEocIfNec (b);
    itemLen = BEncThreeGcamelDestinationContent (b, (v->threeGcamelDestination));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 431);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->camelInvocationFee)))
    {
    itemLen = BEncCamelInvocationFeeContent (b, (v->camelInvocationFee));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 422);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->discountInformation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncDiscountInformationContent (b, (v->discountInformation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 96);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->taxInformation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncTaxInformationListContent (b, (v->taxInformation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 214);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->exchangeRateCode)))
    {
    itemLen = BEncExchangeRateCodeContent (b, (v->exchangeRateCode));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, APPL, PRIM, 105);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->defaultCallHandling)))
    {
    itemLen = BEncDefaultCallHandlingIndicatorContent (b, (v->defaultCallHandling));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, APPL, PRIM, 87);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->camelServiceKey)))
    {
    itemLen = BEncCamelServiceKeyContent (b, (v->camelServiceKey));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, APPL, PRIM, 55);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->camelServiceLevel)))
    {
    itemLen = BEncCamelServiceLevelContent (b, (v->camelServiceLevel));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, APPL, PRIM, 56);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncCamelServiceUsedContent */

void
BDecCamelServiceUsedContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
CamelServiceUsed *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 56))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->camelServiceLevel) = (CamelServiceLevel*) Asn1Alloc (sizeof (CamelServiceLevel));
    CheckAsn1Alloc ((v->camelServiceLevel), env);
    BDecCamelServiceLevelContent (b, tagId1, elmtLen1, (v->camelServiceLevel), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 55))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->camelServiceKey) = (CamelServiceKey*) Asn1Alloc (sizeof (CamelServiceKey));
    CheckAsn1Alloc ((v->camelServiceKey), env);
    BDecCamelServiceKeyContent (b, tagId1, elmtLen1, (v->camelServiceKey), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 87))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->defaultCallHandling) = (DefaultCallHandlingIndicator*) Asn1Alloc (sizeof (DefaultCallHandlingIndicator));
    CheckAsn1Alloc ((v->defaultCallHandling), env);
    BDecDefaultCallHandlingIndicatorContent (b, tagId1, elmtLen1, (v->defaultCallHandling), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 105))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->exchangeRateCode) = (ExchangeRateCode*) Asn1Alloc (sizeof (ExchangeRateCode));
    CheckAsn1Alloc ((v->exchangeRateCode), env);
    BDecExchangeRateCodeContent (b, tagId1, elmtLen1, (v->exchangeRateCode), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 214))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->taxInformation) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->taxInformation), env);
    BDecTaxInformationListContent (b, tagId1, elmtLen1, (v->taxInformation), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 96))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->discountInformation) = (DiscountInformation*) Asn1Alloc (sizeof (DiscountInformation));
    CheckAsn1Alloc ((v->discountInformation), env);
    BDecDiscountInformationContent (b, tagId1, elmtLen1, (v->discountInformation), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 422))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->camelInvocationFee) = (CamelInvocationFee*) Asn1Alloc (sizeof (CamelInvocationFee));
    CheckAsn1Alloc ((v->camelInvocationFee), env);
    BDecCamelInvocationFeeContent (b, tagId1, elmtLen1, (v->camelInvocationFee), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 431))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->threeGcamelDestination) = (ThreeGcamelDestination*) Asn1Alloc (sizeof (ThreeGcamelDestination));
    CheckAsn1Alloc ((v->threeGcamelDestination), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecThreeGcamelDestinationContent (b, tagId2, elmtLen2, (v->threeGcamelDestination), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    /*if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);*/
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 79)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 79))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecCseInformationContent (b, tagId1, elmtLen1, (&v->cseInformation), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -240);
    }


    if (!seqDone)
        longjmp (env, -241);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecCamelServiceUsedContent */

void
PrintCamelServiceUsed PARAMS ((f, v, indent),
FILE* f _AND_
CamelServiceUsed *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->camelServiceLevel)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"camelServiceLevel ");
    PrintCamelServiceLevel (f, (v->camelServiceLevel), indent + stdIndentG);
    }
    if (NOT_NULL ((v->camelServiceKey)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"camelServiceKey ");
    PrintCamelServiceKey (f, (v->camelServiceKey), indent + stdIndentG);
    }
    if (NOT_NULL ((v->defaultCallHandling)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"defaultCallHandling ");
    PrintDefaultCallHandlingIndicator (f, (v->defaultCallHandling), indent + stdIndentG);
    }
    if (NOT_NULL ((v->exchangeRateCode)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"exchangeRateCode ");
    PrintExchangeRateCode (f, (v->exchangeRateCode), indent + stdIndentG);
    }
    if (NOT_NULL ((v->taxInformation)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"taxInformation ");
    PrintTaxInformationList (f, (v->taxInformation), indent + stdIndentG);
    }
    if (NOT_NULL ((v->discountInformation)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"discountInformation ");
    PrintDiscountInformation (f, (v->discountInformation), indent + stdIndentG);
    }
    if (NOT_NULL ((v->camelInvocationFee)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"camelInvocationFee ");
    PrintCamelInvocationFee (f, (v->camelInvocationFee), indent + stdIndentG);
    }
    if (NOT_NULL ((v->threeGcamelDestination)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"threeGcamelDestination ");
    PrintThreeGcamelDestination (f, (v->threeGcamelDestination), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->cseInformation)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"cseInformation ");
    PrintCseInformation (f, (&v->cseInformation), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintCamelServiceUsed */

void
FreeCamelServiceUsed PARAMS ((v),
CamelServiceUsed *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->camelServiceLevel)))
    {
    FreeCamelServiceLevel ((v->camelServiceLevel));
    Asn1Free ((v->camelServiceLevel));
    }

    if (NOT_NULL ((v->camelServiceKey)))
    {
    FreeCamelServiceKey ((v->camelServiceKey));
    Asn1Free ((v->camelServiceKey));
    }

    if (NOT_NULL ((v->defaultCallHandling)))
    {
    FreeDefaultCallHandlingIndicator ((v->defaultCallHandling));
    Asn1Free ((v->defaultCallHandling));
    }

    if (NOT_NULL ((v->exchangeRateCode)))
    {
    FreeExchangeRateCode ((v->exchangeRateCode));
    Asn1Free ((v->exchangeRateCode));
    }

    if (NOT_NULL ((v->taxInformation)))
    {
    FreeTaxInformationList ((v->taxInformation));
    Asn1Free ((v->taxInformation));
    }

    if (NOT_NULL ((v->discountInformation)))
    {
    FreeDiscountInformation ((v->discountInformation));
    Asn1Free ((v->discountInformation));
    }

    if (NOT_NULL ((v->camelInvocationFee)))
    {
    FreeCamelInvocationFee ((v->camelInvocationFee));
    Asn1Free ((v->camelInvocationFee));
    }

    if (NOT_NULL ((v->threeGcamelDestination)))
    {
    FreeThreeGcamelDestination ((v->threeGcamelDestination));
    Asn1Free ((v->threeGcamelDestination));
    }

    if (ASNOCTS_PRESENT ((&v->cseInformation)))
    {
    FreeCseInformation ((&v->cseInformation));
    }

}  /* FreeCamelServiceUsed */




AsnLen
BEncChargedPartyContent PARAMS ((b, v),
BUF_TYPE b _AND_
ChargedParty *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (ASNOCTS_PRESENT ((&v->imei)))
    {
    itemLen = BEncImeiContent (b, (&v->imei));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 128);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->homeLocationDescription)))
    {
    itemLen = BEncHomeLocationDescriptionContent (b, (&v->homeLocationDescription));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 413);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->homeBid)))
    {
    itemLen = BEncHomeBidContent (b, (&v->homeBid));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, PRIM, 122);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->publicUserId)))
    {
    itemLen = BEncPublicUserIdContent (b, (&v->publicUserId));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 446);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->msisdn)))
    {
    itemLen = BEncMsisdnContent (b, (&v->msisdn));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 152);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->imsi)))
    {
    itemLen = BEncImsiContent (b, (&v->imsi));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 129);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncChargedPartyContent */

void
BDecChargedPartyContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ChargedParty *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 129)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 129))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecImsiContent (b, tagId1, elmtLen1, (&v->imsi), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 152)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 152))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecMsisdnContent (b, tagId1, elmtLen1, (&v->msisdn), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 446)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 446))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecPublicUserIdContent (b, tagId1, elmtLen1, (&v->publicUserId), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 122)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 122))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecHomeBidContent (b, tagId1, elmtLen1, (&v->homeBid), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 413)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 413))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecHomeLocationDescriptionContent (b, tagId1, elmtLen1, (&v->homeLocationDescription), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 128)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 128))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecImeiContent (b, tagId1, elmtLen1, (&v->imei), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -242);
    }


    if (!seqDone)
        longjmp (env, -243);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecChargedPartyContent */

void
PrintChargedParty PARAMS ((f, v, indent),
FILE* f _AND_
ChargedParty *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (ASNOCTS_PRESENT ((&v->imsi)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"imsi ");
    PrintImsi (f, (&v->imsi), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->msisdn)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"msisdn ");
    PrintMsisdn (f, (&v->msisdn), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->publicUserId)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"publicUserId ");
    PrintPublicUserId (f, (&v->publicUserId), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->homeBid)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"homeBid ");
    PrintHomeBid (f, (&v->homeBid), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->homeLocationDescription)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"homeLocationDescription ");
    PrintHomeLocationDescription (f, (&v->homeLocationDescription), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->imei)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"imei ");
    PrintImei (f, (&v->imei), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintChargedParty */

void
FreeChargedParty PARAMS ((v),
ChargedParty *v)
{

    if (v == NULL)
        return;
    if (ASNOCTS_PRESENT ((&v->imsi)))
    {
    FreeImsi ((&v->imsi));
    }

    if (ASNOCTS_PRESENT ((&v->msisdn)))
    {
    FreeMsisdn ((&v->msisdn));
    }

    if (ASNOCTS_PRESENT ((&v->publicUserId)))
    {
    FreePublicUserId ((&v->publicUserId));
    }

    if (ASNOCTS_PRESENT ((&v->homeBid)))
    {
    FreeHomeBid ((&v->homeBid));
    }

    if (ASNOCTS_PRESENT ((&v->homeLocationDescription)))
    {
    FreeHomeLocationDescription ((&v->homeLocationDescription));
    }

    if (ASNOCTS_PRESENT ((&v->imei)))
    {
    FreeImei ((&v->imei));
    }

}  /* FreeChargedParty */




AsnLen
BEncChargedPartyInformationContent PARAMS ((b, v),
BUF_TYPE b _AND_
ChargedPartyInformation *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->chargedPartyEquipment)))
    {
    BEncEocIfNec (b);
    itemLen = BEncChargedPartyEquipmentContent (b, (v->chargedPartyEquipment));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 323);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->chargedPartyLocationList)))
    {
    BEncEocIfNec (b);
    itemLen = BEncChargedPartyLocationListContent (b, (v->chargedPartyLocationList));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 321);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->chargedPartyHomeIdList)))
    {
    BEncEocIfNec (b);
    itemLen = BEncChargedPartyHomeIdListContent (b, (v->chargedPartyHomeIdList));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 314);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->chargedPartyIdList)))
    {
    BEncEocIfNec (b);
    itemLen = BEncChargedPartyIdListContent (b, (v->chargedPartyIdList));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 310);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncChargedPartyInformationContent */

void
BDecChargedPartyInformationContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ChargedPartyInformation *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 310))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->chargedPartyIdList) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->chargedPartyIdList), env);
    BDecChargedPartyIdListContent (b, tagId1, elmtLen1, (v->chargedPartyIdList), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 314))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->chargedPartyHomeIdList) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->chargedPartyHomeIdList), env);
    BDecChargedPartyHomeIdListContent (b, tagId1, elmtLen1, (v->chargedPartyHomeIdList), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 321))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->chargedPartyLocationList) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->chargedPartyLocationList), env);
    BDecChargedPartyLocationListContent (b, tagId1, elmtLen1, (v->chargedPartyLocationList), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 323))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->chargedPartyEquipment) = (ChargedPartyEquipment*) Asn1Alloc (sizeof (ChargedPartyEquipment));
    CheckAsn1Alloc ((v->chargedPartyEquipment), env);
    BDecChargedPartyEquipmentContent (b, tagId1, elmtLen1, (v->chargedPartyEquipment), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -244);
    }


    if (!seqDone)
        longjmp (env, -245);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecChargedPartyInformationContent */

void
PrintChargedPartyInformation PARAMS ((f, v, indent),
FILE* f _AND_
ChargedPartyInformation *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->chargedPartyIdList)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"chargedPartyIdList ");
    PrintChargedPartyIdList (f, (v->chargedPartyIdList), indent + stdIndentG);
    }
    if (NOT_NULL ((v->chargedPartyHomeIdList)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"chargedPartyHomeIdList ");
    PrintChargedPartyHomeIdList (f, (v->chargedPartyHomeIdList), indent + stdIndentG);
    }
    if (NOT_NULL ((v->chargedPartyLocationList)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"chargedPartyLocationList ");
    PrintChargedPartyLocationList (f, (v->chargedPartyLocationList), indent + stdIndentG);
    }
    if (NOT_NULL ((v->chargedPartyEquipment)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"chargedPartyEquipment ");
    PrintChargedPartyEquipment (f, (v->chargedPartyEquipment), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintChargedPartyInformation */

void
FreeChargedPartyInformation PARAMS ((v),
ChargedPartyInformation *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->chargedPartyIdList)))
    {
    FreeChargedPartyIdList ((v->chargedPartyIdList));
    Asn1Free ((v->chargedPartyIdList));
    }

    if (NOT_NULL ((v->chargedPartyHomeIdList)))
    {
    FreeChargedPartyHomeIdList ((v->chargedPartyHomeIdList));
    Asn1Free ((v->chargedPartyHomeIdList));
    }

    if (NOT_NULL ((v->chargedPartyLocationList)))
    {
    FreeChargedPartyLocationList ((v->chargedPartyLocationList));
    Asn1Free ((v->chargedPartyLocationList));
    }

    if (NOT_NULL ((v->chargedPartyEquipment)))
    {
    FreeChargedPartyEquipment ((v->chargedPartyEquipment));
    Asn1Free ((v->chargedPartyEquipment));
    }

}  /* FreeChargedPartyInformation */




AsnLen
BEncContentTransactionBasicInfoContent PARAMS ((b, v),
BUF_TYPE b _AND_
ContentTransactionBasicInfo *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->transactionStatus)))
    {
    itemLen = BEncTransactionStatusContent (b, (v->transactionStatus));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 303);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->totalTransactionDuration)))
    {
    itemLen = BEncTotalTransactionDurationContent (b, (v->totalTransactionDuration));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 416);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->actualDeliveryTimeStamp)))
    {
    BEncEocIfNec (b);
    itemLen = BEncActualDeliveryTimeStampContent (b, (v->actualDeliveryTimeStamp));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 302);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->requestedDeliveryTimeStamp)))
    {
    BEncEocIfNec (b);
    itemLen = BEncRequestedDeliveryTimeStampContent (b, (v->requestedDeliveryTimeStamp));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 301);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->orderPlacedTimeStamp)))
    {
    BEncEocIfNec (b);
    itemLen = BEncOrderPlacedTimeStampContent (b, (v->orderPlacedTimeStamp));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 300);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->rapFileSequenceNumber)))
    {
    itemLen = BEncRapFileSequenceNumberContent (b, (&v->rapFileSequenceNumber));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 181);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncContentTransactionBasicInfoContent */

void
BDecContentTransactionBasicInfoContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ContentTransactionBasicInfo *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 181)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 181))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecRapFileSequenceNumberContent (b, tagId1, elmtLen1, (&v->rapFileSequenceNumber), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 300))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->orderPlacedTimeStamp) = (OrderPlacedTimeStamp*) Asn1Alloc (sizeof (OrderPlacedTimeStamp));
    CheckAsn1Alloc ((v->orderPlacedTimeStamp), env);
    BDecOrderPlacedTimeStampContent (b, tagId1, elmtLen1, (v->orderPlacedTimeStamp), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 301))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->requestedDeliveryTimeStamp) = (RequestedDeliveryTimeStamp*) Asn1Alloc (sizeof (RequestedDeliveryTimeStamp));
    CheckAsn1Alloc ((v->requestedDeliveryTimeStamp), env);
    BDecRequestedDeliveryTimeStampContent (b, tagId1, elmtLen1, (v->requestedDeliveryTimeStamp), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 302))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->actualDeliveryTimeStamp) = (ActualDeliveryTimeStamp*) Asn1Alloc (sizeof (ActualDeliveryTimeStamp));
    CheckAsn1Alloc ((v->actualDeliveryTimeStamp), env);
    BDecActualDeliveryTimeStampContent (b, tagId1, elmtLen1, (v->actualDeliveryTimeStamp), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 416))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->totalTransactionDuration) = (TotalTransactionDuration*) Asn1Alloc (sizeof (TotalTransactionDuration));
    CheckAsn1Alloc ((v->totalTransactionDuration), env);
    BDecTotalTransactionDurationContent (b, tagId1, elmtLen1, (v->totalTransactionDuration), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 303))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->transactionStatus) = (TransactionStatus*) Asn1Alloc (sizeof (TransactionStatus));
    CheckAsn1Alloc ((v->transactionStatus), env);
    BDecTransactionStatusContent (b, tagId1, elmtLen1, (v->transactionStatus), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -246);
    }


    if (!seqDone)
        longjmp (env, -247);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecContentTransactionBasicInfoContent */

void
PrintContentTransactionBasicInfo PARAMS ((f, v, indent),
FILE* f _AND_
ContentTransactionBasicInfo *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (ASNOCTS_PRESENT ((&v->rapFileSequenceNumber)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"rapFileSequenceNumber ");
    PrintRapFileSequenceNumber (f, (&v->rapFileSequenceNumber), indent + stdIndentG);
    }
    if (NOT_NULL ((v->orderPlacedTimeStamp)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"orderPlacedTimeStamp ");
    PrintOrderPlacedTimeStamp (f, (v->orderPlacedTimeStamp), indent + stdIndentG);
    }
    if (NOT_NULL ((v->requestedDeliveryTimeStamp)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"requestedDeliveryTimeStamp ");
    PrintRequestedDeliveryTimeStamp (f, (v->requestedDeliveryTimeStamp), indent + stdIndentG);
    }
    if (NOT_NULL ((v->actualDeliveryTimeStamp)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"actualDeliveryTimeStamp ");
    PrintActualDeliveryTimeStamp (f, (v->actualDeliveryTimeStamp), indent + stdIndentG);
    }
    if (NOT_NULL ((v->totalTransactionDuration)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"totalTransactionDuration ");
    PrintTotalTransactionDuration (f, (v->totalTransactionDuration), indent + stdIndentG);
    }
    if (NOT_NULL ((v->transactionStatus)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"transactionStatus ");
    PrintTransactionStatus (f, (v->transactionStatus), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintContentTransactionBasicInfo */

void
FreeContentTransactionBasicInfo PARAMS ((v),
ContentTransactionBasicInfo *v)
{

    if (v == NULL)
        return;
    if (ASNOCTS_PRESENT ((&v->rapFileSequenceNumber)))
    {
    FreeRapFileSequenceNumber ((&v->rapFileSequenceNumber));
    }

    if (NOT_NULL ((v->orderPlacedTimeStamp)))
    {
    FreeOrderPlacedTimeStamp ((v->orderPlacedTimeStamp));
    Asn1Free ((v->orderPlacedTimeStamp));
    }

    if (NOT_NULL ((v->requestedDeliveryTimeStamp)))
    {
    FreeRequestedDeliveryTimeStamp ((v->requestedDeliveryTimeStamp));
    Asn1Free ((v->requestedDeliveryTimeStamp));
    }

    if (NOT_NULL ((v->actualDeliveryTimeStamp)))
    {
    FreeActualDeliveryTimeStamp ((v->actualDeliveryTimeStamp));
    Asn1Free ((v->actualDeliveryTimeStamp));
    }

    if (NOT_NULL ((v->totalTransactionDuration)))
    {
    FreeTotalTransactionDuration ((v->totalTransactionDuration));
    Asn1Free ((v->totalTransactionDuration));
    }

    if (NOT_NULL ((v->transactionStatus)))
    {
    FreeTransactionStatus ((v->transactionStatus));
    Asn1Free ((v->transactionStatus));
    }

}  /* FreeContentTransactionBasicInfo */




AsnLen
BEncGeographicalLocationContent PARAMS ((b, v),
BUF_TYPE b _AND_
GeographicalLocation *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (ASNOCTS_PRESENT ((&v->servingLocationDescription)))
    {
    itemLen = BEncServingLocationDescriptionContent (b, (&v->servingLocationDescription));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 414);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->servingBid)))
    {
    itemLen = BEncServingBidContent (b, (&v->servingBid));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 198);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->servingNetwork)))
    {
    itemLen = BEncServingNetworkContent (b, (&v->servingNetwork));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 195);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncGeographicalLocationContent */

void
BDecGeographicalLocationContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GeographicalLocation *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 195)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 195))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecServingNetworkContent (b, tagId1, elmtLen1, (&v->servingNetwork), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 198)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 198))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecServingBidContent (b, tagId1, elmtLen1, (&v->servingBid), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 414)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 414))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecServingLocationDescriptionContent (b, tagId1, elmtLen1, (&v->servingLocationDescription), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -248);
    }


    if (!seqDone)
        longjmp (env, -249);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGeographicalLocationContent */

void
PrintGeographicalLocation PARAMS ((f, v, indent),
FILE* f _AND_
GeographicalLocation *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (ASNOCTS_PRESENT ((&v->servingNetwork)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"servingNetwork ");
    PrintServingNetwork (f, (&v->servingNetwork), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->servingBid)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"servingBid ");
    PrintServingBid (f, (&v->servingBid), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->servingLocationDescription)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"servingLocationDescription ");
    PrintServingLocationDescription (f, (&v->servingLocationDescription), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintGeographicalLocation */

void
FreeGeographicalLocation PARAMS ((v),
GeographicalLocation *v)
{

    if (v == NULL)
        return;
    if (ASNOCTS_PRESENT ((&v->servingNetwork)))
    {
    FreeServingNetwork ((&v->servingNetwork));
    }

    if (ASNOCTS_PRESENT ((&v->servingBid)))
    {
    FreeServingBid ((&v->servingBid));
    }

    if (ASNOCTS_PRESENT ((&v->servingLocationDescription)))
    {
    FreeServingLocationDescription ((&v->servingLocationDescription));
    }

}  /* FreeGeographicalLocation */




AsnLen
BEncGprsBasicCallInformationContent PARAMS ((b, v),
BUF_TYPE b _AND_
GprsBasicCallInformation *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->chargingId)))
    {
    itemLen = BEncChargingIdContent (b, (v->chargingId));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, APPL, PRIM, 72);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->networkInitPDPContext)))
    {
    itemLen = BEncNetworkInitPDPContextContent (b, (v->networkInitPDPContext));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 245);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->pDPContextStartTimestamp)))
    {
    BEncEocIfNec (b);
    itemLen = BEncPDPContextStartTimestampContent (b, (v->pDPContextStartTimestamp));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 260);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->partialTypeIndicator)))
    {
    itemLen = BEncPartialTypeIndicatorContent (b, (&v->partialTypeIndicator));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 166);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->causeForTerm)))
    {
    itemLen = BEncCauseForTermContent (b, (v->causeForTerm));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, APPL, PRIM, 58);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->totalCallEventDuration)))
    {
    itemLen = BEncTotalCallEventDurationContent (b, (v->totalCallEventDuration));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 223);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->callEventStartTimeStamp)))
    {
    BEncEocIfNec (b);
    itemLen = BEncCallEventStartTimeStampContent (b, (v->callEventStartTimeStamp));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 44);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->gprsDestination)))
    {
    BEncEocIfNec (b);
    itemLen = BEncGprsDestinationContent (b, (v->gprsDestination));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 116);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->rapFileSequenceNumber)))
    {
    itemLen = BEncRapFileSequenceNumberContent (b, (&v->rapFileSequenceNumber));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 181);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->gprsChargeableSubscriber)))
    {
    BEncEocIfNec (b);
    itemLen = BEncGprsChargeableSubscriberContent (b, (v->gprsChargeableSubscriber));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 115);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncGprsBasicCallInformationContent */

void
BDecGprsBasicCallInformationContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GprsBasicCallInformation *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 115))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->gprsChargeableSubscriber) = (GprsChargeableSubscriber*) Asn1Alloc (sizeof (GprsChargeableSubscriber));
    CheckAsn1Alloc ((v->gprsChargeableSubscriber), env);
    BDecGprsChargeableSubscriberContent (b, tagId1, elmtLen1, (v->gprsChargeableSubscriber), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 181)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 181))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecRapFileSequenceNumberContent (b, tagId1, elmtLen1, (&v->rapFileSequenceNumber), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 116))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->gprsDestination) = (GprsDestination*) Asn1Alloc (sizeof (GprsDestination));
    CheckAsn1Alloc ((v->gprsDestination), env);
    BDecGprsDestinationContent (b, tagId1, elmtLen1, (v->gprsDestination), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 44))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->callEventStartTimeStamp) = (CallEventStartTimeStamp*) Asn1Alloc (sizeof (CallEventStartTimeStamp));
    CheckAsn1Alloc ((v->callEventStartTimeStamp), env);
    BDecCallEventStartTimeStampContent (b, tagId1, elmtLen1, (v->callEventStartTimeStamp), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 223))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->totalCallEventDuration) = (TotalCallEventDuration*) Asn1Alloc (sizeof (TotalCallEventDuration));
    CheckAsn1Alloc ((v->totalCallEventDuration), env);
    BDecTotalCallEventDurationContent (b, tagId1, elmtLen1, (v->totalCallEventDuration), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 58))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->causeForTerm) = (CauseForTerm*) Asn1Alloc (sizeof (CauseForTerm));
    CheckAsn1Alloc ((v->causeForTerm), env);
    BDecCauseForTermContent (b, tagId1, elmtLen1, (v->causeForTerm), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 166)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 166))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecPartialTypeIndicatorContent (b, tagId1, elmtLen1, (&v->partialTypeIndicator), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 260))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->pDPContextStartTimestamp) = (PDPContextStartTimestamp*) Asn1Alloc (sizeof (PDPContextStartTimestamp));
    CheckAsn1Alloc ((v->pDPContextStartTimestamp), env);
    BDecPDPContextStartTimestampContent (b, tagId1, elmtLen1, (v->pDPContextStartTimestamp), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 245))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->networkInitPDPContext) = (NetworkInitPDPContext*) Asn1Alloc (sizeof (NetworkInitPDPContext));
    CheckAsn1Alloc ((v->networkInitPDPContext), env);
    BDecNetworkInitPDPContextContent (b, tagId1, elmtLen1, (v->networkInitPDPContext), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 72))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->chargingId) = (ChargingId*) Asn1Alloc (sizeof (ChargingId));
    CheckAsn1Alloc ((v->chargingId), env);
    BDecChargingIdContent (b, tagId1, elmtLen1, (v->chargingId), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -250);   
    }


    if (!seqDone)
        longjmp (env, -251);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGprsBasicCallInformationContent */

void
PrintGprsBasicCallInformation PARAMS ((f, v, indent),
FILE* f _AND_
GprsBasicCallInformation *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->gprsChargeableSubscriber)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"gprsChargeableSubscriber ");
    PrintGprsChargeableSubscriber (f, (v->gprsChargeableSubscriber), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->rapFileSequenceNumber)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"rapFileSequenceNumber ");
    PrintRapFileSequenceNumber (f, (&v->rapFileSequenceNumber), indent + stdIndentG);
    }
    if (NOT_NULL ((v->gprsDestination)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"gprsDestination ");
    PrintGprsDestination (f, (v->gprsDestination), indent + stdIndentG);
    }
    if (NOT_NULL ((v->callEventStartTimeStamp)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"callEventStartTimeStamp ");
    PrintCallEventStartTimeStamp (f, (v->callEventStartTimeStamp), indent + stdIndentG);
    }
    if (NOT_NULL ((v->totalCallEventDuration)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"totalCallEventDuration ");
    PrintTotalCallEventDuration (f, (v->totalCallEventDuration), indent + stdIndentG);
    }
    if (NOT_NULL ((v->causeForTerm)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"causeForTerm ");
    PrintCauseForTerm (f, (v->causeForTerm), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->partialTypeIndicator)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"partialTypeIndicator ");
    PrintPartialTypeIndicator (f, (&v->partialTypeIndicator), indent + stdIndentG);
    }
    if (NOT_NULL ((v->pDPContextStartTimestamp)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"pDPContextStartTimestamp ");
    PrintPDPContextStartTimestamp (f, (v->pDPContextStartTimestamp), indent + stdIndentG);
    }
    if (NOT_NULL ((v->networkInitPDPContext)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"networkInitPDPContext ");
    PrintNetworkInitPDPContext (f, (v->networkInitPDPContext), indent + stdIndentG);
    }
    if (NOT_NULL ((v->chargingId)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"chargingId ");
    PrintChargingId (f, (v->chargingId), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintGprsBasicCallInformation */

void
FreeGprsBasicCallInformation PARAMS ((v),
GprsBasicCallInformation *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->gprsChargeableSubscriber)))
    {
    FreeGprsChargeableSubscriber ((v->gprsChargeableSubscriber));
    Asn1Free ((v->gprsChargeableSubscriber));
    }

    if (ASNOCTS_PRESENT ((&v->rapFileSequenceNumber)))
    {
    FreeRapFileSequenceNumber ((&v->rapFileSequenceNumber));
    }

    if (NOT_NULL ((v->gprsDestination)))
    {
    FreeGprsDestination ((v->gprsDestination));
    Asn1Free ((v->gprsDestination));
    }

    if (NOT_NULL ((v->callEventStartTimeStamp)))
    {
    FreeCallEventStartTimeStamp ((v->callEventStartTimeStamp));
    Asn1Free ((v->callEventStartTimeStamp));
    }

    if (NOT_NULL ((v->totalCallEventDuration)))
    {
    FreeTotalCallEventDuration ((v->totalCallEventDuration));
    Asn1Free ((v->totalCallEventDuration));
    }

    if (NOT_NULL ((v->causeForTerm)))
    {
    FreeCauseForTerm ((v->causeForTerm));
    Asn1Free ((v->causeForTerm));
    }

    if (ASNOCTS_PRESENT ((&v->partialTypeIndicator)))
    {
    FreePartialTypeIndicator ((&v->partialTypeIndicator));
    }

    if (NOT_NULL ((v->pDPContextStartTimestamp)))
    {
    FreePDPContextStartTimestamp ((v->pDPContextStartTimestamp));
    Asn1Free ((v->pDPContextStartTimestamp));
    }

    if (NOT_NULL ((v->networkInitPDPContext)))
    {
    FreeNetworkInitPDPContext ((v->networkInitPDPContext));
    Asn1Free ((v->networkInitPDPContext));
    }

    if (NOT_NULL ((v->chargingId)))
    {
    FreeChargingId ((v->chargingId));
    Asn1Free ((v->chargingId));
    }

}  /* FreeGprsBasicCallInformation */




AsnLen
BEncGprsLocationInformationContent PARAMS ((b, v),
BUF_TYPE b _AND_
GprsLocationInformation *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->geographicalLocation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncGeographicalLocationContent (b, (v->geographicalLocation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 113);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->homeLocationInformation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncHomeLocationInformationContent (b, (v->homeLocationInformation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 123);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->gprsNetworkLocation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncGprsNetworkLocationContent (b, (v->gprsNetworkLocation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 118);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncGprsLocationInformationContent */

void
BDecGprsLocationInformationContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GprsLocationInformation *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 118))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->gprsNetworkLocation) = (GprsNetworkLocation*) Asn1Alloc (sizeof (GprsNetworkLocation));
    CheckAsn1Alloc ((v->gprsNetworkLocation), env);
    BDecGprsNetworkLocationContent (b, tagId1, elmtLen1, (v->gprsNetworkLocation), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 123))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->homeLocationInformation) = (HomeLocationInformation*) Asn1Alloc (sizeof (HomeLocationInformation));
    CheckAsn1Alloc ((v->homeLocationInformation), env);
    BDecHomeLocationInformationContent (b, tagId1, elmtLen1, (v->homeLocationInformation), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 113))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->geographicalLocation) = (GeographicalLocation*) Asn1Alloc (sizeof (GeographicalLocation));
    CheckAsn1Alloc ((v->geographicalLocation), env);
    BDecGeographicalLocationContent (b, tagId1, elmtLen1, (v->geographicalLocation), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -252);
    }


    if (!seqDone)
        longjmp (env, -253);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGprsLocationInformationContent */

void
PrintGprsLocationInformation PARAMS ((f, v, indent),
FILE* f _AND_
GprsLocationInformation *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->gprsNetworkLocation)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"gprsNetworkLocation ");
    PrintGprsNetworkLocation (f, (v->gprsNetworkLocation), indent + stdIndentG);
    }
    if (NOT_NULL ((v->homeLocationInformation)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"homeLocationInformation ");
    PrintHomeLocationInformation (f, (v->homeLocationInformation), indent + stdIndentG);
    }
    if (NOT_NULL ((v->geographicalLocation)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"geographicalLocation ");
    PrintGeographicalLocation (f, (v->geographicalLocation), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintGprsLocationInformation */

void
FreeGprsLocationInformation PARAMS ((v),
GprsLocationInformation *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->gprsNetworkLocation)))
    {
    FreeGprsNetworkLocation ((v->gprsNetworkLocation));
    Asn1Free ((v->gprsNetworkLocation));
    }

    if (NOT_NULL ((v->homeLocationInformation)))
    {
    FreeHomeLocationInformation ((v->homeLocationInformation));
    Asn1Free ((v->homeLocationInformation));
    }

    if (NOT_NULL ((v->geographicalLocation)))
    {
    FreeGeographicalLocation ((v->geographicalLocation));
    Asn1Free ((v->geographicalLocation));
    }

}  /* FreeGprsLocationInformation */




AsnLen
BEncLCSQosRequestedContent PARAMS ((b, v),
BUF_TYPE b _AND_
LCSQosRequested *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->trackingFrequency)))
    {
    itemLen = BEncTrackingFrequencyContent (b, (v->trackingFrequency));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 389);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->trackingPeriod)))
    {
    itemLen = BEncTrackingPeriodContent (b, (v->trackingPeriod));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 388);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->responseTimeCategory)))
    {
    itemLen = BEncResponseTimeCategoryContent (b, (v->responseTimeCategory));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 387);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->verticalAccuracyRequested)))
    {
    itemLen = BEncVerticalAccuracyRequestedContent (b, (v->verticalAccuracyRequested));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 386);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->horizontalAccuracyRequested)))
    {
    itemLen = BEncHorizontalAccuracyRequestedContent (b, (v->horizontalAccuracyRequested));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 385);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->lCSRequestTimestamp)))
    {
    BEncEocIfNec (b);
    itemLen = BEncLCSRequestTimestampContent (b, (v->lCSRequestTimestamp));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 384);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncLCSQosRequestedContent */

void
BDecLCSQosRequestedContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
LCSQosRequested *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 384))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->lCSRequestTimestamp) = (LCSRequestTimestamp*) Asn1Alloc (sizeof (LCSRequestTimestamp));
    CheckAsn1Alloc ((v->lCSRequestTimestamp), env);
    BDecLCSRequestTimestampContent (b, tagId1, elmtLen1, (v->lCSRequestTimestamp), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 385))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->horizontalAccuracyRequested) = (HorizontalAccuracyRequested*) Asn1Alloc (sizeof (HorizontalAccuracyRequested));
    CheckAsn1Alloc ((v->horizontalAccuracyRequested), env);
    BDecHorizontalAccuracyRequestedContent (b, tagId1, elmtLen1, (v->horizontalAccuracyRequested), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 386))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->verticalAccuracyRequested) = (VerticalAccuracyRequested*) Asn1Alloc (sizeof (VerticalAccuracyRequested));
    CheckAsn1Alloc ((v->verticalAccuracyRequested), env);
    BDecVerticalAccuracyRequestedContent (b, tagId1, elmtLen1, (v->verticalAccuracyRequested), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 387))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->responseTimeCategory) = (ResponseTimeCategory*) Asn1Alloc (sizeof (ResponseTimeCategory));
    CheckAsn1Alloc ((v->responseTimeCategory), env);
    BDecResponseTimeCategoryContent (b, tagId1, elmtLen1, (v->responseTimeCategory), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 388))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->trackingPeriod) = (TrackingPeriod*) Asn1Alloc (sizeof (TrackingPeriod));
    CheckAsn1Alloc ((v->trackingPeriod), env);
    BDecTrackingPeriodContent (b, tagId1, elmtLen1, (v->trackingPeriod), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 389))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->trackingFrequency) = (TrackingFrequency*) Asn1Alloc (sizeof (TrackingFrequency));
    CheckAsn1Alloc ((v->trackingFrequency), env);
    BDecTrackingFrequencyContent (b, tagId1, elmtLen1, (v->trackingFrequency), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -254);
    }


    if (!seqDone)
        longjmp (env, -255);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecLCSQosRequestedContent */

void
PrintLCSQosRequested PARAMS ((f, v, indent),
FILE* f _AND_
LCSQosRequested *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->lCSRequestTimestamp)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"lCSRequestTimestamp ");
    PrintLCSRequestTimestamp (f, (v->lCSRequestTimestamp), indent + stdIndentG);
    }
    if (NOT_NULL ((v->horizontalAccuracyRequested)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"horizontalAccuracyRequested ");
    PrintHorizontalAccuracyRequested (f, (v->horizontalAccuracyRequested), indent + stdIndentG);
    }
    if (NOT_NULL ((v->verticalAccuracyRequested)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"verticalAccuracyRequested ");
    PrintVerticalAccuracyRequested (f, (v->verticalAccuracyRequested), indent + stdIndentG);
    }
    if (NOT_NULL ((v->responseTimeCategory)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"responseTimeCategory ");
    PrintResponseTimeCategory (f, (v->responseTimeCategory), indent + stdIndentG);
    }
    if (NOT_NULL ((v->trackingPeriod)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"trackingPeriod ");
    PrintTrackingPeriod (f, (v->trackingPeriod), indent + stdIndentG);
    }
    if (NOT_NULL ((v->trackingFrequency)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"trackingFrequency ");
    PrintTrackingFrequency (f, (v->trackingFrequency), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintLCSQosRequested */

void
FreeLCSQosRequested PARAMS ((v),
LCSQosRequested *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->lCSRequestTimestamp)))
    {
    FreeLCSRequestTimestamp ((v->lCSRequestTimestamp));
    Asn1Free ((v->lCSRequestTimestamp));
    }

    if (NOT_NULL ((v->horizontalAccuracyRequested)))
    {
    FreeHorizontalAccuracyRequested ((v->horizontalAccuracyRequested));
    Asn1Free ((v->horizontalAccuracyRequested));
    }

    if (NOT_NULL ((v->verticalAccuracyRequested)))
    {
    FreeVerticalAccuracyRequested ((v->verticalAccuracyRequested));
    Asn1Free ((v->verticalAccuracyRequested));
    }

    if (NOT_NULL ((v->responseTimeCategory)))
    {
    FreeResponseTimeCategory ((v->responseTimeCategory));
    Asn1Free ((v->responseTimeCategory));
    }

    if (NOT_NULL ((v->trackingPeriod)))
    {
    FreeTrackingPeriod ((v->trackingPeriod));
    Asn1Free ((v->trackingPeriod));
    }

    if (NOT_NULL ((v->trackingFrequency)))
    {
    FreeTrackingFrequency ((v->trackingFrequency));
    Asn1Free ((v->trackingFrequency));
    }

}  /* FreeLCSQosRequested */




AsnLen
BEncLocationInformationContent PARAMS ((b, v),
BUF_TYPE b _AND_
LocationInformation *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->geographicalLocation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncGeographicalLocationContent (b, (v->geographicalLocation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 113);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->homeLocationInformation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncHomeLocationInformationContent (b, (v->homeLocationInformation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 123);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->networkLocation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncNetworkLocationContent (b, (v->networkLocation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 156);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncLocationInformationContent */

void
BDecLocationInformationContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
LocationInformation *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 156))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->networkLocation) = (NetworkLocation*) Asn1Alloc (sizeof (NetworkLocation));
    CheckAsn1Alloc ((v->networkLocation), env);
    BDecNetworkLocationContent (b, tagId1, elmtLen1, (v->networkLocation), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 123))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->homeLocationInformation) = (HomeLocationInformation*) Asn1Alloc (sizeof (HomeLocationInformation));
    CheckAsn1Alloc ((v->homeLocationInformation), env);
    BDecHomeLocationInformationContent (b, tagId1, elmtLen1, (v->homeLocationInformation), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 113))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->geographicalLocation) = (GeographicalLocation*) Asn1Alloc (sizeof (GeographicalLocation));
    CheckAsn1Alloc ((v->geographicalLocation), env);
    BDecGeographicalLocationContent (b, tagId1, elmtLen1, (v->geographicalLocation), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -256);
    }


    if (!seqDone)
        longjmp (env, -257);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecLocationInformationContent */

void
PrintLocationInformation PARAMS ((f, v, indent),
FILE* f _AND_
LocationInformation *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->networkLocation)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"networkLocation ");
    PrintNetworkLocation (f, (v->networkLocation), indent + stdIndentG);
    }
    if (NOT_NULL ((v->homeLocationInformation)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"homeLocationInformation ");
    PrintHomeLocationInformation (f, (v->homeLocationInformation), indent + stdIndentG);
    }
    if (NOT_NULL ((v->geographicalLocation)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"geographicalLocation ");
    PrintGeographicalLocation (f, (v->geographicalLocation), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintLocationInformation */

void
FreeLocationInformation PARAMS ((v),
LocationInformation *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->networkLocation)))
    {
    FreeNetworkLocation ((v->networkLocation));
    Asn1Free ((v->networkLocation));
    }

    if (NOT_NULL ((v->homeLocationInformation)))
    {
    FreeHomeLocationInformation ((v->homeLocationInformation));
    Asn1Free ((v->homeLocationInformation));
    }

    if (NOT_NULL ((v->geographicalLocation)))
    {
    FreeGeographicalLocation ((v->geographicalLocation));
    Asn1Free ((v->geographicalLocation));
    }

}  /* FreeLocationInformation */




AsnLen
BEncMoBasicCallInformationContent PARAMS ((b, v),
BUF_TYPE b _AND_
MoBasicCallInformation *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->causeForTerm)))
    {
    itemLen = BEncCauseForTermContent (b, (v->causeForTerm));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, APPL, PRIM, 58);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->simToolkitIndicator)))
    {
    itemLen = BEncSimToolkitIndicatorContent (b, (&v->simToolkitIndicator));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 200);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->totalCallEventDuration)))
    {
    itemLen = BEncTotalCallEventDurationContent (b, (v->totalCallEventDuration));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 223);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->callEventStartTimeStamp)))
    {
    BEncEocIfNec (b);
    itemLen = BEncCallEventStartTimeStampContent (b, (v->callEventStartTimeStamp));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 44);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->destinationNetwork)))
    {
    itemLen = BEncDestinationNetworkContent (b, (&v->destinationNetwork));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, PRIM, 90);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->destination)))
    {
    BEncEocIfNec (b);
    itemLen = BEncDestinationContent (b, (v->destination));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 89);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->rapFileSequenceNumber)))
    {
    itemLen = BEncRapFileSequenceNumberContent (b, (&v->rapFileSequenceNumber));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 181);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->chargeableSubscriber)))
    {
    BEncEocIfNec (b);
    itemLen = BEncChargeableSubscriberContent (b, (v->chargeableSubscriber));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 427);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncMoBasicCallInformationContent */

void
BDecMoBasicCallInformationContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
MoBasicCallInformation *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 427))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->chargeableSubscriber) = (ChargeableSubscriber*) Asn1Alloc (sizeof (ChargeableSubscriber));
    CheckAsn1Alloc ((v->chargeableSubscriber), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecChargeableSubscriberContent (b, tagId2, elmtLen2, (v->chargeableSubscriber), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    /*if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);*/
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 181)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 181))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecRapFileSequenceNumberContent (b, tagId1, elmtLen1, (&v->rapFileSequenceNumber), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 89))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->destination) = (Destination*) Asn1Alloc (sizeof (Destination));
    CheckAsn1Alloc ((v->destination), env);
    BDecDestinationContent (b, tagId1, elmtLen1, (v->destination), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 90)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 90))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecDestinationNetworkContent (b, tagId1, elmtLen1, (&v->destinationNetwork), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 44))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->callEventStartTimeStamp) = (CallEventStartTimeStamp*) Asn1Alloc (sizeof (CallEventStartTimeStamp));
    CheckAsn1Alloc ((v->callEventStartTimeStamp), env);
    BDecCallEventStartTimeStampContent (b, tagId1, elmtLen1, (v->callEventStartTimeStamp), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 223))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->totalCallEventDuration) = (TotalCallEventDuration*) Asn1Alloc (sizeof (TotalCallEventDuration));
    CheckAsn1Alloc ((v->totalCallEventDuration), env);
    BDecTotalCallEventDurationContent (b, tagId1, elmtLen1, (v->totalCallEventDuration), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 200)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 200))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecSimToolkitIndicatorContent (b, tagId1, elmtLen1, (&v->simToolkitIndicator), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 58))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->causeForTerm) = (CauseForTerm*) Asn1Alloc (sizeof (CauseForTerm));
    CheckAsn1Alloc ((v->causeForTerm), env);
    BDecCauseForTermContent (b, tagId1, elmtLen1, (v->causeForTerm), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -258);
    }


    if (!seqDone)
        longjmp (env, -259);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecMoBasicCallInformationContent */

void
PrintMoBasicCallInformation PARAMS ((f, v, indent),
FILE* f _AND_
MoBasicCallInformation *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->chargeableSubscriber)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"chargeableSubscriber ");
    PrintChargeableSubscriber (f, (v->chargeableSubscriber), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->rapFileSequenceNumber)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"rapFileSequenceNumber ");
    PrintRapFileSequenceNumber (f, (&v->rapFileSequenceNumber), indent + stdIndentG);
    }
    if (NOT_NULL ((v->destination)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"destination ");
    PrintDestination (f, (v->destination), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->destinationNetwork)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"destinationNetwork ");
    PrintDestinationNetwork (f, (&v->destinationNetwork), indent + stdIndentG);
    }
    if (NOT_NULL ((v->callEventStartTimeStamp)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"callEventStartTimeStamp ");
    PrintCallEventStartTimeStamp (f, (v->callEventStartTimeStamp), indent + stdIndentG);
    }
    if (NOT_NULL ((v->totalCallEventDuration)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"totalCallEventDuration ");
    PrintTotalCallEventDuration (f, (v->totalCallEventDuration), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->simToolkitIndicator)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"simToolkitIndicator ");
    PrintSimToolkitIndicator (f, (&v->simToolkitIndicator), indent + stdIndentG);
    }
    if (NOT_NULL ((v->causeForTerm)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"causeForTerm ");
    PrintCauseForTerm (f, (v->causeForTerm), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintMoBasicCallInformation */

void
FreeMoBasicCallInformation PARAMS ((v),
MoBasicCallInformation *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->chargeableSubscriber)))
    {
    FreeChargeableSubscriber ((v->chargeableSubscriber));
    Asn1Free ((v->chargeableSubscriber));
    }

    if (ASNOCTS_PRESENT ((&v->rapFileSequenceNumber)))
    {
    FreeRapFileSequenceNumber ((&v->rapFileSequenceNumber));
    }

    if (NOT_NULL ((v->destination)))
    {
    FreeDestination ((v->destination));
    Asn1Free ((v->destination));
    }

    if (ASNOCTS_PRESENT ((&v->destinationNetwork)))
    {
    FreeDestinationNetwork ((&v->destinationNetwork));
    }

    if (NOT_NULL ((v->callEventStartTimeStamp)))
    {
    FreeCallEventStartTimeStamp ((v->callEventStartTimeStamp));
    Asn1Free ((v->callEventStartTimeStamp));
    }

    if (NOT_NULL ((v->totalCallEventDuration)))
    {
    FreeTotalCallEventDuration ((v->totalCallEventDuration));
    Asn1Free ((v->totalCallEventDuration));
    }

    if (ASNOCTS_PRESENT ((&v->simToolkitIndicator)))
    {
    FreeSimToolkitIndicator ((&v->simToolkitIndicator));
    }

    if (NOT_NULL ((v->causeForTerm)))
    {
    FreeCauseForTerm ((v->causeForTerm));
    Asn1Free ((v->causeForTerm));
    }

}  /* FreeMoBasicCallInformation */




AsnLen
BEncMtBasicCallInformationContent PARAMS ((b, v),
BUF_TYPE b _AND_
MtBasicCallInformation *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->causeForTerm)))
    {
    itemLen = BEncCauseForTermContent (b, (v->causeForTerm));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, APPL, PRIM, 58);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->simToolkitIndicator)))
    {
    itemLen = BEncSimToolkitIndicatorContent (b, (&v->simToolkitIndicator));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 200);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->totalCallEventDuration)))
    {
    itemLen = BEncTotalCallEventDurationContent (b, (v->totalCallEventDuration));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 223);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->callEventStartTimeStamp)))
    {
    BEncEocIfNec (b);
    itemLen = BEncCallEventStartTimeStampContent (b, (v->callEventStartTimeStamp));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 44);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->originatingNetwork)))
    {
    itemLen = BEncOriginatingNetworkContent (b, (&v->originatingNetwork));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 164);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->callOriginator)))
    {
    BEncEocIfNec (b);
    itemLen = BEncCallOriginatorContent (b, (v->callOriginator));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 41);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->rapFileSequenceNumber)))
    {
    itemLen = BEncRapFileSequenceNumberContent (b, (&v->rapFileSequenceNumber));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 181);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->chargeableSubscriber)))
    {
    BEncEocIfNec (b);
    itemLen = BEncChargeableSubscriberContent (b, (v->chargeableSubscriber));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 427);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncMtBasicCallInformationContent */

void
BDecMtBasicCallInformationContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
MtBasicCallInformation *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 427))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->chargeableSubscriber) = (ChargeableSubscriber*) Asn1Alloc (sizeof (ChargeableSubscriber));
    CheckAsn1Alloc ((v->chargeableSubscriber), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecChargeableSubscriberContent (b, tagId2, elmtLen2, (v->chargeableSubscriber), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    /*if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);*/
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 181)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 181))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecRapFileSequenceNumberContent (b, tagId1, elmtLen1, (&v->rapFileSequenceNumber), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 41))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->callOriginator) = (CallOriginator*) Asn1Alloc (sizeof (CallOriginator));
    CheckAsn1Alloc ((v->callOriginator), env);
    BDecCallOriginatorContent (b, tagId1, elmtLen1, (v->callOriginator), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 164)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 164))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecOriginatingNetworkContent (b, tagId1, elmtLen1, (&v->originatingNetwork), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 44))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->callEventStartTimeStamp) = (CallEventStartTimeStamp*) Asn1Alloc (sizeof (CallEventStartTimeStamp));
    CheckAsn1Alloc ((v->callEventStartTimeStamp), env);
    BDecCallEventStartTimeStampContent (b, tagId1, elmtLen1, (v->callEventStartTimeStamp), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 223))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->totalCallEventDuration) = (TotalCallEventDuration*) Asn1Alloc (sizeof (TotalCallEventDuration));
    CheckAsn1Alloc ((v->totalCallEventDuration), env);
    BDecTotalCallEventDurationContent (b, tagId1, elmtLen1, (v->totalCallEventDuration), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 200)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 200))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecSimToolkitIndicatorContent (b, tagId1, elmtLen1, (&v->simToolkitIndicator), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 58))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->causeForTerm) = (CauseForTerm*) Asn1Alloc (sizeof (CauseForTerm));
    CheckAsn1Alloc ((v->causeForTerm), env);
    BDecCauseForTermContent (b, tagId1, elmtLen1, (v->causeForTerm), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -260);
    }


    if (!seqDone)
        longjmp (env, -261);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecMtBasicCallInformationContent */

void
PrintMtBasicCallInformation PARAMS ((f, v, indent),
FILE* f _AND_
MtBasicCallInformation *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->chargeableSubscriber)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"chargeableSubscriber ");
    PrintChargeableSubscriber (f, (v->chargeableSubscriber), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->rapFileSequenceNumber)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"rapFileSequenceNumber ");
    PrintRapFileSequenceNumber (f, (&v->rapFileSequenceNumber), indent + stdIndentG);
    }
    if (NOT_NULL ((v->callOriginator)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"callOriginator ");
    PrintCallOriginator (f, (v->callOriginator), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->originatingNetwork)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"originatingNetwork ");
    PrintOriginatingNetwork (f, (&v->originatingNetwork), indent + stdIndentG);
    }
    if (NOT_NULL ((v->callEventStartTimeStamp)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"callEventStartTimeStamp ");
    PrintCallEventStartTimeStamp (f, (v->callEventStartTimeStamp), indent + stdIndentG);
    }
    if (NOT_NULL ((v->totalCallEventDuration)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"totalCallEventDuration ");
    PrintTotalCallEventDuration (f, (v->totalCallEventDuration), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->simToolkitIndicator)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"simToolkitIndicator ");
    PrintSimToolkitIndicator (f, (&v->simToolkitIndicator), indent + stdIndentG);
    }
    if (NOT_NULL ((v->causeForTerm)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"causeForTerm ");
    PrintCauseForTerm (f, (v->causeForTerm), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintMtBasicCallInformation */

void
FreeMtBasicCallInformation PARAMS ((v),
MtBasicCallInformation *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->chargeableSubscriber)))
    {
    FreeChargeableSubscriber ((v->chargeableSubscriber));
    Asn1Free ((v->chargeableSubscriber));
    }

    if (ASNOCTS_PRESENT ((&v->rapFileSequenceNumber)))
    {
    FreeRapFileSequenceNumber ((&v->rapFileSequenceNumber));
    }

    if (NOT_NULL ((v->callOriginator)))
    {
    FreeCallOriginator ((v->callOriginator));
    Asn1Free ((v->callOriginator));
    }

    if (ASNOCTS_PRESENT ((&v->originatingNetwork)))
    {
    FreeOriginatingNetwork ((&v->originatingNetwork));
    }

    if (NOT_NULL ((v->callEventStartTimeStamp)))
    {
    FreeCallEventStartTimeStamp ((v->callEventStartTimeStamp));
    Asn1Free ((v->callEventStartTimeStamp));
    }

    if (NOT_NULL ((v->totalCallEventDuration)))
    {
    FreeTotalCallEventDuration ((v->totalCallEventDuration));
    Asn1Free ((v->totalCallEventDuration));
    }

    if (ASNOCTS_PRESENT ((&v->simToolkitIndicator)))
    {
    FreeSimToolkitIndicator ((&v->simToolkitIndicator));
    }

    if (NOT_NULL ((v->causeForTerm)))
    {
    FreeCauseForTerm ((v->causeForTerm));
    Asn1Free ((v->causeForTerm));
    }

}  /* FreeMtBasicCallInformation */




AsnLen
BEncScuBasicInformationContent PARAMS ((b, v),
BUF_TYPE b _AND_
ScuBasicInformation *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (ASNOCTS_PRESENT ((&v->destinationNetwork)))
    {
    itemLen = BEncDestinationNetworkContent (b, (&v->destinationNetwork));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, PRIM, 90);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->originatingNetwork)))
    {
    itemLen = BEncOriginatingNetworkContent (b, (&v->originatingNetwork));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 164);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->clirIndicator)))
    {
    itemLen = BEncClirIndicatorContent (b, (v->clirIndicator));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, APPL, PRIM, 75);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->nonChargedNumber)))
    {
    itemLen = BEncNonChargedNumberContent (b, (&v->nonChargedNumber));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 402);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->chargedPartyStatus)))
    {
    itemLen = BEncChargedPartyStatusContent (b, (v->chargedPartyStatus));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, APPL, PRIM, 67);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->chargeableSubscriber)))
    {
    BEncEocIfNec (b);
    itemLen = BEncScuChargeableSubscriberContent (b, (v->chargeableSubscriber));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 430);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncScuBasicInformationContent */

void
BDecScuBasicInformationContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ScuBasicInformation *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 430))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->chargeableSubscriber) = (ScuChargeableSubscriber*) Asn1Alloc (sizeof (ScuChargeableSubscriber));
    CheckAsn1Alloc ((v->chargeableSubscriber), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecScuChargeableSubscriberContent (b, tagId2, elmtLen2, (v->chargeableSubscriber), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    /*if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);*/
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 67))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->chargedPartyStatus) = (ChargedPartyStatus*) Asn1Alloc (sizeof (ChargedPartyStatus));
    CheckAsn1Alloc ((v->chargedPartyStatus), env);
    BDecChargedPartyStatusContent (b, tagId1, elmtLen1, (v->chargedPartyStatus), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 402)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 402))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecNonChargedNumberContent (b, tagId1, elmtLen1, (&v->nonChargedNumber), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 75))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->clirIndicator) = (ClirIndicator*) Asn1Alloc (sizeof (ClirIndicator));
    CheckAsn1Alloc ((v->clirIndicator), env);
    BDecClirIndicatorContent (b, tagId1, elmtLen1, (v->clirIndicator), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 164)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 164))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecOriginatingNetworkContent (b, tagId1, elmtLen1, (&v->originatingNetwork), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 90)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 90))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecDestinationNetworkContent (b, tagId1, elmtLen1, (&v->destinationNetwork), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -262);
    }


    if (!seqDone)
        longjmp (env, -263);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecScuBasicInformationContent */

void
PrintScuBasicInformation PARAMS ((f, v, indent),
FILE* f _AND_
ScuBasicInformation *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->chargeableSubscriber)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"chargeableSubscriber ");
    PrintScuChargeableSubscriber (f, (v->chargeableSubscriber), indent + stdIndentG);
    }
    if (NOT_NULL ((v->chargedPartyStatus)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"chargedPartyStatus ");
    PrintChargedPartyStatus (f, (v->chargedPartyStatus), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->nonChargedNumber)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"nonChargedNumber ");
    PrintNonChargedNumber (f, (&v->nonChargedNumber), indent + stdIndentG);
    }
    if (NOT_NULL ((v->clirIndicator)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"clirIndicator ");
    PrintClirIndicator (f, (v->clirIndicator), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->originatingNetwork)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"originatingNetwork ");
    PrintOriginatingNetwork (f, (&v->originatingNetwork), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->destinationNetwork)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"destinationNetwork ");
    PrintDestinationNetwork (f, (&v->destinationNetwork), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintScuBasicInformation */

void
FreeScuBasicInformation PARAMS ((v),
ScuBasicInformation *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->chargeableSubscriber)))
    {
    FreeScuChargeableSubscriber ((v->chargeableSubscriber));
    Asn1Free ((v->chargeableSubscriber));
    }

    if (NOT_NULL ((v->chargedPartyStatus)))
    {
    FreeChargedPartyStatus ((v->chargedPartyStatus));
    Asn1Free ((v->chargedPartyStatus));
    }

    if (ASNOCTS_PRESENT ((&v->nonChargedNumber)))
    {
    FreeNonChargedNumber ((&v->nonChargedNumber));
    }

    if (NOT_NULL ((v->clirIndicator)))
    {
    FreeClirIndicator ((v->clirIndicator));
    Asn1Free ((v->clirIndicator));
    }

    if (ASNOCTS_PRESENT ((&v->originatingNetwork)))
    {
    FreeOriginatingNetwork ((&v->originatingNetwork));
    }

    if (ASNOCTS_PRESENT ((&v->destinationNetwork)))
    {
    FreeDestinationNetwork ((&v->destinationNetwork));
    }

}  /* FreeScuBasicInformation */




AsnLen
BEncScuTimeStampsContent PARAMS ((b, v),
BUF_TYPE b _AND_
ScuTimeStamps *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (ASNOCTS_PRESENT ((&v->chargingPoint)))
    {
    itemLen = BEncChargingPointContent (b, (&v->chargingPoint));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, PRIM, 73);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->completionTimeStamp)))
    {
    BEncEocIfNec (b);
    itemLen = BEncCompletionTimeStampContent (b, (v->completionTimeStamp));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 76);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->depositTimeStamp)))
    {
    BEncEocIfNec (b);
    itemLen = BEncDepositTimeStampContent (b, (v->depositTimeStamp));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 88);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncScuTimeStampsContent */

void
BDecScuTimeStampsContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ScuTimeStamps *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 88))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->depositTimeStamp) = (DepositTimeStamp*) Asn1Alloc (sizeof (DepositTimeStamp));
    CheckAsn1Alloc ((v->depositTimeStamp), env);
    BDecDepositTimeStampContent (b, tagId1, elmtLen1, (v->depositTimeStamp), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 76))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->completionTimeStamp) = (CompletionTimeStamp*) Asn1Alloc (sizeof (CompletionTimeStamp));
    CheckAsn1Alloc ((v->completionTimeStamp), env);
    BDecCompletionTimeStampContent (b, tagId1, elmtLen1, (v->completionTimeStamp), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 73)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 73))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecChargingPointContent (b, tagId1, elmtLen1, (&v->chargingPoint), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -264);
    }


    if (!seqDone)
        longjmp (env, -265);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecScuTimeStampsContent */

void
PrintScuTimeStamps PARAMS ((f, v, indent),
FILE* f _AND_
ScuTimeStamps *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->depositTimeStamp)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"depositTimeStamp ");
    PrintDepositTimeStamp (f, (v->depositTimeStamp), indent + stdIndentG);
    }
    if (NOT_NULL ((v->completionTimeStamp)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"completionTimeStamp ");
    PrintCompletionTimeStamp (f, (v->completionTimeStamp), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->chargingPoint)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"chargingPoint ");
    PrintChargingPoint (f, (&v->chargingPoint), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintScuTimeStamps */

void
FreeScuTimeStamps PARAMS ((v),
ScuTimeStamps *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->depositTimeStamp)))
    {
    FreeDepositTimeStamp ((v->depositTimeStamp));
    Asn1Free ((v->depositTimeStamp));
    }

    if (NOT_NULL ((v->completionTimeStamp)))
    {
    FreeCompletionTimeStamp ((v->completionTimeStamp));
    Asn1Free ((v->completionTimeStamp));
    }

    if (ASNOCTS_PRESENT ((&v->chargingPoint)))
    {
    FreeChargingPoint ((&v->chargingPoint));
    }

}  /* FreeScuTimeStamps */




AsnLen
BEncMessagingEventContent PARAMS ((b, v),
BUF_TYPE b _AND_
MessagingEvent *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->operatorSpecInformation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncOperatorSpecInfoListContent (b, (v->operatorSpecInformation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 162);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->taxInformationList)))
    {
    BEncEocIfNec (b);
    itemLen = BEncTaxInformationListContent (b, (v->taxInformationList));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 214);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->charge)))
    {
    itemLen = BEncChargeContent (b, (v->charge));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, APPL, PRIM, 62);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->callTypeGroup)))
    {
    BEncEocIfNec (b);
    itemLen = BEncCallTypeGroupContent (b, (v->callTypeGroup));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 258);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->exchangeRateCode)))
    {
    itemLen = BEncExchangeRateCodeContent (b, (v->exchangeRateCode));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, APPL, PRIM, 105);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->nonChargedParty)))
    {
    BEncEocIfNec (b);
    itemLen = BEncNonChargedPartyContent (b, (v->nonChargedParty));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 443);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->serviceStartTimestamp)))
    {
    BEncEocIfNec (b);
    itemLen = BEncServiceStartTimestampContent (b, (v->serviceStartTimestamp));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 447);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->cellId)))
    {
    itemLen = BEncCellIdContent (b, (v->cellId));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, APPL, PRIM, 59);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->locationArea)))
    {
    itemLen = BEncLocationAreaContent (b, (v->locationArea));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 136);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->networkElementList)))
    {
    BEncEocIfNec (b);
    itemLen = BEncNetworkElementListContent (b, (v->networkElementList));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 442);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->recEntityCodeList)))
    {
    BEncEocIfNec (b);
    itemLen = BEncRecEntityCodeListContent (b, (v->recEntityCodeList));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 185);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->eventReference)))
    {
    itemLen = BEncEventReferenceContent (b, (&v->eventReference));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 435);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->geographicalLocation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncGeographicalLocationContent (b, (v->geographicalLocation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 113);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->simToolkitIndicator)))
    {
    itemLen = BEncSimToolkitIndicatorContent (b, (&v->simToolkitIndicator));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 200);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->rapFileSequenceNumber)))
    {
    itemLen = BEncRapFileSequenceNumberContent (b, (&v->rapFileSequenceNumber));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 181);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->chargedParty)))
    {
    BEncEocIfNec (b);
    itemLen = BEncChargedPartyContent (b, (v->chargedParty));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 436);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->messagingEventService)))
    {
    itemLen = BEncMessagingEventServiceContent (b, (v->messagingEventService));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 439);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncMessagingEventContent */

void
BDecMessagingEventContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
MessagingEvent *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 439))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->messagingEventService) = (MessagingEventService*) Asn1Alloc (sizeof (MessagingEventService));
    CheckAsn1Alloc ((v->messagingEventService), env);
    BDecMessagingEventServiceContent (b, tagId1, elmtLen1, (v->messagingEventService), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 436))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->chargedParty) = (ChargedParty*) Asn1Alloc (sizeof (ChargedParty));
    CheckAsn1Alloc ((v->chargedParty), env);
    BDecChargedPartyContent (b, tagId1, elmtLen1, (v->chargedParty), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 181)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 181))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecRapFileSequenceNumberContent (b, tagId1, elmtLen1, (&v->rapFileSequenceNumber), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 200)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 200))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecSimToolkitIndicatorContent (b, tagId1, elmtLen1, (&v->simToolkitIndicator), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 113))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->geographicalLocation) = (GeographicalLocation*) Asn1Alloc (sizeof (GeographicalLocation));
    CheckAsn1Alloc ((v->geographicalLocation), env);
    BDecGeographicalLocationContent (b, tagId1, elmtLen1, (v->geographicalLocation), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 435)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 435))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecEventReferenceContent (b, tagId1, elmtLen1, (&v->eventReference), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 185))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->recEntityCodeList) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->recEntityCodeList), env);
    BDecRecEntityCodeListContent (b, tagId1, elmtLen1, (v->recEntityCodeList), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 442))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->networkElementList) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->networkElementList), env);
    BDecNetworkElementListContent (b, tagId1, elmtLen1, (v->networkElementList), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 136))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->locationArea) = (LocationArea*) Asn1Alloc (sizeof (LocationArea));
    CheckAsn1Alloc ((v->locationArea), env);
    BDecLocationAreaContent (b, tagId1, elmtLen1, (v->locationArea), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 59))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->cellId) = (CellId*) Asn1Alloc (sizeof (CellId));
    CheckAsn1Alloc ((v->cellId), env);
    BDecCellIdContent (b, tagId1, elmtLen1, (v->cellId), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 447))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->serviceStartTimestamp) = (ServiceStartTimestamp*) Asn1Alloc (sizeof (ServiceStartTimestamp));
    CheckAsn1Alloc ((v->serviceStartTimestamp), env);
    BDecServiceStartTimestampContent (b, tagId1, elmtLen1, (v->serviceStartTimestamp), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 443))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->nonChargedParty) = (NonChargedParty*) Asn1Alloc (sizeof (NonChargedParty));
    CheckAsn1Alloc ((v->nonChargedParty), env);
    BDecNonChargedPartyContent (b, tagId1, elmtLen1, (v->nonChargedParty), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 105))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->exchangeRateCode) = (ExchangeRateCode*) Asn1Alloc (sizeof (ExchangeRateCode));
    CheckAsn1Alloc ((v->exchangeRateCode), env);
    BDecExchangeRateCodeContent (b, tagId1, elmtLen1, (v->exchangeRateCode), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 258))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->callTypeGroup) = (CallTypeGroup*) Asn1Alloc (sizeof (CallTypeGroup));
    CheckAsn1Alloc ((v->callTypeGroup), env);
    BDecCallTypeGroupContent (b, tagId1, elmtLen1, (v->callTypeGroup), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 62))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->charge) = (Charge*) Asn1Alloc (sizeof (Charge));
    CheckAsn1Alloc ((v->charge), env);
    BDecChargeContent (b, tagId1, elmtLen1, (v->charge), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 214))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->taxInformationList) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->taxInformationList), env);
    BDecTaxInformationListContent (b, tagId1, elmtLen1, (v->taxInformationList), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 162))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->operatorSpecInformation) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->operatorSpecInformation), env);
    BDecOperatorSpecInfoListContent (b, tagId1, elmtLen1, (v->operatorSpecInformation), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -266);
    }


    if (!seqDone)
        longjmp (env, -267);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecMessagingEventContent */

void
PrintMessagingEvent PARAMS ((f, v, indent),
FILE* f _AND_
MessagingEvent *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->messagingEventService)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"messagingEventService ");
    PrintMessagingEventService (f, (v->messagingEventService), indent + stdIndentG);
    }
    if (NOT_NULL ((v->chargedParty)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"chargedParty ");
    PrintChargedParty (f, (v->chargedParty), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->rapFileSequenceNumber)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"rapFileSequenceNumber ");
    PrintRapFileSequenceNumber (f, (&v->rapFileSequenceNumber), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->simToolkitIndicator)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"simToolkitIndicator ");
    PrintSimToolkitIndicator (f, (&v->simToolkitIndicator), indent + stdIndentG);
    }
    if (NOT_NULL ((v->geographicalLocation)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"geographicalLocation ");
    PrintGeographicalLocation (f, (v->geographicalLocation), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->eventReference)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"eventReference ");
    PrintEventReference (f, (&v->eventReference), indent + stdIndentG);
    }
    if (NOT_NULL ((v->recEntityCodeList)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"recEntityCodeList ");
    PrintRecEntityCodeList (f, (v->recEntityCodeList), indent + stdIndentG);
    }
    if (NOT_NULL ((v->networkElementList)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"networkElementList ");
    PrintNetworkElementList (f, (v->networkElementList), indent + stdIndentG);
    }
    if (NOT_NULL ((v->locationArea)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"locationArea ");
    PrintLocationArea (f, (v->locationArea), indent + stdIndentG);
    }
    if (NOT_NULL ((v->cellId)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"cellId ");
    PrintCellId (f, (v->cellId), indent + stdIndentG);
    }
    if (NOT_NULL ((v->serviceStartTimestamp)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"serviceStartTimestamp ");
    PrintServiceStartTimestamp (f, (v->serviceStartTimestamp), indent + stdIndentG);
    }
    if (NOT_NULL ((v->nonChargedParty)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"nonChargedParty ");
    PrintNonChargedParty (f, (v->nonChargedParty), indent + stdIndentG);
    }
    if (NOT_NULL ((v->exchangeRateCode)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"exchangeRateCode ");
    PrintExchangeRateCode (f, (v->exchangeRateCode), indent + stdIndentG);
    }
    if (NOT_NULL ((v->callTypeGroup)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"callTypeGroup ");
    PrintCallTypeGroup (f, (v->callTypeGroup), indent + stdIndentG);
    }
    if (NOT_NULL ((v->charge)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"charge ");
    PrintCharge (f, (v->charge), indent + stdIndentG);
    }
    if (NOT_NULL ((v->taxInformationList)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"taxInformationList ");
    PrintTaxInformationList (f, (v->taxInformationList), indent + stdIndentG);
    }
    if (NOT_NULL ((v->operatorSpecInformation)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"operatorSpecInformation ");
    PrintOperatorSpecInfoList (f, (v->operatorSpecInformation), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintMessagingEvent */

void
FreeMessagingEvent PARAMS ((v),
MessagingEvent *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->messagingEventService)))
    {
    FreeMessagingEventService ((v->messagingEventService));
    Asn1Free ((v->messagingEventService));
    }

    if (NOT_NULL ((v->chargedParty)))
    {
    FreeChargedParty ((v->chargedParty));
    Asn1Free ((v->chargedParty));
    }

    if (ASNOCTS_PRESENT ((&v->rapFileSequenceNumber)))
    {
    FreeRapFileSequenceNumber ((&v->rapFileSequenceNumber));
    }

    if (ASNOCTS_PRESENT ((&v->simToolkitIndicator)))
    {
    FreeSimToolkitIndicator ((&v->simToolkitIndicator));
    }

    if (NOT_NULL ((v->geographicalLocation)))
    {
    FreeGeographicalLocation ((v->geographicalLocation));
    Asn1Free ((v->geographicalLocation));
    }

    if (ASNOCTS_PRESENT ((&v->eventReference)))
    {
    FreeEventReference ((&v->eventReference));
    }

    if (NOT_NULL ((v->recEntityCodeList)))
    {
    FreeRecEntityCodeList ((v->recEntityCodeList));
    Asn1Free ((v->recEntityCodeList));
    }

    if (NOT_NULL ((v->networkElementList)))
    {
    FreeNetworkElementList ((v->networkElementList));
    Asn1Free ((v->networkElementList));
    }

    if (NOT_NULL ((v->locationArea)))
    {
    FreeLocationArea ((v->locationArea));
    Asn1Free ((v->locationArea));
    }

    if (NOT_NULL ((v->cellId)))
    {
    FreeCellId ((v->cellId));
    Asn1Free ((v->cellId));
    }

    if (NOT_NULL ((v->serviceStartTimestamp)))
    {
    FreeServiceStartTimestamp ((v->serviceStartTimestamp));
    Asn1Free ((v->serviceStartTimestamp));
    }

    if (NOT_NULL ((v->nonChargedParty)))
    {
    FreeNonChargedParty ((v->nonChargedParty));
    Asn1Free ((v->nonChargedParty));
    }

    if (NOT_NULL ((v->exchangeRateCode)))
    {
    FreeExchangeRateCode ((v->exchangeRateCode));
    Asn1Free ((v->exchangeRateCode));
    }

    if (NOT_NULL ((v->callTypeGroup)))
    {
    FreeCallTypeGroup ((v->callTypeGroup));
    Asn1Free ((v->callTypeGroup));
    }

    if (NOT_NULL ((v->charge)))
    {
    FreeCharge ((v->charge));
    Asn1Free ((v->charge));
    }

    if (NOT_NULL ((v->taxInformationList)))
    {
    FreeTaxInformationList ((v->taxInformationList));
    Asn1Free ((v->taxInformationList));
    }

    if (NOT_NULL ((v->operatorSpecInformation)))
    {
    FreeOperatorSpecInfoList ((v->operatorSpecInformation));
    Asn1Free ((v->operatorSpecInformation));
    }

}  /* FreeMessagingEvent */




AsnLen
BEncChargeDetailContent PARAMS ((b, v),
BUF_TYPE b _AND_
ChargeDetail *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->chargeDetailTimeStamp)))
    {
    BEncEocIfNec (b);
    itemLen = BEncChargeDetailTimeStampContent (b, (v->chargeDetailTimeStamp));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 410);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->chargedUnits)))
    {
    itemLen = BEncChargedUnitsContent (b, (v->chargedUnits));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, APPL, PRIM, 68);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->chargeableUnits)))
    {
    itemLen = BEncChargeableUnitsContent (b, (v->chargeableUnits));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, APPL, PRIM, 65);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->charge)))
    {
    itemLen = BEncChargeContent (b, (v->charge));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, APPL, PRIM, 62);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->chargeType)))
    {
    itemLen = BEncChargeTypeContent (b, (&v->chargeType));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, PRIM, 71);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncChargeDetailContent */

void
BDecChargeDetailContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ChargeDetail *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 71)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 71))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecChargeTypeContent (b, tagId1, elmtLen1, (&v->chargeType), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 62))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->charge) = (Charge*) Asn1Alloc (sizeof (Charge));
    CheckAsn1Alloc ((v->charge), env);
    BDecChargeContent (b, tagId1, elmtLen1, (v->charge), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 65))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->chargeableUnits) = (ChargeableUnits*) Asn1Alloc (sizeof (ChargeableUnits));
    CheckAsn1Alloc ((v->chargeableUnits), env);
    BDecChargeableUnitsContent (b, tagId1, elmtLen1, (v->chargeableUnits), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 68))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->chargedUnits) = (ChargedUnits*) Asn1Alloc (sizeof (ChargedUnits));
    CheckAsn1Alloc ((v->chargedUnits), env);
    BDecChargedUnitsContent (b, tagId1, elmtLen1, (v->chargedUnits), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 410))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->chargeDetailTimeStamp) = (ChargeDetailTimeStamp*) Asn1Alloc (sizeof (ChargeDetailTimeStamp));
    CheckAsn1Alloc ((v->chargeDetailTimeStamp), env);
    BDecChargeDetailTimeStampContent (b, tagId1, elmtLen1, (v->chargeDetailTimeStamp), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -268);
    }


    if (!seqDone)
        longjmp (env, -269);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecChargeDetailContent */

void
PrintChargeDetail PARAMS ((f, v, indent),
FILE* f _AND_
ChargeDetail *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (ASNOCTS_PRESENT ((&v->chargeType)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"chargeType ");
    PrintChargeType (f, (&v->chargeType), indent + stdIndentG);
    }
    if (NOT_NULL ((v->charge)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"charge ");
    PrintCharge (f, (v->charge), indent + stdIndentG);
    }
    if (NOT_NULL ((v->chargeableUnits)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"chargeableUnits ");
    PrintChargeableUnits (f, (v->chargeableUnits), indent + stdIndentG);
    }
    if (NOT_NULL ((v->chargedUnits)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"chargedUnits ");
    PrintChargedUnits (f, (v->chargedUnits), indent + stdIndentG);
    }
    if (NOT_NULL ((v->chargeDetailTimeStamp)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"chargeDetailTimeStamp ");
    PrintChargeDetailTimeStamp (f, (v->chargeDetailTimeStamp), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintChargeDetail */

void
FreeChargeDetail PARAMS ((v),
ChargeDetail *v)
{

    if (v == NULL)
        return;
    if (ASNOCTS_PRESENT ((&v->chargeType)))
    {
    FreeChargeType ((&v->chargeType));
    }

    if (NOT_NULL ((v->charge)))
    {
    FreeCharge ((v->charge));
    Asn1Free ((v->charge));
    }

    if (NOT_NULL ((v->chargeableUnits)))
    {
    FreeChargeableUnits ((v->chargeableUnits));
    Asn1Free ((v->chargeableUnits));
    }

    if (NOT_NULL ((v->chargedUnits)))
    {
    FreeChargedUnits ((v->chargedUnits));
    Asn1Free ((v->chargedUnits));
    }

    if (NOT_NULL ((v->chargeDetailTimeStamp)))
    {
    FreeChargeDetailTimeStamp ((v->chargeDetailTimeStamp));
    Asn1Free ((v->chargeDetailTimeStamp));
    }

}  /* FreeChargeDetail */




AsnLen
BEncChargeDetailListContent PARAMS ((b, v),
BUF_TYPE b _AND_
ChargeDetailList *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    BEncEocIfNec (b);
    itemLen = BEncChargeDetailContent (b, component);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 63);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncChargeDetailListContent */

void
BDecChargeDetailListContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ChargeDetailList *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        ChargeDetail **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (APPL, CONS, 63)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (ChargeDetail**) AsnListAppend (v);
    (*tmpVar) = (ChargeDetail*) Asn1Alloc (sizeof (ChargeDetail));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecChargeDetailContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -270);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecChargeDetailListContent */

void
PrintChargeDetailList PARAMS ((f, v, indent),
FILE* f _AND_
ChargeDetailList *v _AND_
unsigned short int indent)
{
    ChargeDetail *tmp;
    if (v == NULL)
        return;
    fprintf (f,"{ -- SEQUENCE OF -- \n");
    FOR_EACH_LIST_ELMT (tmp, v)
    {
        Indent (f, indent+ stdIndentG);
        PrintChargeDetail (f, tmp, indent + stdIndentG);
        if (tmp != (ChargeDetail*)LAST_LIST_ELMT (v))
            fprintf (f,",\n");
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintChargeDetailList */

void
FreeChargeDetailList PARAMS ((v),
ChargeDetailList *v)
{

    AsnListNode *l;
    AsnListNode *tmp;
    if (v == NULL)
        return;
    for (l = FIRST_LIST_NODE (v); l != NULL; )
    {
        FreeChargeDetail ((l->data));
        tmp = l->next;
        Asn1Free (l->data);
        Asn1Free (l);
        l = tmp;
    }
}  /* FreeChargeDetailList */




AsnLen
BEncChargeInformationContent PARAMS ((b, v),
BUF_TYPE b _AND_
ChargeInformation *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->discountInformation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncDiscountInformationContent (b, (v->discountInformation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 96);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->taxInformation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncTaxInformationListContent (b, (v->taxInformation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 214);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->chargeDetailList)))
    {
    BEncEocIfNec (b);
    itemLen = BEncChargeDetailListContent (b, (v->chargeDetailList));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 64);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->callTypeGroup)))
    {
    BEncEocIfNec (b);
    itemLen = BEncCallTypeGroupContent (b, (v->callTypeGroup));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 258);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->exchangeRateCode)))
    {
    itemLen = BEncExchangeRateCodeContent (b, (v->exchangeRateCode));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, APPL, PRIM, 105);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->chargedItem)))
    {
    itemLen = BEncChargedItemContent (b, (&v->chargedItem));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, PRIM, 66);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncChargeInformationContent */

void
BDecChargeInformationContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ChargeInformation *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 66)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 66))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecChargedItemContent (b, tagId1, elmtLen1, (&v->chargedItem), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 105))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->exchangeRateCode) = (ExchangeRateCode*) Asn1Alloc (sizeof (ExchangeRateCode));
    CheckAsn1Alloc ((v->exchangeRateCode), env);
    BDecExchangeRateCodeContent (b, tagId1, elmtLen1, (v->exchangeRateCode), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 258))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->callTypeGroup) = (CallTypeGroup*) Asn1Alloc (sizeof (CallTypeGroup));
    CheckAsn1Alloc ((v->callTypeGroup), env);
    BDecCallTypeGroupContent (b, tagId1, elmtLen1, (v->callTypeGroup), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 64))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->chargeDetailList) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->chargeDetailList), env);
    BDecChargeDetailListContent (b, tagId1, elmtLen1, (v->chargeDetailList), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 214))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->taxInformation) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->taxInformation), env);
    BDecTaxInformationListContent (b, tagId1, elmtLen1, (v->taxInformation), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 96))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->discountInformation) = (DiscountInformation*) Asn1Alloc (sizeof (DiscountInformation));
    CheckAsn1Alloc ((v->discountInformation), env);
    BDecDiscountInformationContent (b, tagId1, elmtLen1, (v->discountInformation), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -271);
    }


    if (!seqDone)
        longjmp (env, -272);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecChargeInformationContent */

void
PrintChargeInformation PARAMS ((f, v, indent),
FILE* f _AND_
ChargeInformation *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (ASNOCTS_PRESENT ((&v->chargedItem)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"chargedItem ");
    PrintChargedItem (f, (&v->chargedItem), indent + stdIndentG);
    }
    if (NOT_NULL ((v->exchangeRateCode)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"exchangeRateCode ");
    PrintExchangeRateCode (f, (v->exchangeRateCode), indent + stdIndentG);
    }
    if (NOT_NULL ((v->callTypeGroup)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"callTypeGroup ");
    PrintCallTypeGroup (f, (v->callTypeGroup), indent + stdIndentG);
    }
    if (NOT_NULL ((v->chargeDetailList)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"chargeDetailList ");
    PrintChargeDetailList (f, (v->chargeDetailList), indent + stdIndentG);
    }
    if (NOT_NULL ((v->taxInformation)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"taxInformation ");
    PrintTaxInformationList (f, (v->taxInformation), indent + stdIndentG);
    }
    if (NOT_NULL ((v->discountInformation)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"discountInformation ");
    PrintDiscountInformation (f, (v->discountInformation), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintChargeInformation */

void
FreeChargeInformation PARAMS ((v),
ChargeInformation *v)
{

    if (v == NULL)
        return;
    if (ASNOCTS_PRESENT ((&v->chargedItem)))
    {
    FreeChargedItem ((&v->chargedItem));
    }

    if (NOT_NULL ((v->exchangeRateCode)))
    {
    FreeExchangeRateCode ((v->exchangeRateCode));
    Asn1Free ((v->exchangeRateCode));
    }

    if (NOT_NULL ((v->callTypeGroup)))
    {
    FreeCallTypeGroup ((v->callTypeGroup));
    Asn1Free ((v->callTypeGroup));
    }

    if (NOT_NULL ((v->chargeDetailList)))
    {
    FreeChargeDetailList ((v->chargeDetailList));
    Asn1Free ((v->chargeDetailList));
    }

    if (NOT_NULL ((v->taxInformation)))
    {
    FreeTaxInformationList ((v->taxInformation));
    Asn1Free ((v->taxInformation));
    }

    if (NOT_NULL ((v->discountInformation)))
    {
    FreeDiscountInformation ((v->discountInformation));
    Asn1Free ((v->discountInformation));
    }

}  /* FreeChargeInformation */




AsnLen
BEncChargeInformationListContent PARAMS ((b, v),
BUF_TYPE b _AND_
ChargeInformationList *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    BEncEocIfNec (b);
    itemLen = BEncChargeInformationContent (b, component);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 69);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncChargeInformationListContent */

void
BDecChargeInformationListContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ChargeInformationList *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        ChargeInformation **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (APPL, CONS, 69)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (ChargeInformation**) AsnListAppend (v);
    (*tmpVar) = (ChargeInformation*) Asn1Alloc (sizeof (ChargeInformation));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecChargeInformationContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -273);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecChargeInformationListContent */

void
PrintChargeInformationList PARAMS ((f, v, indent),
FILE* f _AND_
ChargeInformationList *v _AND_
unsigned short int indent)
{
    ChargeInformation *tmp;
    if (v == NULL)
        return;
    fprintf (f,"{ -- SEQUENCE OF -- \n");
    FOR_EACH_LIST_ELMT (tmp, v)
    {
        Indent (f, indent+ stdIndentG);
        PrintChargeInformation (f, tmp, indent + stdIndentG);
        if (tmp != (ChargeInformation*)LAST_LIST_ELMT (v))
            fprintf (f,",\n");
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintChargeInformationList */

void
FreeChargeInformationList PARAMS ((v),
ChargeInformationList *v)
{

    AsnListNode *l;
    AsnListNode *tmp;
    if (v == NULL)
        return;
    for (l = FIRST_LIST_NODE (v); l != NULL; )
    {
        FreeChargeInformation ((l->data));
        tmp = l->next;
        Asn1Free (l->data);
        Asn1Free (l);
        l = tmp;
    }
}  /* FreeChargeInformationList */




AsnLen
BEncContentServiceUsedContent PARAMS ((b, v),
BUF_TYPE b _AND_
ContentServiceUsed *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->advisedChargeInformation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncAdvisedChargeInformationContent (b, (v->advisedChargeInformation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 351);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->chargeInformationList)))
    {
    BEncEocIfNec (b);
    itemLen = BEncChargeInformationListContent (b, (v->chargeInformationList));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 70);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->contentChargingPoint)))
    {
    itemLen = BEncContentChargingPointContent (b, (v->contentChargingPoint));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 345);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->chargeRefundIndicator)))
    {
    itemLen = BEncChargeRefundIndicatorContent (b, (v->chargeRefundIndicator));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 344);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->totalDataVolume)))
    {
    itemLen = BEncTotalDataVolumeContent (b, (v->totalDataVolume));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 343);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->dataVolumeOutgoing)))
    {
    itemLen = BEncDataVolumeOutgoingContent (b, (v->dataVolumeOutgoing));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 251);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->dataVolumeIncoming)))
    {
    itemLen = BEncDataVolumeIncomingContent (b, (v->dataVolumeIncoming));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 250);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->transactionAuthCode)))
    {
    itemLen = BEncTransactionAuthCodeContent (b, (&v->transactionAuthCode));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 342);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->transactionIdentifier)))
    {
    itemLen = BEncTransactionIdentifierContent (b, (&v->transactionIdentifier));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 341);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->transactionDetailDescription)))
    {
    itemLen = BEncTransactionDetailDescriptionContent (b, (&v->transactionDetailDescription));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 339);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->transactionShortDescription)))
    {
    itemLen = BEncTransactionShortDescriptionContent (b, (&v->transactionShortDescription));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 340);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->transactionDescriptionSupp)))
    {
    itemLen = BEncTransactionDescriptionSuppContent (b, (v->transactionDescriptionSupp));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 338);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->objectType)))
    {
    itemLen = BEncObjectTypeContent (b, (v->objectType));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 281);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->contentTransactionType)))
    {
    itemLen = BEncContentTransactionTypeContent (b, (v->contentTransactionType));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 337);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->contentTransactionCode)))
    {
    itemLen = BEncContentTransactionCodeContent (b, (v->contentTransactionCode));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 336);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncContentServiceUsedContent */

void
BDecContentServiceUsedContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ContentServiceUsed *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 336))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->contentTransactionCode) = (ContentTransactionCode*) Asn1Alloc (sizeof (ContentTransactionCode));
    CheckAsn1Alloc ((v->contentTransactionCode), env);
    BDecContentTransactionCodeContent (b, tagId1, elmtLen1, (v->contentTransactionCode), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 337))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->contentTransactionType) = (ContentTransactionType*) Asn1Alloc (sizeof (ContentTransactionType));
    CheckAsn1Alloc ((v->contentTransactionType), env);
    BDecContentTransactionTypeContent (b, tagId1, elmtLen1, (v->contentTransactionType), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 281))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->objectType) = (ObjectType*) Asn1Alloc (sizeof (ObjectType));
    CheckAsn1Alloc ((v->objectType), env);
    BDecObjectTypeContent (b, tagId1, elmtLen1, (v->objectType), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 338))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->transactionDescriptionSupp) = (TransactionDescriptionSupp*) Asn1Alloc (sizeof (TransactionDescriptionSupp));
    CheckAsn1Alloc ((v->transactionDescriptionSupp), env);
    BDecTransactionDescriptionSuppContent (b, tagId1, elmtLen1, (v->transactionDescriptionSupp), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 340)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 340))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecTransactionShortDescriptionContent (b, tagId1, elmtLen1, (&v->transactionShortDescription), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 339)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 339))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecTransactionDetailDescriptionContent (b, tagId1, elmtLen1, (&v->transactionDetailDescription), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 341)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 341))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecTransactionIdentifierContent (b, tagId1, elmtLen1, (&v->transactionIdentifier), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 342)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 342))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecTransactionAuthCodeContent (b, tagId1, elmtLen1, (&v->transactionAuthCode), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 250))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->dataVolumeIncoming) = (DataVolumeIncoming*) Asn1Alloc (sizeof (DataVolumeIncoming));
    CheckAsn1Alloc ((v->dataVolumeIncoming), env);
    BDecDataVolumeIncomingContent (b, tagId1, elmtLen1, (v->dataVolumeIncoming), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 251))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->dataVolumeOutgoing) = (DataVolumeOutgoing*) Asn1Alloc (sizeof (DataVolumeOutgoing));
    CheckAsn1Alloc ((v->dataVolumeOutgoing), env);
    BDecDataVolumeOutgoingContent (b, tagId1, elmtLen1, (v->dataVolumeOutgoing), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 343))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->totalDataVolume) = (TotalDataVolume*) Asn1Alloc (sizeof (TotalDataVolume));
    CheckAsn1Alloc ((v->totalDataVolume), env);
    BDecTotalDataVolumeContent (b, tagId1, elmtLen1, (v->totalDataVolume), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 344))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->chargeRefundIndicator) = (ChargeRefundIndicator*) Asn1Alloc (sizeof (ChargeRefundIndicator));
    CheckAsn1Alloc ((v->chargeRefundIndicator), env);
    BDecChargeRefundIndicatorContent (b, tagId1, elmtLen1, (v->chargeRefundIndicator), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 345))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->contentChargingPoint) = (ContentChargingPoint*) Asn1Alloc (sizeof (ContentChargingPoint));
    CheckAsn1Alloc ((v->contentChargingPoint), env);
    BDecContentChargingPointContent (b, tagId1, elmtLen1, (v->contentChargingPoint), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 70))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->chargeInformationList) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->chargeInformationList), env);
    BDecChargeInformationListContent (b, tagId1, elmtLen1, (v->chargeInformationList), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 351))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->advisedChargeInformation) = (AdvisedChargeInformation*) Asn1Alloc (sizeof (AdvisedChargeInformation));
    CheckAsn1Alloc ((v->advisedChargeInformation), env);
    BDecAdvisedChargeInformationContent (b, tagId1, elmtLen1, (v->advisedChargeInformation), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -274);
    }


    if (!seqDone)
        longjmp (env, -275);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecContentServiceUsedContent */

void
PrintContentServiceUsed PARAMS ((f, v, indent),
FILE* f _AND_
ContentServiceUsed *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->contentTransactionCode)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"contentTransactionCode ");
    PrintContentTransactionCode (f, (v->contentTransactionCode), indent + stdIndentG);
    }
    if (NOT_NULL ((v->contentTransactionType)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"contentTransactionType ");
    PrintContentTransactionType (f, (v->contentTransactionType), indent + stdIndentG);
    }
    if (NOT_NULL ((v->objectType)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"objectType ");
    PrintObjectType (f, (v->objectType), indent + stdIndentG);
    }
    if (NOT_NULL ((v->transactionDescriptionSupp)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"transactionDescriptionSupp ");
    PrintTransactionDescriptionSupp (f, (v->transactionDescriptionSupp), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->transactionShortDescription)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"transactionShortDescription ");
    PrintTransactionShortDescription (f, (&v->transactionShortDescription), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->transactionDetailDescription)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"transactionDetailDescription ");
    PrintTransactionDetailDescription (f, (&v->transactionDetailDescription), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->transactionIdentifier)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"transactionIdentifier ");
    PrintTransactionIdentifier (f, (&v->transactionIdentifier), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->transactionAuthCode)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"transactionAuthCode ");
    PrintTransactionAuthCode (f, (&v->transactionAuthCode), indent + stdIndentG);
    }
    if (NOT_NULL ((v->dataVolumeIncoming)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"dataVolumeIncoming ");
    PrintDataVolumeIncoming (f, (v->dataVolumeIncoming), indent + stdIndentG);
    }
    if (NOT_NULL ((v->dataVolumeOutgoing)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"dataVolumeOutgoing ");
    PrintDataVolumeOutgoing (f, (v->dataVolumeOutgoing), indent + stdIndentG);
    }
    if (NOT_NULL ((v->totalDataVolume)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"totalDataVolume ");
    PrintTotalDataVolume (f, (v->totalDataVolume), indent + stdIndentG);
    }
    if (NOT_NULL ((v->chargeRefundIndicator)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"chargeRefundIndicator ");
    PrintChargeRefundIndicator (f, (v->chargeRefundIndicator), indent + stdIndentG);
    }
    if (NOT_NULL ((v->contentChargingPoint)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"contentChargingPoint ");
    PrintContentChargingPoint (f, (v->contentChargingPoint), indent + stdIndentG);
    }
    if (NOT_NULL ((v->chargeInformationList)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"chargeInformationList ");
    PrintChargeInformationList (f, (v->chargeInformationList), indent + stdIndentG);
    }
    if (NOT_NULL ((v->advisedChargeInformation)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"advisedChargeInformation ");
    PrintAdvisedChargeInformation (f, (v->advisedChargeInformation), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintContentServiceUsed */

void
FreeContentServiceUsed PARAMS ((v),
ContentServiceUsed *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->contentTransactionCode)))
    {
    FreeContentTransactionCode ((v->contentTransactionCode));
    Asn1Free ((v->contentTransactionCode));
    }

    if (NOT_NULL ((v->contentTransactionType)))
    {
    FreeContentTransactionType ((v->contentTransactionType));
    Asn1Free ((v->contentTransactionType));
    }

    if (NOT_NULL ((v->objectType)))
    {
    FreeObjectType ((v->objectType));
    Asn1Free ((v->objectType));
    }

    if (NOT_NULL ((v->transactionDescriptionSupp)))
    {
    FreeTransactionDescriptionSupp ((v->transactionDescriptionSupp));
    Asn1Free ((v->transactionDescriptionSupp));
    }

    if (ASNOCTS_PRESENT ((&v->transactionShortDescription)))
    {
    FreeTransactionShortDescription ((&v->transactionShortDescription));
    }

    if (ASNOCTS_PRESENT ((&v->transactionDetailDescription)))
    {
    FreeTransactionDetailDescription ((&v->transactionDetailDescription));
    }

    if (ASNOCTS_PRESENT ((&v->transactionIdentifier)))
    {
    FreeTransactionIdentifier ((&v->transactionIdentifier));
    }

    if (ASNOCTS_PRESENT ((&v->transactionAuthCode)))
    {
    FreeTransactionAuthCode ((&v->transactionAuthCode));
    }

    if (NOT_NULL ((v->dataVolumeIncoming)))
    {
    FreeDataVolumeIncoming ((v->dataVolumeIncoming));
    Asn1Free ((v->dataVolumeIncoming));
    }

    if (NOT_NULL ((v->dataVolumeOutgoing)))
    {
    FreeDataVolumeOutgoing ((v->dataVolumeOutgoing));
    Asn1Free ((v->dataVolumeOutgoing));
    }

    if (NOT_NULL ((v->totalDataVolume)))
    {
    FreeTotalDataVolume ((v->totalDataVolume));
    Asn1Free ((v->totalDataVolume));
    }

    if (NOT_NULL ((v->chargeRefundIndicator)))
    {
    FreeChargeRefundIndicator ((v->chargeRefundIndicator));
    Asn1Free ((v->chargeRefundIndicator));
    }

    if (NOT_NULL ((v->contentChargingPoint)))
    {
    FreeContentChargingPoint ((v->contentChargingPoint));
    Asn1Free ((v->contentChargingPoint));
    }

    if (NOT_NULL ((v->chargeInformationList)))
    {
    FreeChargeInformationList ((v->chargeInformationList));
    Asn1Free ((v->chargeInformationList));
    }

    if (NOT_NULL ((v->advisedChargeInformation)))
    {
    FreeAdvisedChargeInformation ((v->advisedChargeInformation));
    Asn1Free ((v->advisedChargeInformation));
    }

}  /* FreeContentServiceUsed */




AsnLen
BEncContentServiceUsedListContent PARAMS ((b, v),
BUF_TYPE b _AND_
ContentServiceUsedList *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    BEncEocIfNec (b);
    itemLen = BEncContentServiceUsedContent (b, component);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 352);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncContentServiceUsedListContent */

void
BDecContentServiceUsedListContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ContentServiceUsedList *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        ContentServiceUsed **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (APPL, CONS, 352)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (ContentServiceUsed**) AsnListAppend (v);
    (*tmpVar) = (ContentServiceUsed*) Asn1Alloc (sizeof (ContentServiceUsed));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecContentServiceUsedContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -276);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecContentServiceUsedListContent */

void
PrintContentServiceUsedList PARAMS ((f, v, indent),
FILE* f _AND_
ContentServiceUsedList *v _AND_
unsigned short int indent)
{
    ContentServiceUsed *tmp;
    if (v == NULL)
        return;
    fprintf (f,"{ -- SEQUENCE OF -- \n");
    FOR_EACH_LIST_ELMT (tmp, v)
    {
        Indent (f, indent+ stdIndentG);
        PrintContentServiceUsed (f, tmp, indent + stdIndentG);
        if (tmp != (ContentServiceUsed*)LAST_LIST_ELMT (v))
            fprintf (f,",\n");
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintContentServiceUsedList */

void
FreeContentServiceUsedList PARAMS ((v),
ContentServiceUsedList *v)
{

    AsnListNode *l;
    AsnListNode *tmp;
    if (v == NULL)
        return;
    for (l = FIRST_LIST_NODE (v); l != NULL; )
    {
        FreeContentServiceUsed ((l->data));
        tmp = l->next;
        Asn1Free (l->data);
        Asn1Free (l);
        l = tmp;
    }
}  /* FreeContentServiceUsedList */




AsnLen
BEncGprsServiceUsedContent PARAMS ((b, v),
BUF_TYPE b _AND_
GprsServiceUsed *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->chargeInformationList)))
    {
    BEncEocIfNec (b);
    itemLen = BEncChargeInformationListContent (b, (v->chargeInformationList));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 70);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->dataVolumeOutgoing)))
    {
    itemLen = BEncDataVolumeOutgoingContent (b, (v->dataVolumeOutgoing));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 251);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->dataVolumeIncoming)))
    {
    itemLen = BEncDataVolumeIncomingContent (b, (v->dataVolumeIncoming));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 250);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->iMSSignallingContext)))
    {
    itemLen = BEncIMSSignallingContextContent (b, (v->iMSSignallingContext));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 418);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncGprsServiceUsedContent */

void
BDecGprsServiceUsedContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GprsServiceUsed *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 418))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->iMSSignallingContext) = (IMSSignallingContext*) Asn1Alloc (sizeof (IMSSignallingContext));
    CheckAsn1Alloc ((v->iMSSignallingContext), env);
    BDecIMSSignallingContextContent (b, tagId1, elmtLen1, (v->iMSSignallingContext), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 250))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->dataVolumeIncoming) = (DataVolumeIncoming*) Asn1Alloc (sizeof (DataVolumeIncoming));
    CheckAsn1Alloc ((v->dataVolumeIncoming), env);
    BDecDataVolumeIncomingContent (b, tagId1, elmtLen1, (v->dataVolumeIncoming), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 251))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->dataVolumeOutgoing) = (DataVolumeOutgoing*) Asn1Alloc (sizeof (DataVolumeOutgoing));
    CheckAsn1Alloc ((v->dataVolumeOutgoing), env);
    BDecDataVolumeOutgoingContent (b, tagId1, elmtLen1, (v->dataVolumeOutgoing), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 70))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->chargeInformationList) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->chargeInformationList), env);
    BDecChargeInformationListContent (b, tagId1, elmtLen1, (v->chargeInformationList), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -277);
    }


    if (!seqDone)
        longjmp (env, -278);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGprsServiceUsedContent */

void
PrintGprsServiceUsed PARAMS ((f, v, indent),
FILE* f _AND_
GprsServiceUsed *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->iMSSignallingContext)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"iMSSignallingContext ");
    PrintIMSSignallingContext (f, (v->iMSSignallingContext), indent + stdIndentG);
    }
    if (NOT_NULL ((v->dataVolumeIncoming)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"dataVolumeIncoming ");
    PrintDataVolumeIncoming (f, (v->dataVolumeIncoming), indent + stdIndentG);
    }
    if (NOT_NULL ((v->dataVolumeOutgoing)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"dataVolumeOutgoing ");
    PrintDataVolumeOutgoing (f, (v->dataVolumeOutgoing), indent + stdIndentG);
    }
    if (NOT_NULL ((v->chargeInformationList)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"chargeInformationList ");
    PrintChargeInformationList (f, (v->chargeInformationList), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintGprsServiceUsed */

void
FreeGprsServiceUsed PARAMS ((v),
GprsServiceUsed *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->iMSSignallingContext)))
    {
    FreeIMSSignallingContext ((v->iMSSignallingContext));
    Asn1Free ((v->iMSSignallingContext));
    }

    if (NOT_NULL ((v->dataVolumeIncoming)))
    {
    FreeDataVolumeIncoming ((v->dataVolumeIncoming));
    Asn1Free ((v->dataVolumeIncoming));
    }

    if (NOT_NULL ((v->dataVolumeOutgoing)))
    {
    FreeDataVolumeOutgoing ((v->dataVolumeOutgoing));
    Asn1Free ((v->dataVolumeOutgoing));
    }

    if (NOT_NULL ((v->chargeInformationList)))
    {
    FreeChargeInformationList ((v->chargeInformationList));
    Asn1Free ((v->chargeInformationList));
    }

}  /* FreeGprsServiceUsed */




AsnLen
BEncLocationServiceUsageContent PARAMS ((b, v),
BUF_TYPE b _AND_
LocationServiceUsage *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->chargeInformationList)))
    {
    BEncEocIfNec (b);
    itemLen = BEncChargeInformationListContent (b, (v->chargeInformationList));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 70);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->chargingTimeStamp)))
    {
    BEncEocIfNec (b);
    itemLen = BEncChargingTimeStampContent (b, (v->chargingTimeStamp));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 74);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->lCSQosDelivered)))
    {
    BEncEocIfNec (b);
    itemLen = BEncLCSQosDeliveredContent (b, (v->lCSQosDelivered));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 390);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->lCSQosRequested)))
    {
    BEncEocIfNec (b);
    itemLen = BEncLCSQosRequestedContent (b, (v->lCSQosRequested));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 383);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncLocationServiceUsageContent */

void
BDecLocationServiceUsageContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
LocationServiceUsage *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 383))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->lCSQosRequested) = (LCSQosRequested*) Asn1Alloc (sizeof (LCSQosRequested));
    CheckAsn1Alloc ((v->lCSQosRequested), env);
    BDecLCSQosRequestedContent (b, tagId1, elmtLen1, (v->lCSQosRequested), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 390))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->lCSQosDelivered) = (LCSQosDelivered*) Asn1Alloc (sizeof (LCSQosDelivered));
    CheckAsn1Alloc ((v->lCSQosDelivered), env);
    BDecLCSQosDeliveredContent (b, tagId1, elmtLen1, (v->lCSQosDelivered), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 74))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->chargingTimeStamp) = (ChargingTimeStamp*) Asn1Alloc (sizeof (ChargingTimeStamp));
    CheckAsn1Alloc ((v->chargingTimeStamp), env);
    BDecChargingTimeStampContent (b, tagId1, elmtLen1, (v->chargingTimeStamp), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 70))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->chargeInformationList) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->chargeInformationList), env);
    BDecChargeInformationListContent (b, tagId1, elmtLen1, (v->chargeInformationList), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -279);
    }


    if (!seqDone)
        longjmp (env, -280);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecLocationServiceUsageContent */

void
PrintLocationServiceUsage PARAMS ((f, v, indent),
FILE* f _AND_
LocationServiceUsage *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->lCSQosRequested)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"lCSQosRequested ");
    PrintLCSQosRequested (f, (v->lCSQosRequested), indent + stdIndentG);
    }
    if (NOT_NULL ((v->lCSQosDelivered)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"lCSQosDelivered ");
    PrintLCSQosDelivered (f, (v->lCSQosDelivered), indent + stdIndentG);
    }
    if (NOT_NULL ((v->chargingTimeStamp)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"chargingTimeStamp ");
    PrintChargingTimeStamp (f, (v->chargingTimeStamp), indent + stdIndentG);
    }
    if (NOT_NULL ((v->chargeInformationList)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"chargeInformationList ");
    PrintChargeInformationList (f, (v->chargeInformationList), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintLocationServiceUsage */

void
FreeLocationServiceUsage PARAMS ((v),
LocationServiceUsage *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->lCSQosRequested)))
    {
    FreeLCSQosRequested ((v->lCSQosRequested));
    Asn1Free ((v->lCSQosRequested));
    }

    if (NOT_NULL ((v->lCSQosDelivered)))
    {
    FreeLCSQosDelivered ((v->lCSQosDelivered));
    Asn1Free ((v->lCSQosDelivered));
    }

    if (NOT_NULL ((v->chargingTimeStamp)))
    {
    FreeChargingTimeStamp ((v->chargingTimeStamp));
    Asn1Free ((v->chargingTimeStamp));
    }

    if (NOT_NULL ((v->chargeInformationList)))
    {
    FreeChargeInformationList ((v->chargeInformationList));
    Asn1Free ((v->chargeInformationList));
    }

}  /* FreeLocationServiceUsage */




AsnLen
BEncSessionChargeInformationContent PARAMS ((b, v),
BUF_TYPE b _AND_
SessionChargeInformation *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->taxInformationList)))
    {
    BEncEocIfNec (b);
    itemLen = BEncTaxInformationListContent (b, (v->taxInformationList));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 214);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->chargeDetailList)))
    {
    BEncEocIfNec (b);
    itemLen = BEncChargeDetailListContent (b, (v->chargeDetailList));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 64);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->callTypeGroup)))
    {
    BEncEocIfNec (b);
    itemLen = BEncCallTypeGroupContent (b, (v->callTypeGroup));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 258);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->exchangeRateCode)))
    {
    itemLen = BEncExchangeRateCodeContent (b, (v->exchangeRateCode));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, APPL, PRIM, 105);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->chargedItem)))
    {
    itemLen = BEncChargedItemContent (b, (&v->chargedItem));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, PRIM, 66);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncSessionChargeInformationContent */

void
BDecSessionChargeInformationContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SessionChargeInformation *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 66)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 66))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecChargedItemContent (b, tagId1, elmtLen1, (&v->chargedItem), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 105))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->exchangeRateCode) = (ExchangeRateCode*) Asn1Alloc (sizeof (ExchangeRateCode));
    CheckAsn1Alloc ((v->exchangeRateCode), env);
    BDecExchangeRateCodeContent (b, tagId1, elmtLen1, (v->exchangeRateCode), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 258))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->callTypeGroup) = (CallTypeGroup*) Asn1Alloc (sizeof (CallTypeGroup));
    CheckAsn1Alloc ((v->callTypeGroup), env);
    BDecCallTypeGroupContent (b, tagId1, elmtLen1, (v->callTypeGroup), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 64))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->chargeDetailList) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->chargeDetailList), env);
    BDecChargeDetailListContent (b, tagId1, elmtLen1, (v->chargeDetailList), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 214))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->taxInformationList) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->taxInformationList), env);
    BDecTaxInformationListContent (b, tagId1, elmtLen1, (v->taxInformationList), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -281);
    }


    if (!seqDone)
        longjmp (env, -282);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSessionChargeInformationContent */

void
PrintSessionChargeInformation PARAMS ((f, v, indent),
FILE* f _AND_
SessionChargeInformation *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (ASNOCTS_PRESENT ((&v->chargedItem)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"chargedItem ");
    PrintChargedItem (f, (&v->chargedItem), indent + stdIndentG);
    }
    if (NOT_NULL ((v->exchangeRateCode)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"exchangeRateCode ");
    PrintExchangeRateCode (f, (v->exchangeRateCode), indent + stdIndentG);
    }
    if (NOT_NULL ((v->callTypeGroup)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"callTypeGroup ");
    PrintCallTypeGroup (f, (v->callTypeGroup), indent + stdIndentG);
    }
    if (NOT_NULL ((v->chargeDetailList)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"chargeDetailList ");
    PrintChargeDetailList (f, (v->chargeDetailList), indent + stdIndentG);
    }
    if (NOT_NULL ((v->taxInformationList)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"taxInformationList ");
    PrintTaxInformationList (f, (v->taxInformationList), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintSessionChargeInformation */

void
FreeSessionChargeInformation PARAMS ((v),
SessionChargeInformation *v)
{

    if (v == NULL)
        return;
    if (ASNOCTS_PRESENT ((&v->chargedItem)))
    {
    FreeChargedItem ((&v->chargedItem));
    }

    if (NOT_NULL ((v->exchangeRateCode)))
    {
    FreeExchangeRateCode ((v->exchangeRateCode));
    Asn1Free ((v->exchangeRateCode));
    }

    if (NOT_NULL ((v->callTypeGroup)))
    {
    FreeCallTypeGroup ((v->callTypeGroup));
    Asn1Free ((v->callTypeGroup));
    }

    if (NOT_NULL ((v->chargeDetailList)))
    {
    FreeChargeDetailList ((v->chargeDetailList));
    Asn1Free ((v->chargeDetailList));
    }

    if (NOT_NULL ((v->taxInformationList)))
    {
    FreeTaxInformationList ((v->taxInformationList));
    Asn1Free ((v->taxInformationList));
    }

}  /* FreeSessionChargeInformation */




AsnLen
BEncSupplServiceUsedContent PARAMS ((b, v),
BUF_TYPE b _AND_
SupplServiceUsed *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->basicServiceCodeList)))
    {
    BEncEocIfNec (b);
    itemLen = BEncBasicServiceCodeListContent (b, (v->basicServiceCodeList));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 37);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->chargeInformation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncChargeInformationContent (b, (v->chargeInformation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 69);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->chargingTimeStamp)))
    {
    BEncEocIfNec (b);
    itemLen = BEncChargingTimeStampContent (b, (v->chargingTimeStamp));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 74);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->ssParameters)))
    {
    itemLen = BEncSsParametersContent (b, (&v->ssParameters));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 204);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->supplServiceActionCode)))
    {
    itemLen = BEncSupplServiceActionCodeContent (b, (v->supplServiceActionCode));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 208);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->supplServiceCode)))
    {
    itemLen = BEncSupplServiceCodeContent (b, (&v->supplServiceCode));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 209);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncSupplServiceUsedContent */

void
BDecSupplServiceUsedContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SupplServiceUsed *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 209)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 209))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecSupplServiceCodeContent (b, tagId1, elmtLen1, (&v->supplServiceCode), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 208))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->supplServiceActionCode) = (SupplServiceActionCode*) Asn1Alloc (sizeof (SupplServiceActionCode));
    CheckAsn1Alloc ((v->supplServiceActionCode), env);
    BDecSupplServiceActionCodeContent (b, tagId1, elmtLen1, (v->supplServiceActionCode), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 204)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 204))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecSsParametersContent (b, tagId1, elmtLen1, (&v->ssParameters), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 74))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->chargingTimeStamp) = (ChargingTimeStamp*) Asn1Alloc (sizeof (ChargingTimeStamp));
    CheckAsn1Alloc ((v->chargingTimeStamp), env);
    BDecChargingTimeStampContent (b, tagId1, elmtLen1, (v->chargingTimeStamp), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 69))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->chargeInformation) = (ChargeInformation*) Asn1Alloc (sizeof (ChargeInformation));
    CheckAsn1Alloc ((v->chargeInformation), env);
    BDecChargeInformationContent (b, tagId1, elmtLen1, (v->chargeInformation), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 37))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->basicServiceCodeList) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->basicServiceCodeList), env);
    BDecBasicServiceCodeListContent (b, tagId1, elmtLen1, (v->basicServiceCodeList), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -283);
    }


    if (!seqDone)
        longjmp (env, -284);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSupplServiceUsedContent */

void
PrintSupplServiceUsed PARAMS ((f, v, indent),
FILE* f _AND_
SupplServiceUsed *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (ASNOCTS_PRESENT ((&v->supplServiceCode)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"supplServiceCode ");
    PrintSupplServiceCode (f, (&v->supplServiceCode), indent + stdIndentG);
    }
    if (NOT_NULL ((v->supplServiceActionCode)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"supplServiceActionCode ");
    PrintSupplServiceActionCode (f, (v->supplServiceActionCode), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->ssParameters)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"ssParameters ");
    PrintSsParameters (f, (&v->ssParameters), indent + stdIndentG);
    }
    if (NOT_NULL ((v->chargingTimeStamp)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"chargingTimeStamp ");
    PrintChargingTimeStamp (f, (v->chargingTimeStamp), indent + stdIndentG);
    }
    if (NOT_NULL ((v->chargeInformation)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"chargeInformation ");
    PrintChargeInformation (f, (v->chargeInformation), indent + stdIndentG);
    }
    if (NOT_NULL ((v->basicServiceCodeList)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"basicServiceCodeList ");
    PrintBasicServiceCodeList (f, (v->basicServiceCodeList), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintSupplServiceUsed */

void
FreeSupplServiceUsed PARAMS ((v),
SupplServiceUsed *v)
{

    if (v == NULL)
        return;
    if (ASNOCTS_PRESENT ((&v->supplServiceCode)))
    {
    FreeSupplServiceCode ((&v->supplServiceCode));
    }

    if (NOT_NULL ((v->supplServiceActionCode)))
    {
    FreeSupplServiceActionCode ((v->supplServiceActionCode));
    Asn1Free ((v->supplServiceActionCode));
    }

    if (ASNOCTS_PRESENT ((&v->ssParameters)))
    {
    FreeSsParameters ((&v->ssParameters));
    }

    if (NOT_NULL ((v->chargingTimeStamp)))
    {
    FreeChargingTimeStamp ((v->chargingTimeStamp));
    Asn1Free ((v->chargingTimeStamp));
    }

    if (NOT_NULL ((v->chargeInformation)))
    {
    FreeChargeInformation ((v->chargeInformation));
    Asn1Free ((v->chargeInformation));
    }

    if (NOT_NULL ((v->basicServiceCodeList)))
    {
    FreeBasicServiceCodeList ((v->basicServiceCodeList));
    Asn1Free ((v->basicServiceCodeList));
    }

}  /* FreeSupplServiceUsed */




AsnLen
BEncSupplServiceEventContent PARAMS ((b, v),
BUF_TYPE b _AND_
SupplServiceEvent *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->operatorSpecInformation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncOperatorSpecInfoListContent (b, (v->operatorSpecInformation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 162);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->supplServiceUsed)))
    {
    BEncEocIfNec (b);
    itemLen = BEncSupplServiceUsedContent (b, (v->supplServiceUsed));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 206);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->equipmentIdentifier)))
    {
    BEncEocIfNec (b);
    itemLen = BEncImeiOrEsnContent (b, (v->equipmentIdentifier));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 429);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->locationInformation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncLocationInformationContent (b, (v->locationInformation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 138);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->rapFileSequenceNumber)))
    {
    itemLen = BEncRapFileSequenceNumberContent (b, (&v->rapFileSequenceNumber));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 181);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->chargeableSubscriber)))
    {
    BEncEocIfNec (b);
    itemLen = BEncChargeableSubscriberContent (b, (v->chargeableSubscriber));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 427);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncSupplServiceEventContent */

void
BDecSupplServiceEventContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SupplServiceEvent *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 427))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->chargeableSubscriber) = (ChargeableSubscriber*) Asn1Alloc (sizeof (ChargeableSubscriber));
    CheckAsn1Alloc ((v->chargeableSubscriber), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecChargeableSubscriberContent (b, tagId2, elmtLen2, (v->chargeableSubscriber), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    /*if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);*/
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 181)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 181))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecRapFileSequenceNumberContent (b, tagId1, elmtLen1, (&v->rapFileSequenceNumber), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 138))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->locationInformation) = (LocationInformation*) Asn1Alloc (sizeof (LocationInformation));
    CheckAsn1Alloc ((v->locationInformation), env);
    BDecLocationInformationContent (b, tagId1, elmtLen1, (v->locationInformation), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 429))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->equipmentIdentifier) = (ImeiOrEsn*) Asn1Alloc (sizeof (ImeiOrEsn));
    CheckAsn1Alloc ((v->equipmentIdentifier), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecImeiOrEsnContent (b, tagId2, elmtLen2, (v->equipmentIdentifier), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    /*if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);*/
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 206))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->supplServiceUsed) = (SupplServiceUsed*) Asn1Alloc (sizeof (SupplServiceUsed));
    CheckAsn1Alloc ((v->supplServiceUsed), env);
    BDecSupplServiceUsedContent (b, tagId1, elmtLen1, (v->supplServiceUsed), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 162))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->operatorSpecInformation) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->operatorSpecInformation), env);
    BDecOperatorSpecInfoListContent (b, tagId1, elmtLen1, (v->operatorSpecInformation), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -285);
    }


    if (!seqDone)
        longjmp (env, -286);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSupplServiceEventContent */

void
PrintSupplServiceEvent PARAMS ((f, v, indent),
FILE* f _AND_
SupplServiceEvent *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->chargeableSubscriber)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"chargeableSubscriber ");
    PrintChargeableSubscriber (f, (v->chargeableSubscriber), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->rapFileSequenceNumber)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"rapFileSequenceNumber ");
    PrintRapFileSequenceNumber (f, (&v->rapFileSequenceNumber), indent + stdIndentG);
    }
    if (NOT_NULL ((v->locationInformation)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"locationInformation ");
    PrintLocationInformation (f, (v->locationInformation), indent + stdIndentG);
    }
    if (NOT_NULL ((v->equipmentIdentifier)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"equipmentIdentifier ");
    PrintImeiOrEsn (f, (v->equipmentIdentifier), indent + stdIndentG);
    }
    if (NOT_NULL ((v->supplServiceUsed)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"supplServiceUsed ");
    PrintSupplServiceUsed (f, (v->supplServiceUsed), indent + stdIndentG);
    }
    if (NOT_NULL ((v->operatorSpecInformation)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"operatorSpecInformation ");
    PrintOperatorSpecInfoList (f, (v->operatorSpecInformation), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintSupplServiceEvent */

void
FreeSupplServiceEvent PARAMS ((v),
SupplServiceEvent *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->chargeableSubscriber)))
    {
    FreeChargeableSubscriber ((v->chargeableSubscriber));
    Asn1Free ((v->chargeableSubscriber));
    }

    if (ASNOCTS_PRESENT ((&v->rapFileSequenceNumber)))
    {
    FreeRapFileSequenceNumber ((&v->rapFileSequenceNumber));
    }

    if (NOT_NULL ((v->locationInformation)))
    {
    FreeLocationInformation ((v->locationInformation));
    Asn1Free ((v->locationInformation));
    }

    if (NOT_NULL ((v->equipmentIdentifier)))
    {
    FreeImeiOrEsn ((v->equipmentIdentifier));
    Asn1Free ((v->equipmentIdentifier));
    }

    if (NOT_NULL ((v->supplServiceUsed)))
    {
    FreeSupplServiceUsed ((v->supplServiceUsed));
    Asn1Free ((v->supplServiceUsed));
    }

    if (NOT_NULL ((v->operatorSpecInformation)))
    {
    FreeOperatorSpecInfoList ((v->operatorSpecInformation));
    Asn1Free ((v->operatorSpecInformation));
    }

}  /* FreeSupplServiceEvent */




AsnLen
BEncServiceCentreUsageContent PARAMS ((b, v),
BUF_TYPE b _AND_
ServiceCentreUsage *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->operatorSpecInformation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncOperatorSpecInfoListContent (b, (v->operatorSpecInformation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 162);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->scuTimeStamps)))
    {
    BEncEocIfNec (b);
    itemLen = BEncScuTimeStampsContent (b, (v->scuTimeStamps));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 193);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->scuChargeType)))
    {
    BEncEocIfNec (b);
    itemLen = BEncScuChargeTypeContent (b, (v->scuChargeType));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 192);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->chargeInformation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncChargeInformationContent (b, (v->chargeInformation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 69);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->recEntityCode)))
    {
    itemLen = BEncRecEntityCodeContent (b, (v->recEntityCode));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 184);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->servingNetwork)))
    {
    itemLen = BEncServingNetworkContent (b, (&v->servingNetwork));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 195);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->rapFileSequenceNumber)))
    {
    itemLen = BEncRapFileSequenceNumberContent (b, (&v->rapFileSequenceNumber));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 181);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->basicInformation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncScuBasicInformationContent (b, (v->basicInformation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 191);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncServiceCentreUsageContent */

void
BDecServiceCentreUsageContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ServiceCentreUsage *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 191))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->basicInformation) = (ScuBasicInformation*) Asn1Alloc (sizeof (ScuBasicInformation));
    CheckAsn1Alloc ((v->basicInformation), env);
    BDecScuBasicInformationContent (b, tagId1, elmtLen1, (v->basicInformation), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 181)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 181))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecRapFileSequenceNumberContent (b, tagId1, elmtLen1, (&v->rapFileSequenceNumber), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 195)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 195))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecServingNetworkContent (b, tagId1, elmtLen1, (&v->servingNetwork), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 184))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->recEntityCode) = (RecEntityCode*) Asn1Alloc (sizeof (RecEntityCode));
    CheckAsn1Alloc ((v->recEntityCode), env);
    BDecRecEntityCodeContent (b, tagId1, elmtLen1, (v->recEntityCode), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 69))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->chargeInformation) = (ChargeInformation*) Asn1Alloc (sizeof (ChargeInformation));
    CheckAsn1Alloc ((v->chargeInformation), env);
    BDecChargeInformationContent (b, tagId1, elmtLen1, (v->chargeInformation), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 192))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->scuChargeType) = (ScuChargeType*) Asn1Alloc (sizeof (ScuChargeType));
    CheckAsn1Alloc ((v->scuChargeType), env);
    BDecScuChargeTypeContent (b, tagId1, elmtLen1, (v->scuChargeType), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 193))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->scuTimeStamps) = (ScuTimeStamps*) Asn1Alloc (sizeof (ScuTimeStamps));
    CheckAsn1Alloc ((v->scuTimeStamps), env);
    BDecScuTimeStampsContent (b, tagId1, elmtLen1, (v->scuTimeStamps), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 162))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->operatorSpecInformation) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->operatorSpecInformation), env);
    BDecOperatorSpecInfoListContent (b, tagId1, elmtLen1, (v->operatorSpecInformation), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -287);
    }


    if (!seqDone)
        longjmp (env, -288);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecServiceCentreUsageContent */

void
PrintServiceCentreUsage PARAMS ((f, v, indent),
FILE* f _AND_
ServiceCentreUsage *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->basicInformation)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"basicInformation ");
    PrintScuBasicInformation (f, (v->basicInformation), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->rapFileSequenceNumber)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"rapFileSequenceNumber ");
    PrintRapFileSequenceNumber (f, (&v->rapFileSequenceNumber), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->servingNetwork)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"servingNetwork ");
    PrintServingNetwork (f, (&v->servingNetwork), indent + stdIndentG);
    }
    if (NOT_NULL ((v->recEntityCode)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"recEntityCode ");
    PrintRecEntityCode (f, (v->recEntityCode), indent + stdIndentG);
    }
    if (NOT_NULL ((v->chargeInformation)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"chargeInformation ");
    PrintChargeInformation (f, (v->chargeInformation), indent + stdIndentG);
    }
    if (NOT_NULL ((v->scuChargeType)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"scuChargeType ");
    PrintScuChargeType (f, (v->scuChargeType), indent + stdIndentG);
    }
    if (NOT_NULL ((v->scuTimeStamps)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"scuTimeStamps ");
    PrintScuTimeStamps (f, (v->scuTimeStamps), indent + stdIndentG);
    }
    if (NOT_NULL ((v->operatorSpecInformation)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"operatorSpecInformation ");
    PrintOperatorSpecInfoList (f, (v->operatorSpecInformation), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintServiceCentreUsage */

void
FreeServiceCentreUsage PARAMS ((v),
ServiceCentreUsage *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->basicInformation)))
    {
    FreeScuBasicInformation ((v->basicInformation));
    Asn1Free ((v->basicInformation));
    }

    if (ASNOCTS_PRESENT ((&v->rapFileSequenceNumber)))
    {
    FreeRapFileSequenceNumber ((&v->rapFileSequenceNumber));
    }

    if (ASNOCTS_PRESENT ((&v->servingNetwork)))
    {
    FreeServingNetwork ((&v->servingNetwork));
    }

    if (NOT_NULL ((v->recEntityCode)))
    {
    FreeRecEntityCode ((v->recEntityCode));
    Asn1Free ((v->recEntityCode));
    }

    if (NOT_NULL ((v->chargeInformation)))
    {
    FreeChargeInformation ((v->chargeInformation));
    Asn1Free ((v->chargeInformation));
    }

    if (NOT_NULL ((v->scuChargeType)))
    {
    FreeScuChargeType ((v->scuChargeType));
    Asn1Free ((v->scuChargeType));
    }

    if (NOT_NULL ((v->scuTimeStamps)))
    {
    FreeScuTimeStamps ((v->scuTimeStamps));
    Asn1Free ((v->scuTimeStamps));
    }

    if (NOT_NULL ((v->operatorSpecInformation)))
    {
    FreeOperatorSpecInfoList ((v->operatorSpecInformation));
    Asn1Free ((v->operatorSpecInformation));
    }

}  /* FreeServiceCentreUsage */




AsnLen
BEncGprsCallContent PARAMS ((b, v),
BUF_TYPE b _AND_
GprsCall *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->operatorSpecInformation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncOperatorSpecInfoListContent (b, (v->operatorSpecInformation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 162);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->camelServiceUsed)))
    {
    BEncEocIfNec (b);
    itemLen = BEncCamelServiceUsedContent (b, (v->camelServiceUsed));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 57);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->gprsServiceUsed)))
    {
    BEncEocIfNec (b);
    itemLen = BEncGprsServiceUsedContent (b, (v->gprsServiceUsed));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 121);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->equipmentIdentifier)))
    {
    BEncEocIfNec (b);
    itemLen = BEncImeiOrEsnContent (b, (v->equipmentIdentifier));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 429);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->gprsLocationInformation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncGprsLocationInformationContent (b, (v->gprsLocationInformation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 117);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->gprsBasicCallInformation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncGprsBasicCallInformationContent (b, (v->gprsBasicCallInformation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 114);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncGprsCallContent */

void
BDecGprsCallContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GprsCall *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 114))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->gprsBasicCallInformation) = (GprsBasicCallInformation*) Asn1Alloc (sizeof (GprsBasicCallInformation));
    CheckAsn1Alloc ((v->gprsBasicCallInformation), env);
    BDecGprsBasicCallInformationContent (b, tagId1, elmtLen1, (v->gprsBasicCallInformation), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 117))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->gprsLocationInformation) = (GprsLocationInformation*) Asn1Alloc (sizeof (GprsLocationInformation));
    CheckAsn1Alloc ((v->gprsLocationInformation), env);
    BDecGprsLocationInformationContent (b, tagId1, elmtLen1, (v->gprsLocationInformation), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 429))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->equipmentIdentifier) = (ImeiOrEsn*) Asn1Alloc (sizeof (ImeiOrEsn));
    CheckAsn1Alloc ((v->equipmentIdentifier), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecImeiOrEsnContent (b, tagId2, elmtLen2, (v->equipmentIdentifier), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    /*if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);*/
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 121))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->gprsServiceUsed) = (GprsServiceUsed*) Asn1Alloc (sizeof (GprsServiceUsed));
    CheckAsn1Alloc ((v->gprsServiceUsed), env);
    BDecGprsServiceUsedContent (b, tagId1, elmtLen1, (v->gprsServiceUsed), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 57))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->camelServiceUsed) = (CamelServiceUsed*) Asn1Alloc (sizeof (CamelServiceUsed));
    CheckAsn1Alloc ((v->camelServiceUsed), env);
    BDecCamelServiceUsedContent (b, tagId1, elmtLen1, (v->camelServiceUsed), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 162))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->operatorSpecInformation) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->operatorSpecInformation), env);
    BDecOperatorSpecInfoListContent (b, tagId1, elmtLen1, (v->operatorSpecInformation), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -289);
    }


    if (!seqDone)
        longjmp (env, -290);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGprsCallContent */

void
PrintGprsCall PARAMS ((f, v, indent),
FILE* f _AND_
GprsCall *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->gprsBasicCallInformation)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"gprsBasicCallInformation ");
    PrintGprsBasicCallInformation (f, (v->gprsBasicCallInformation), indent + stdIndentG);
    }
    if (NOT_NULL ((v->gprsLocationInformation)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"gprsLocationInformation ");
    PrintGprsLocationInformation (f, (v->gprsLocationInformation), indent + stdIndentG);
    }
    if (NOT_NULL ((v->equipmentIdentifier)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"equipmentIdentifier ");
    PrintImeiOrEsn (f, (v->equipmentIdentifier), indent + stdIndentG);
    }
    if (NOT_NULL ((v->gprsServiceUsed)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"gprsServiceUsed ");
    PrintGprsServiceUsed (f, (v->gprsServiceUsed), indent + stdIndentG);
    }
    if (NOT_NULL ((v->camelServiceUsed)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"camelServiceUsed ");
    PrintCamelServiceUsed (f, (v->camelServiceUsed), indent + stdIndentG);
    }
    if (NOT_NULL ((v->operatorSpecInformation)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"operatorSpecInformation ");
    PrintOperatorSpecInfoList (f, (v->operatorSpecInformation), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintGprsCall */

void
FreeGprsCall PARAMS ((v),
GprsCall *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->gprsBasicCallInformation)))
    {
    FreeGprsBasicCallInformation ((v->gprsBasicCallInformation));
    Asn1Free ((v->gprsBasicCallInformation));
    }

    if (NOT_NULL ((v->gprsLocationInformation)))
    {
    FreeGprsLocationInformation ((v->gprsLocationInformation));
    Asn1Free ((v->gprsLocationInformation));
    }

    if (NOT_NULL ((v->equipmentIdentifier)))
    {
    FreeImeiOrEsn ((v->equipmentIdentifier));
    Asn1Free ((v->equipmentIdentifier));
    }

    if (NOT_NULL ((v->gprsServiceUsed)))
    {
    FreeGprsServiceUsed ((v->gprsServiceUsed));
    Asn1Free ((v->gprsServiceUsed));
    }

    if (NOT_NULL ((v->camelServiceUsed)))
    {
    FreeCamelServiceUsed ((v->camelServiceUsed));
    Asn1Free ((v->camelServiceUsed));
    }

    if (NOT_NULL ((v->operatorSpecInformation)))
    {
    FreeOperatorSpecInfoList ((v->operatorSpecInformation));
    Asn1Free ((v->operatorSpecInformation));
    }

}  /* FreeGprsCall */




AsnLen
BEncContentTransactionContent PARAMS ((b, v),
BUF_TYPE b _AND_
ContentTransaction *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->operatorSpecInformation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncOperatorSpecInfoListContent (b, (v->operatorSpecInformation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 162);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->contentServiceUsed)))
    {
    BEncEocIfNec (b);
    itemLen = BEncContentServiceUsedListContent (b, (v->contentServiceUsed));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 285);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->servingPartiesInformation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncServingPartiesInformationContent (b, (v->servingPartiesInformation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 335);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->chargedPartyInformation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncChargedPartyInformationContent (b, (v->chargedPartyInformation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 324);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->contentTransactionBasicInfo)))
    {
    BEncEocIfNec (b);
    itemLen = BEncContentTransactionBasicInfoContent (b, (v->contentTransactionBasicInfo));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 304);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncContentTransactionContent */

void
BDecContentTransactionContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ContentTransaction *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 304))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->contentTransactionBasicInfo) = (ContentTransactionBasicInfo*) Asn1Alloc (sizeof (ContentTransactionBasicInfo));
    CheckAsn1Alloc ((v->contentTransactionBasicInfo), env);
    BDecContentTransactionBasicInfoContent (b, tagId1, elmtLen1, (v->contentTransactionBasicInfo), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 324))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->chargedPartyInformation) = (ChargedPartyInformation*) Asn1Alloc (sizeof (ChargedPartyInformation));
    CheckAsn1Alloc ((v->chargedPartyInformation), env);
    BDecChargedPartyInformationContent (b, tagId1, elmtLen1, (v->chargedPartyInformation), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 335))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->servingPartiesInformation) = (ServingPartiesInformation*) Asn1Alloc (sizeof (ServingPartiesInformation));
    CheckAsn1Alloc ((v->servingPartiesInformation), env);
    BDecServingPartiesInformationContent (b, tagId1, elmtLen1, (v->servingPartiesInformation), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 285))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->contentServiceUsed) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->contentServiceUsed), env);
    BDecContentServiceUsedListContent (b, tagId1, elmtLen1, (v->contentServiceUsed), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 162))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->operatorSpecInformation) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->operatorSpecInformation), env);
    BDecOperatorSpecInfoListContent (b, tagId1, elmtLen1, (v->operatorSpecInformation), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -291);
    }


    if (!seqDone)
        longjmp (env, -292);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecContentTransactionContent */

void
PrintContentTransaction PARAMS ((f, v, indent),
FILE* f _AND_
ContentTransaction *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->contentTransactionBasicInfo)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"contentTransactionBasicInfo ");
    PrintContentTransactionBasicInfo (f, (v->contentTransactionBasicInfo), indent + stdIndentG);
    }
    if (NOT_NULL ((v->chargedPartyInformation)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"chargedPartyInformation ");
    PrintChargedPartyInformation (f, (v->chargedPartyInformation), indent + stdIndentG);
    }
    if (NOT_NULL ((v->servingPartiesInformation)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"servingPartiesInformation ");
    PrintServingPartiesInformation (f, (v->servingPartiesInformation), indent + stdIndentG);
    }
    if (NOT_NULL ((v->contentServiceUsed)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"contentServiceUsed ");
    PrintContentServiceUsedList (f, (v->contentServiceUsed), indent + stdIndentG);
    }
    if (NOT_NULL ((v->operatorSpecInformation)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"operatorSpecInformation ");
    PrintOperatorSpecInfoList (f, (v->operatorSpecInformation), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintContentTransaction */

void
FreeContentTransaction PARAMS ((v),
ContentTransaction *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->contentTransactionBasicInfo)))
    {
    FreeContentTransactionBasicInfo ((v->contentTransactionBasicInfo));
    Asn1Free ((v->contentTransactionBasicInfo));
    }

    if (NOT_NULL ((v->chargedPartyInformation)))
    {
    FreeChargedPartyInformation ((v->chargedPartyInformation));
    Asn1Free ((v->chargedPartyInformation));
    }

    if (NOT_NULL ((v->servingPartiesInformation)))
    {
    FreeServingPartiesInformation ((v->servingPartiesInformation));
    Asn1Free ((v->servingPartiesInformation));
    }

    if (NOT_NULL ((v->contentServiceUsed)))
    {
    FreeContentServiceUsedList ((v->contentServiceUsed));
    Asn1Free ((v->contentServiceUsed));
    }

    if (NOT_NULL ((v->operatorSpecInformation)))
    {
    FreeOperatorSpecInfoList ((v->operatorSpecInformation));
    Asn1Free ((v->operatorSpecInformation));
    }

}  /* FreeContentTransaction */




AsnLen
BEncLocationServiceContent PARAMS ((b, v),
BUF_TYPE b _AND_
LocationService *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->operatorSpecInformation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncOperatorSpecInfoListContent (b, (v->operatorSpecInformation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 162);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->locationServiceUsage)))
    {
    BEncEocIfNec (b);
    itemLen = BEncLocationServiceUsageContent (b, (v->locationServiceUsage));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 382);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->trackedCustomerInformation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncTrackedCustomerInformationContent (b, (v->trackedCustomerInformation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 367);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->lCSSPInformation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncLCSSPInformationContent (b, (v->lCSSPInformation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 373);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->trackingCustomerInformation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncTrackingCustomerInformationContent (b, (v->trackingCustomerInformation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 298);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->callReference)))
    {
    itemLen = BEncCallReferenceContent (b, (&v->callReference));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, PRIM, 45);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->recEntityCode)))
    {
    itemLen = BEncRecEntityCodeContent (b, (v->recEntityCode));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 184);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->rapFileSequenceNumber)))
    {
    itemLen = BEncRapFileSequenceNumberContent (b, (&v->rapFileSequenceNumber));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 181);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncLocationServiceContent */

void
BDecLocationServiceContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
LocationService *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 181)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 181))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecRapFileSequenceNumberContent (b, tagId1, elmtLen1, (&v->rapFileSequenceNumber), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 184))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->recEntityCode) = (RecEntityCode*) Asn1Alloc (sizeof (RecEntityCode));
    CheckAsn1Alloc ((v->recEntityCode), env);
    BDecRecEntityCodeContent (b, tagId1, elmtLen1, (v->recEntityCode), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 45)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 45))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecCallReferenceContent (b, tagId1, elmtLen1, (&v->callReference), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 298))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->trackingCustomerInformation) = (TrackingCustomerInformation*) Asn1Alloc (sizeof (TrackingCustomerInformation));
    CheckAsn1Alloc ((v->trackingCustomerInformation), env);
    BDecTrackingCustomerInformationContent (b, tagId1, elmtLen1, (v->trackingCustomerInformation), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 373))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->lCSSPInformation) = (LCSSPInformation*) Asn1Alloc (sizeof (LCSSPInformation));
    CheckAsn1Alloc ((v->lCSSPInformation), env);
    BDecLCSSPInformationContent (b, tagId1, elmtLen1, (v->lCSSPInformation), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 367))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->trackedCustomerInformation) = (TrackedCustomerInformation*) Asn1Alloc (sizeof (TrackedCustomerInformation));
    CheckAsn1Alloc ((v->trackedCustomerInformation), env);
    BDecTrackedCustomerInformationContent (b, tagId1, elmtLen1, (v->trackedCustomerInformation), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 382))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->locationServiceUsage) = (LocationServiceUsage*) Asn1Alloc (sizeof (LocationServiceUsage));
    CheckAsn1Alloc ((v->locationServiceUsage), env);
    BDecLocationServiceUsageContent (b, tagId1, elmtLen1, (v->locationServiceUsage), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 162))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->operatorSpecInformation) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->operatorSpecInformation), env);
    BDecOperatorSpecInfoListContent (b, tagId1, elmtLen1, (v->operatorSpecInformation), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -293);
    }


    if (!seqDone)
        longjmp (env, -294);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecLocationServiceContent */

void
PrintLocationService PARAMS ((f, v, indent),
FILE* f _AND_
LocationService *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (ASNOCTS_PRESENT ((&v->rapFileSequenceNumber)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"rapFileSequenceNumber ");
    PrintRapFileSequenceNumber (f, (&v->rapFileSequenceNumber), indent + stdIndentG);
    }
    if (NOT_NULL ((v->recEntityCode)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"recEntityCode ");
    PrintRecEntityCode (f, (v->recEntityCode), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->callReference)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"callReference ");
    PrintCallReference (f, (&v->callReference), indent + stdIndentG);
    }
    if (NOT_NULL ((v->trackingCustomerInformation)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"trackingCustomerInformation ");
    PrintTrackingCustomerInformation (f, (v->trackingCustomerInformation), indent + stdIndentG);
    }
    if (NOT_NULL ((v->lCSSPInformation)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"lCSSPInformation ");
    PrintLCSSPInformation (f, (v->lCSSPInformation), indent + stdIndentG);
    }
    if (NOT_NULL ((v->trackedCustomerInformation)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"trackedCustomerInformation ");
    PrintTrackedCustomerInformation (f, (v->trackedCustomerInformation), indent + stdIndentG);
    }
    if (NOT_NULL ((v->locationServiceUsage)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"locationServiceUsage ");
    PrintLocationServiceUsage (f, (v->locationServiceUsage), indent + stdIndentG);
    }
    if (NOT_NULL ((v->operatorSpecInformation)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"operatorSpecInformation ");
    PrintOperatorSpecInfoList (f, (v->operatorSpecInformation), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintLocationService */

void
FreeLocationService PARAMS ((v),
LocationService *v)
{

    if (v == NULL)
        return;
    if (ASNOCTS_PRESENT ((&v->rapFileSequenceNumber)))
    {
    FreeRapFileSequenceNumber ((&v->rapFileSequenceNumber));
    }

    if (NOT_NULL ((v->recEntityCode)))
    {
    FreeRecEntityCode ((v->recEntityCode));
    Asn1Free ((v->recEntityCode));
    }

    if (ASNOCTS_PRESENT ((&v->callReference)))
    {
    FreeCallReference ((&v->callReference));
    }

    if (NOT_NULL ((v->trackingCustomerInformation)))
    {
    FreeTrackingCustomerInformation ((v->trackingCustomerInformation));
    Asn1Free ((v->trackingCustomerInformation));
    }

    if (NOT_NULL ((v->lCSSPInformation)))
    {
    FreeLCSSPInformation ((v->lCSSPInformation));
    Asn1Free ((v->lCSSPInformation));
    }

    if (NOT_NULL ((v->trackedCustomerInformation)))
    {
    FreeTrackedCustomerInformation ((v->trackedCustomerInformation));
    Asn1Free ((v->trackedCustomerInformation));
    }

    if (NOT_NULL ((v->locationServiceUsage)))
    {
    FreeLocationServiceUsage ((v->locationServiceUsage));
    Asn1Free ((v->locationServiceUsage));
    }

    if (NOT_NULL ((v->operatorSpecInformation)))
    {
    FreeOperatorSpecInfoList ((v->operatorSpecInformation));
    Asn1Free ((v->operatorSpecInformation));
    }

}  /* FreeLocationService */




AsnLen
BEncBasicServiceUsedContent PARAMS ((b, v),
BUF_TYPE b _AND_
BasicServiceUsed *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (ASNOCTS_PRESENT ((&v->hSCSDIndicator)))
    {
    itemLen = BEncHSCSDIndicatorContent (b, (&v->hSCSDIndicator));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 424);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->chargeInformationList)))
    {
    BEncEocIfNec (b);
    itemLen = BEncChargeInformationListContent (b, (v->chargeInformationList));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 70);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->chargingTimeStamp)))
    {
    BEncEocIfNec (b);
    itemLen = BEncChargingTimeStampContent (b, (v->chargingTimeStamp));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 74);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->basicService)))
    {
    BEncEocIfNec (b);
    itemLen = BEncBasicServiceContent (b, (v->basicService));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 36);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncBasicServiceUsedContent */

void
BDecBasicServiceUsedContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
BasicServiceUsed *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 36))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->basicService) = (BasicService*) Asn1Alloc (sizeof (BasicService));
    CheckAsn1Alloc ((v->basicService), env);
    BDecBasicServiceContent (b, tagId1, elmtLen1, (v->basicService), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 74))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->chargingTimeStamp) = (ChargingTimeStamp*) Asn1Alloc (sizeof (ChargingTimeStamp));
    CheckAsn1Alloc ((v->chargingTimeStamp), env);
    BDecChargingTimeStampContent (b, tagId1, elmtLen1, (v->chargingTimeStamp), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 70))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->chargeInformationList) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->chargeInformationList), env);
    BDecChargeInformationListContent (b, tagId1, elmtLen1, (v->chargeInformationList), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 424)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 424))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecHSCSDIndicatorContent (b, tagId1, elmtLen1, (&v->hSCSDIndicator), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -295);
    }


    if (!seqDone)
        longjmp (env, -296);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecBasicServiceUsedContent */

void
PrintBasicServiceUsed PARAMS ((f, v, indent),
FILE* f _AND_
BasicServiceUsed *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->basicService)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"basicService ");
    PrintBasicService (f, (v->basicService), indent + stdIndentG);
    }
    if (NOT_NULL ((v->chargingTimeStamp)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"chargingTimeStamp ");
    PrintChargingTimeStamp (f, (v->chargingTimeStamp), indent + stdIndentG);
    }
    if (NOT_NULL ((v->chargeInformationList)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"chargeInformationList ");
    PrintChargeInformationList (f, (v->chargeInformationList), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->hSCSDIndicator)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"hSCSDIndicator ");
    PrintHSCSDIndicator (f, (&v->hSCSDIndicator), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintBasicServiceUsed */

void
FreeBasicServiceUsed PARAMS ((v),
BasicServiceUsed *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->basicService)))
    {
    FreeBasicService ((v->basicService));
    Asn1Free ((v->basicService));
    }

    if (NOT_NULL ((v->chargingTimeStamp)))
    {
    FreeChargingTimeStamp ((v->chargingTimeStamp));
    Asn1Free ((v->chargingTimeStamp));
    }

    if (NOT_NULL ((v->chargeInformationList)))
    {
    FreeChargeInformationList ((v->chargeInformationList));
    Asn1Free ((v->chargeInformationList));
    }

    if (ASNOCTS_PRESENT ((&v->hSCSDIndicator)))
    {
    FreeHSCSDIndicator ((&v->hSCSDIndicator));
    }

}  /* FreeBasicServiceUsed */




AsnLen
BEncBasicServiceUsedListContent PARAMS ((b, v),
BUF_TYPE b _AND_
BasicServiceUsedList *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    BEncEocIfNec (b);
    itemLen = BEncBasicServiceUsedContent (b, component);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 39);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncBasicServiceUsedListContent */

void
BDecBasicServiceUsedListContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
BasicServiceUsedList *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        BasicServiceUsed **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (APPL, CONS, 39)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (BasicServiceUsed**) AsnListAppend (v);
    (*tmpVar) = (BasicServiceUsed*) Asn1Alloc (sizeof (BasicServiceUsed));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecBasicServiceUsedContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -297);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecBasicServiceUsedListContent */

void
PrintBasicServiceUsedList PARAMS ((f, v, indent),
FILE* f _AND_
BasicServiceUsedList *v _AND_
unsigned short int indent)
{
    BasicServiceUsed *tmp;
    if (v == NULL)
        return;
    fprintf (f,"{ -- SEQUENCE OF -- \n");
    FOR_EACH_LIST_ELMT (tmp, v)
    {
        Indent (f, indent+ stdIndentG);
        PrintBasicServiceUsed (f, tmp, indent + stdIndentG);
        if (tmp != (BasicServiceUsed*)LAST_LIST_ELMT (v))
            fprintf (f,",\n");
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintBasicServiceUsedList */

void
FreeBasicServiceUsedList PARAMS ((v),
BasicServiceUsedList *v)
{

    AsnListNode *l;
    AsnListNode *tmp;
    if (v == NULL)
        return;
    for (l = FIRST_LIST_NODE (v); l != NULL; )
    {
        FreeBasicServiceUsed ((l->data));
        tmp = l->next;
        Asn1Free (l->data);
        Asn1Free (l);
        l = tmp;
    }
}  /* FreeBasicServiceUsedList */




AsnLen
BEncSessionChargeInfoListContent PARAMS ((b, v),
BUF_TYPE b _AND_
SessionChargeInfoList *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    BEncEocIfNec (b);
    itemLen = BEncSessionChargeInformationContent (b, component);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 449);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncSessionChargeInfoListContent */

void
BDecSessionChargeInfoListContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SessionChargeInfoList *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        SessionChargeInformation **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (APPL, CONS, 449)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (SessionChargeInformation**) AsnListAppend (v);
    (*tmpVar) = (SessionChargeInformation*) Asn1Alloc (sizeof (SessionChargeInformation));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecSessionChargeInformationContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -298);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSessionChargeInfoListContent */

void
PrintSessionChargeInfoList PARAMS ((f, v, indent),
FILE* f _AND_
SessionChargeInfoList *v _AND_
unsigned short int indent)
{
    SessionChargeInformation *tmp;
    if (v == NULL)
        return;
    fprintf (f,"{ -- SEQUENCE OF -- \n");
    FOR_EACH_LIST_ELMT (tmp, v)
    {
        Indent (f, indent+ stdIndentG);
        PrintSessionChargeInformation (f, tmp, indent + stdIndentG);
        if (tmp != (SessionChargeInformation*)LAST_LIST_ELMT (v))
            fprintf (f,",\n");
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintSessionChargeInfoList */

void
FreeSessionChargeInfoList PARAMS ((v),
SessionChargeInfoList *v)
{

    AsnListNode *l;
    AsnListNode *tmp;
    if (v == NULL)
        return;
    for (l = FIRST_LIST_NODE (v); l != NULL; )
    {
        FreeSessionChargeInformation ((l->data));
        tmp = l->next;
        Asn1Free (l->data);
        Asn1Free (l);
        l = tmp;
    }
}  /* FreeSessionChargeInfoList */




AsnLen
BEncMobileOriginatedCallContent PARAMS ((b, v),
BUF_TYPE b _AND_
MobileOriginatedCall *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->operatorSpecInformation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncOperatorSpecInfoListContent (b, (v->operatorSpecInformation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 162);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->camelServiceUsed)))
    {
    BEncEocIfNec (b);
    itemLen = BEncCamelServiceUsedContent (b, (v->camelServiceUsed));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 57);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->thirdPartyInformation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncThirdPartyInformationContent (b, (v->thirdPartyInformation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 219);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->supplServiceCode)))
    {
    itemLen = BEncSupplServiceCodeContent (b, (&v->supplServiceCode));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 209);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->basicServiceUsedList)))
    {
    BEncEocIfNec (b);
    itemLen = BEncBasicServiceUsedListContent (b, (v->basicServiceUsedList));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 38);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->equipmentIdentifier)))
    {
    BEncEocIfNec (b);
    itemLen = BEncImeiOrEsnContent (b, (v->equipmentIdentifier));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 429);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->locationInformation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncLocationInformationContent (b, (v->locationInformation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 138);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->basicCallInformation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncMoBasicCallInformationContent (b, (v->basicCallInformation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 147);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncMobileOriginatedCallContent */

void
BDecMobileOriginatedCallContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
MobileOriginatedCall *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 147))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->basicCallInformation) = (MoBasicCallInformation*) Asn1Alloc (sizeof (MoBasicCallInformation));
    CheckAsn1Alloc ((v->basicCallInformation), env);
    BDecMoBasicCallInformationContent (b, tagId1, elmtLen1, (v->basicCallInformation), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 138))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->locationInformation) = (LocationInformation*) Asn1Alloc (sizeof (LocationInformation));
    CheckAsn1Alloc ((v->locationInformation), env);
    BDecLocationInformationContent (b, tagId1, elmtLen1, (v->locationInformation), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 429))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->equipmentIdentifier) = (ImeiOrEsn*) Asn1Alloc (sizeof (ImeiOrEsn));
    CheckAsn1Alloc ((v->equipmentIdentifier), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecImeiOrEsnContent (b, tagId2, elmtLen2, (v->equipmentIdentifier), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    /*if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);*/
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 38))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->basicServiceUsedList) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->basicServiceUsedList), env);
    BDecBasicServiceUsedListContent (b, tagId1, elmtLen1, (v->basicServiceUsedList), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 209)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 209))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecSupplServiceCodeContent (b, tagId1, elmtLen1, (&v->supplServiceCode), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 219))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->thirdPartyInformation) = (ThirdPartyInformation*) Asn1Alloc (sizeof (ThirdPartyInformation));
    CheckAsn1Alloc ((v->thirdPartyInformation), env);
    BDecThirdPartyInformationContent (b, tagId1, elmtLen1, (v->thirdPartyInformation), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 57))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->camelServiceUsed) = (CamelServiceUsed*) Asn1Alloc (sizeof (CamelServiceUsed));
    CheckAsn1Alloc ((v->camelServiceUsed), env);
    BDecCamelServiceUsedContent (b, tagId1, elmtLen1, (v->camelServiceUsed), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 162))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->operatorSpecInformation) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->operatorSpecInformation), env);
    BDecOperatorSpecInfoListContent (b, tagId1, elmtLen1, (v->operatorSpecInformation), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -299);
    }


    if (!seqDone)
        longjmp (env, -300);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecMobileOriginatedCallContent */

void
PrintMobileOriginatedCall PARAMS ((f, v, indent),
FILE* f _AND_
MobileOriginatedCall *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->basicCallInformation)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"basicCallInformation ");
    PrintMoBasicCallInformation (f, (v->basicCallInformation), indent + stdIndentG);
    }
    if (NOT_NULL ((v->locationInformation)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"locationInformation ");
    PrintLocationInformation (f, (v->locationInformation), indent + stdIndentG);
    }
    if (NOT_NULL ((v->equipmentIdentifier)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"equipmentIdentifier ");
    PrintImeiOrEsn (f, (v->equipmentIdentifier), indent + stdIndentG);
    }
    if (NOT_NULL ((v->basicServiceUsedList)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"basicServiceUsedList ");
    PrintBasicServiceUsedList (f, (v->basicServiceUsedList), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->supplServiceCode)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"supplServiceCode ");
    PrintSupplServiceCode (f, (&v->supplServiceCode), indent + stdIndentG);
    }
    if (NOT_NULL ((v->thirdPartyInformation)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"thirdPartyInformation ");
    PrintThirdPartyInformation (f, (v->thirdPartyInformation), indent + stdIndentG);
    }
    if (NOT_NULL ((v->camelServiceUsed)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"camelServiceUsed ");
    PrintCamelServiceUsed (f, (v->camelServiceUsed), indent + stdIndentG);
    }
    if (NOT_NULL ((v->operatorSpecInformation)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"operatorSpecInformation ");
    PrintOperatorSpecInfoList (f, (v->operatorSpecInformation), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintMobileOriginatedCall */

void
FreeMobileOriginatedCall PARAMS ((v),
MobileOriginatedCall *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->basicCallInformation)))
    {
    FreeMoBasicCallInformation ((v->basicCallInformation));
    Asn1Free ((v->basicCallInformation));
    }

    if (NOT_NULL ((v->locationInformation)))
    {
    FreeLocationInformation ((v->locationInformation));
    Asn1Free ((v->locationInformation));
    }

    if (NOT_NULL ((v->equipmentIdentifier)))
    {
    FreeImeiOrEsn ((v->equipmentIdentifier));
    Asn1Free ((v->equipmentIdentifier));
    }

    if (NOT_NULL ((v->basicServiceUsedList)))
    {
    FreeBasicServiceUsedList ((v->basicServiceUsedList));
    Asn1Free ((v->basicServiceUsedList));
    }

    if (ASNOCTS_PRESENT ((&v->supplServiceCode)))
    {
    FreeSupplServiceCode ((&v->supplServiceCode));
    }

    if (NOT_NULL ((v->thirdPartyInformation)))
    {
    FreeThirdPartyInformation ((v->thirdPartyInformation));
    Asn1Free ((v->thirdPartyInformation));
    }

    if (NOT_NULL ((v->camelServiceUsed)))
    {
    FreeCamelServiceUsed ((v->camelServiceUsed));
    Asn1Free ((v->camelServiceUsed));
    }

    if (NOT_NULL ((v->operatorSpecInformation)))
    {
    FreeOperatorSpecInfoList ((v->operatorSpecInformation));
    Asn1Free ((v->operatorSpecInformation));
    }

}  /* FreeMobileOriginatedCall */




AsnLen
BEncMobileTerminatedCallContent PARAMS ((b, v),
BUF_TYPE b _AND_
MobileTerminatedCall *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->operatorSpecInformation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncOperatorSpecInfoListContent (b, (v->operatorSpecInformation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 162);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->camelServiceUsed)))
    {
    BEncEocIfNec (b);
    itemLen = BEncCamelServiceUsedContent (b, (v->camelServiceUsed));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 57);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->basicServiceUsedList)))
    {
    BEncEocIfNec (b);
    itemLen = BEncBasicServiceUsedListContent (b, (v->basicServiceUsedList));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 38);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->equipmentIdentifier)))
    {
    BEncEocIfNec (b);
    itemLen = BEncImeiOrEsnContent (b, (v->equipmentIdentifier));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 429);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->locationInformation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncLocationInformationContent (b, (v->locationInformation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 138);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->basicCallInformation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncMtBasicCallInformationContent (b, (v->basicCallInformation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 153);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncMobileTerminatedCallContent */

void
BDecMobileTerminatedCallContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
MobileTerminatedCall *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 153))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->basicCallInformation) = (MtBasicCallInformation*) Asn1Alloc (sizeof (MtBasicCallInformation));
    CheckAsn1Alloc ((v->basicCallInformation), env);
    BDecMtBasicCallInformationContent (b, tagId1, elmtLen1, (v->basicCallInformation), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 138))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->locationInformation) = (LocationInformation*) Asn1Alloc (sizeof (LocationInformation));
    CheckAsn1Alloc ((v->locationInformation), env);
    BDecLocationInformationContent (b, tagId1, elmtLen1, (v->locationInformation), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 429))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->equipmentIdentifier) = (ImeiOrEsn*) Asn1Alloc (sizeof (ImeiOrEsn));
    CheckAsn1Alloc ((v->equipmentIdentifier), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecImeiOrEsnContent (b, tagId2, elmtLen2, (v->equipmentIdentifier), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    /*if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);*/
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 38))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->basicServiceUsedList) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->basicServiceUsedList), env);
    BDecBasicServiceUsedListContent (b, tagId1, elmtLen1, (v->basicServiceUsedList), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 57))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->camelServiceUsed) = (CamelServiceUsed*) Asn1Alloc (sizeof (CamelServiceUsed));
    CheckAsn1Alloc ((v->camelServiceUsed), env);
    BDecCamelServiceUsedContent (b, tagId1, elmtLen1, (v->camelServiceUsed), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 162))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->operatorSpecInformation) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->operatorSpecInformation), env);
    BDecOperatorSpecInfoListContent (b, tagId1, elmtLen1, (v->operatorSpecInformation), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -301);
    }


    if (!seqDone)
        longjmp (env, -302);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecMobileTerminatedCallContent */

void
PrintMobileTerminatedCall PARAMS ((f, v, indent),
FILE* f _AND_
MobileTerminatedCall *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->basicCallInformation)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"basicCallInformation ");
    PrintMtBasicCallInformation (f, (v->basicCallInformation), indent + stdIndentG);
    }
    if (NOT_NULL ((v->locationInformation)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"locationInformation ");
    PrintLocationInformation (f, (v->locationInformation), indent + stdIndentG);
    }
    if (NOT_NULL ((v->equipmentIdentifier)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"equipmentIdentifier ");
    PrintImeiOrEsn (f, (v->equipmentIdentifier), indent + stdIndentG);
    }
    if (NOT_NULL ((v->basicServiceUsedList)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"basicServiceUsedList ");
    PrintBasicServiceUsedList (f, (v->basicServiceUsedList), indent + stdIndentG);
    }
    if (NOT_NULL ((v->camelServiceUsed)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"camelServiceUsed ");
    PrintCamelServiceUsed (f, (v->camelServiceUsed), indent + stdIndentG);
    }
    if (NOT_NULL ((v->operatorSpecInformation)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"operatorSpecInformation ");
    PrintOperatorSpecInfoList (f, (v->operatorSpecInformation), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintMobileTerminatedCall */

void
FreeMobileTerminatedCall PARAMS ((v),
MobileTerminatedCall *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->basicCallInformation)))
    {
    FreeMtBasicCallInformation ((v->basicCallInformation));
    Asn1Free ((v->basicCallInformation));
    }

    if (NOT_NULL ((v->locationInformation)))
    {
    FreeLocationInformation ((v->locationInformation));
    Asn1Free ((v->locationInformation));
    }

    if (NOT_NULL ((v->equipmentIdentifier)))
    {
    FreeImeiOrEsn ((v->equipmentIdentifier));
    Asn1Free ((v->equipmentIdentifier));
    }

    if (NOT_NULL ((v->basicServiceUsedList)))
    {
    FreeBasicServiceUsedList ((v->basicServiceUsedList));
    Asn1Free ((v->basicServiceUsedList));
    }

    if (NOT_NULL ((v->camelServiceUsed)))
    {
    FreeCamelServiceUsed ((v->camelServiceUsed));
    Asn1Free ((v->camelServiceUsed));
    }

    if (NOT_NULL ((v->operatorSpecInformation)))
    {
    FreeOperatorSpecInfoList ((v->operatorSpecInformation));
    Asn1Free ((v->operatorSpecInformation));
    }

}  /* FreeMobileTerminatedCall */




AsnLen
BEncMobileSessionContent PARAMS ((b, v),
BUF_TYPE b _AND_
MobileSession *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->operatorSpecInformation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncOperatorSpecInfoListContent (b, (v->operatorSpecInformation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 162);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->sessionChargeInfoList)))
    {
    BEncEocIfNec (b);
    itemLen = BEncSessionChargeInfoListContent (b, (v->sessionChargeInfoList));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 448);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->nonChargedParty)))
    {
    BEncEocIfNec (b);
    itemLen = BEncNonChargedPartyContent (b, (v->nonChargedParty));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 443);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->totalCallEventDuration)))
    {
    itemLen = BEncTotalCallEventDurationContent (b, (v->totalCallEventDuration));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 223);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->causeForTerm)))
    {
    itemLen = BEncCauseForTermContent (b, (v->causeForTerm));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, APPL, PRIM, 58);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->serviceStartTimestamp)))
    {
    BEncEocIfNec (b);
    itemLen = BEncServiceStartTimestampContent (b, (v->serviceStartTimestamp));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 447);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->recEntityCodeList)))
    {
    BEncEocIfNec (b);
    itemLen = BEncRecEntityCodeListContent (b, (v->recEntityCodeList));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 185);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->eventReference)))
    {
    itemLen = BEncEventReferenceContent (b, (&v->eventReference));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 435);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->cellId)))
    {
    itemLen = BEncCellIdContent (b, (v->cellId));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, APPL, PRIM, 59);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->locationArea)))
    {
    itemLen = BEncLocationAreaContent (b, (v->locationArea));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 136);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->geographicalLocation)))
    {
    BEncEocIfNec (b);
    itemLen = BEncGeographicalLocationContent (b, (v->geographicalLocation));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, APPL, CONS, 113);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->simToolkitIndicator)))
    {
    itemLen = BEncSimToolkitIndicatorContent (b, (&v->simToolkitIndicator));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 200);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->rapFileSequenceNumber)))
    {
    itemLen = BEncRapFileSequenceNumberContent (b, (&v->rapFileSequenceNumber));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, PRIM, 181);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->chargedParty)))
    {
    BEncEocIfNec (b);
    itemLen = BEncChargedPartyContent (b, (v->chargedParty));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 436);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->mobileSessionService)))
    {
    itemLen = BEncMobileSessionServiceContent (b, (v->mobileSessionService));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag3 (b, APPL, PRIM, 440);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncMobileSessionContent */

void
BDecMobileSessionContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
MobileSession *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 440))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->mobileSessionService) = (MobileSessionService*) Asn1Alloc (sizeof (MobileSessionService));
    CheckAsn1Alloc ((v->mobileSessionService), env);
    BDecMobileSessionServiceContent (b, tagId1, elmtLen1, (v->mobileSessionService), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 436))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->chargedParty) = (ChargedParty*) Asn1Alloc (sizeof (ChargedParty));
    CheckAsn1Alloc ((v->chargedParty), env);
    BDecChargedPartyContent (b, tagId1, elmtLen1, (v->chargedParty), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 181)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 181))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecRapFileSequenceNumberContent (b, tagId1, elmtLen1, (&v->rapFileSequenceNumber), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 200)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 200))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecSimToolkitIndicatorContent (b, tagId1, elmtLen1, (&v->simToolkitIndicator), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 113))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->geographicalLocation) = (GeographicalLocation*) Asn1Alloc (sizeof (GeographicalLocation));
    CheckAsn1Alloc ((v->geographicalLocation), env);
    BDecGeographicalLocationContent (b, tagId1, elmtLen1, (v->geographicalLocation), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 136))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->locationArea) = (LocationArea*) Asn1Alloc (sizeof (LocationArea));
    CheckAsn1Alloc ((v->locationArea), env);
    BDecLocationAreaContent (b, tagId1, elmtLen1, (v->locationArea), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 59))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->cellId) = (CellId*) Asn1Alloc (sizeof (CellId));
    CheckAsn1Alloc ((v->cellId), env);
    BDecCellIdContent (b, tagId1, elmtLen1, (v->cellId), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 435)) ||
(tagId1 == MAKE_TAG_ID (APPL, CONS, 435))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecEventReferenceContent (b, tagId1, elmtLen1, (&v->eventReference), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 185))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->recEntityCodeList) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->recEntityCodeList), env);
    BDecRecEntityCodeListContent (b, tagId1, elmtLen1, (v->recEntityCodeList), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 447))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->serviceStartTimestamp) = (ServiceStartTimestamp*) Asn1Alloc (sizeof (ServiceStartTimestamp));
    CheckAsn1Alloc ((v->serviceStartTimestamp), env);
    BDecServiceStartTimestampContent (b, tagId1, elmtLen1, (v->serviceStartTimestamp), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 58))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->causeForTerm) = (CauseForTerm*) Asn1Alloc (sizeof (CauseForTerm));
    CheckAsn1Alloc ((v->causeForTerm), env);
    BDecCauseForTermContent (b, tagId1, elmtLen1, (v->causeForTerm), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, PRIM, 223))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->totalCallEventDuration) = (TotalCallEventDuration*) Asn1Alloc (sizeof (TotalCallEventDuration));
    CheckAsn1Alloc ((v->totalCallEventDuration), env);
    BDecTotalCallEventDurationContent (b, tagId1, elmtLen1, (v->totalCallEventDuration), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 443))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->nonChargedParty) = (NonChargedParty*) Asn1Alloc (sizeof (NonChargedParty));
    CheckAsn1Alloc ((v->nonChargedParty), env);
    BDecNonChargedPartyContent (b, tagId1, elmtLen1, (v->nonChargedParty), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 448))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->sessionChargeInfoList) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->sessionChargeInfoList), env);
    BDecSessionChargeInfoListContent (b, tagId1, elmtLen1, (v->sessionChargeInfoList), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 162))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->operatorSpecInformation) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->operatorSpecInformation), env);
    BDecOperatorSpecInfoListContent (b, tagId1, elmtLen1, (v->operatorSpecInformation), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -303);
    }


    if (!seqDone)
        longjmp (env, -304);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecMobileSessionContent */

void
PrintMobileSession PARAMS ((f, v, indent),
FILE* f _AND_
MobileSession *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->mobileSessionService)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"mobileSessionService ");
    PrintMobileSessionService (f, (v->mobileSessionService), indent + stdIndentG);
    }
    if (NOT_NULL ((v->chargedParty)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"chargedParty ");
    PrintChargedParty (f, (v->chargedParty), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->rapFileSequenceNumber)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"rapFileSequenceNumber ");
    PrintRapFileSequenceNumber (f, (&v->rapFileSequenceNumber), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->simToolkitIndicator)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"simToolkitIndicator ");
    PrintSimToolkitIndicator (f, (&v->simToolkitIndicator), indent + stdIndentG);
    }
    if (NOT_NULL ((v->geographicalLocation)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"geographicalLocation ");
    PrintGeographicalLocation (f, (v->geographicalLocation), indent + stdIndentG);
    }
    if (NOT_NULL ((v->locationArea)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"locationArea ");
    PrintLocationArea (f, (v->locationArea), indent + stdIndentG);
    }
    if (NOT_NULL ((v->cellId)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"cellId ");
    PrintCellId (f, (v->cellId), indent + stdIndentG);
    }
    if (ASNOCTS_PRESENT ((&v->eventReference)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"eventReference ");
    PrintEventReference (f, (&v->eventReference), indent + stdIndentG);
    }
    if (NOT_NULL ((v->recEntityCodeList)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"recEntityCodeList ");
    PrintRecEntityCodeList (f, (v->recEntityCodeList), indent + stdIndentG);
    }
    if (NOT_NULL ((v->serviceStartTimestamp)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"serviceStartTimestamp ");
    PrintServiceStartTimestamp (f, (v->serviceStartTimestamp), indent + stdIndentG);
    }
    if (NOT_NULL ((v->causeForTerm)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"causeForTerm ");
    PrintCauseForTerm (f, (v->causeForTerm), indent + stdIndentG);
    }
    if (NOT_NULL ((v->totalCallEventDuration)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"totalCallEventDuration ");
    PrintTotalCallEventDuration (f, (v->totalCallEventDuration), indent + stdIndentG);
    }
    if (NOT_NULL ((v->nonChargedParty)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"nonChargedParty ");
    PrintNonChargedParty (f, (v->nonChargedParty), indent + stdIndentG);
    }
    if (NOT_NULL ((v->sessionChargeInfoList)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"sessionChargeInfoList ");
    PrintSessionChargeInfoList (f, (v->sessionChargeInfoList), indent + stdIndentG);
    }
    if (NOT_NULL ((v->operatorSpecInformation)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"operatorSpecInformation ");
    PrintOperatorSpecInfoList (f, (v->operatorSpecInformation), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintMobileSession */

void
FreeMobileSession PARAMS ((v),
MobileSession *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->mobileSessionService)))
    {
    FreeMobileSessionService ((v->mobileSessionService));
    Asn1Free ((v->mobileSessionService));
    }

    if (NOT_NULL ((v->chargedParty)))
    {
    FreeChargedParty ((v->chargedParty));
    Asn1Free ((v->chargedParty));
    }

    if (ASNOCTS_PRESENT ((&v->rapFileSequenceNumber)))
    {
    FreeRapFileSequenceNumber ((&v->rapFileSequenceNumber));
    }

    if (ASNOCTS_PRESENT ((&v->simToolkitIndicator)))
    {
    FreeSimToolkitIndicator ((&v->simToolkitIndicator));
    }

    if (NOT_NULL ((v->geographicalLocation)))
    {
    FreeGeographicalLocation ((v->geographicalLocation));
    Asn1Free ((v->geographicalLocation));
    }

    if (NOT_NULL ((v->locationArea)))
    {
    FreeLocationArea ((v->locationArea));
    Asn1Free ((v->locationArea));
    }

    if (NOT_NULL ((v->cellId)))
    {
    FreeCellId ((v->cellId));
    Asn1Free ((v->cellId));
    }

    if (ASNOCTS_PRESENT ((&v->eventReference)))
    {
    FreeEventReference ((&v->eventReference));
    }

    if (NOT_NULL ((v->recEntityCodeList)))
    {
    FreeRecEntityCodeList ((v->recEntityCodeList));
    Asn1Free ((v->recEntityCodeList));
    }

    if (NOT_NULL ((v->serviceStartTimestamp)))
    {
    FreeServiceStartTimestamp ((v->serviceStartTimestamp));
    Asn1Free ((v->serviceStartTimestamp));
    }

    if (NOT_NULL ((v->causeForTerm)))
    {
    FreeCauseForTerm ((v->causeForTerm));
    Asn1Free ((v->causeForTerm));
    }

    if (NOT_NULL ((v->totalCallEventDuration)))
    {
    FreeTotalCallEventDuration ((v->totalCallEventDuration));
    Asn1Free ((v->totalCallEventDuration));
    }

    if (NOT_NULL ((v->nonChargedParty)))
    {
    FreeNonChargedParty ((v->nonChargedParty));
    Asn1Free ((v->nonChargedParty));
    }

    if (NOT_NULL ((v->sessionChargeInfoList)))
    {
    FreeSessionChargeInfoList ((v->sessionChargeInfoList));
    Asn1Free ((v->sessionChargeInfoList));
    }

    if (NOT_NULL ((v->operatorSpecInformation)))
    {
    FreeOperatorSpecInfoList ((v->operatorSpecInformation));
    Asn1Free ((v->operatorSpecInformation));
    }

}  /* FreeMobileSession */




AsnLen
BEncCallEventDetailContent PARAMS ((b, v),
BUF_TYPE b _AND_
CallEventDetail *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    switch (v->choiceId)
    {
       case CALLEVENTDETAIL_MOBILEORIGINATEDCALL:
    BEncEocIfNec (b);
    itemLen = BEncMobileOriginatedCallContent (b, (v->a.mobileOriginatedCall));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, APPL, CONS, 9);

    totalLen += itemLen;

    break;

       case CALLEVENTDETAIL_MOBILETERMINATEDCALL:
    BEncEocIfNec (b);
    itemLen = BEncMobileTerminatedCallContent (b, (v->a.mobileTerminatedCall));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, APPL, CONS, 10);

    totalLen += itemLen;

    break;

       case CALLEVENTDETAIL_SUPPLSERVICEEVENT:
    BEncEocIfNec (b);
    itemLen = BEncSupplServiceEventContent (b, (v->a.supplServiceEvent));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, APPL, CONS, 11);

    totalLen += itemLen;

    break;

       case CALLEVENTDETAIL_SERVICECENTREUSAGE:
    BEncEocIfNec (b);
    itemLen = BEncServiceCentreUsageContent (b, (v->a.serviceCentreUsage));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, APPL, CONS, 12);

    totalLen += itemLen;

    break;

       case CALLEVENTDETAIL_GPRSCALL:
    BEncEocIfNec (b);
    itemLen = BEncGprsCallContent (b, (v->a.gprsCall));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, APPL, CONS, 14);

    totalLen += itemLen;

    break;

       case CALLEVENTDETAIL_CONTENTTRANSACTION:
    BEncEocIfNec (b);
    itemLen = BEncContentTransactionContent (b, (v->a.contentTransaction));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, APPL, CONS, 17);

    totalLen += itemLen;

    break;

       case CALLEVENTDETAIL_LOCATIONSERVICE:
    BEncEocIfNec (b);
    itemLen = BEncLocationServiceContent (b, (v->a.locationService));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 297);

    totalLen += itemLen;

    break;

       case CALLEVENTDETAIL_MESSAGINGEVENT:
    BEncEocIfNec (b);
    itemLen = BEncMessagingEventContent (b, (v->a.messagingEvent));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 433);

    totalLen += itemLen;

    break;

       case CALLEVENTDETAIL_MOBILESESSION:
    BEncEocIfNec (b);
    itemLen = BEncMobileSessionContent (b, (v->a.mobileSession));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, APPL, CONS, 434);

    totalLen += itemLen;

    break;

    }
    return totalLen;

}  /* BEncCallEventDetailContent */

void
BDecCallEventDetailContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
CallEventDetail *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    switch (tagId0)
    {
       case MAKE_TAG_ID (APPL, CONS, 9):
        (v->choiceId) = CALLEVENTDETAIL_MOBILEORIGINATEDCALL;
    (v->a.mobileOriginatedCall) = (MobileOriginatedCall*) Asn1Alloc (sizeof (MobileOriginatedCall));
    CheckAsn1Alloc ((v->a.mobileOriginatedCall), env);
    BDecMobileOriginatedCallContent (b, tagId0, elmtLen0, (v->a.mobileOriginatedCall), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (APPL, CONS, 10):
        (v->choiceId) = CALLEVENTDETAIL_MOBILETERMINATEDCALL;
    (v->a.mobileTerminatedCall) = (MobileTerminatedCall*) Asn1Alloc (sizeof (MobileTerminatedCall));
    CheckAsn1Alloc ((v->a.mobileTerminatedCall), env);
    BDecMobileTerminatedCallContent (b, tagId0, elmtLen0, (v->a.mobileTerminatedCall), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (APPL, CONS, 11):
        (v->choiceId) = CALLEVENTDETAIL_SUPPLSERVICEEVENT;
    (v->a.supplServiceEvent) = (SupplServiceEvent*) Asn1Alloc (sizeof (SupplServiceEvent));
    CheckAsn1Alloc ((v->a.supplServiceEvent), env);
    BDecSupplServiceEventContent (b, tagId0, elmtLen0, (v->a.supplServiceEvent), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (APPL, CONS, 12):
        (v->choiceId) = CALLEVENTDETAIL_SERVICECENTREUSAGE;
    (v->a.serviceCentreUsage) = (ServiceCentreUsage*) Asn1Alloc (sizeof (ServiceCentreUsage));
    CheckAsn1Alloc ((v->a.serviceCentreUsage), env);
    BDecServiceCentreUsageContent (b, tagId0, elmtLen0, (v->a.serviceCentreUsage), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (APPL, CONS, 14):
        (v->choiceId) = CALLEVENTDETAIL_GPRSCALL;
    (v->a.gprsCall) = (GprsCall*) Asn1Alloc (sizeof (GprsCall));
    CheckAsn1Alloc ((v->a.gprsCall), env);
    BDecGprsCallContent (b, tagId0, elmtLen0, (v->a.gprsCall), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (APPL, CONS, 17):
        (v->choiceId) = CALLEVENTDETAIL_CONTENTTRANSACTION;
    (v->a.contentTransaction) = (ContentTransaction*) Asn1Alloc (sizeof (ContentTransaction));
    CheckAsn1Alloc ((v->a.contentTransaction), env);
    BDecContentTransactionContent (b, tagId0, elmtLen0, (v->a.contentTransaction), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (APPL, CONS, 297):
        (v->choiceId) = CALLEVENTDETAIL_LOCATIONSERVICE;
    (v->a.locationService) = (LocationService*) Asn1Alloc (sizeof (LocationService));
    CheckAsn1Alloc ((v->a.locationService), env);
    BDecLocationServiceContent (b, tagId0, elmtLen0, (v->a.locationService), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (APPL, CONS, 433):
        (v->choiceId) = CALLEVENTDETAIL_MESSAGINGEVENT;
    (v->a.messagingEvent) = (MessagingEvent*) Asn1Alloc (sizeof (MessagingEvent));
    CheckAsn1Alloc ((v->a.messagingEvent), env);
    BDecMessagingEventContent (b, tagId0, elmtLen0, (v->a.messagingEvent), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (APPL, CONS, 434):
        (v->choiceId) = CALLEVENTDETAIL_MOBILESESSION;
    (v->a.mobileSession) = (MobileSession*) Asn1Alloc (sizeof (MobileSession));
    CheckAsn1Alloc ((v->a.mobileSession), env);
    BDecMobileSessionContent (b, tagId0, elmtLen0, (v->a.mobileSession), &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("ERROR - unexpected tag in CHOICE\n");
        longjmp (env, -305);
        break;
    } /* end switch */
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecCallEventDetailContent */

void
PrintCallEventDetail PARAMS ((f, v, indent),
FILE* f _AND_
CallEventDetail *v _AND_
unsigned short int indent)
{
    switch (v->choiceId)
    {
      case CALLEVENTDETAIL_MOBILEORIGINATEDCALL:
          fprintf (f,"mobileOriginatedCall ");
    PrintMobileOriginatedCall (f, (v->a.mobileOriginatedCall), indent + stdIndentG);
          break;

      case CALLEVENTDETAIL_MOBILETERMINATEDCALL:
          fprintf (f,"mobileTerminatedCall ");
    PrintMobileTerminatedCall (f, (v->a.mobileTerminatedCall), indent + stdIndentG);
          break;

      case CALLEVENTDETAIL_SUPPLSERVICEEVENT:
          fprintf (f,"supplServiceEvent ");
    PrintSupplServiceEvent (f, (v->a.supplServiceEvent), indent + stdIndentG);
          break;

      case CALLEVENTDETAIL_SERVICECENTREUSAGE:
          fprintf (f,"serviceCentreUsage ");
    PrintServiceCentreUsage (f, (v->a.serviceCentreUsage), indent + stdIndentG);
          break;

      case CALLEVENTDETAIL_GPRSCALL:
          fprintf (f,"gprsCall ");
    PrintGprsCall (f, (v->a.gprsCall), indent + stdIndentG);
          break;

      case CALLEVENTDETAIL_CONTENTTRANSACTION:
          fprintf (f,"contentTransaction ");
    PrintContentTransaction (f, (v->a.contentTransaction), indent + stdIndentG);
          break;

      case CALLEVENTDETAIL_LOCATIONSERVICE:
          fprintf (f,"locationService ");
    PrintLocationService (f, (v->a.locationService), indent + stdIndentG);
          break;

      case CALLEVENTDETAIL_MESSAGINGEVENT:
          fprintf (f,"messagingEvent ");
    PrintMessagingEvent (f, (v->a.messagingEvent), indent + stdIndentG);
          break;

      case CALLEVENTDETAIL_MOBILESESSION:
          fprintf (f,"mobileSession ");
    PrintMobileSession (f, (v->a.mobileSession), indent + stdIndentG);
          break;

    }
}  /* PrintCallEventDetail */

void
FreeCallEventDetail PARAMS ((v),
CallEventDetail *v)
{

    if (v == NULL)
        return;
    switch (v->choiceId)
    {
       case CALLEVENTDETAIL_MOBILEORIGINATEDCALL:
    FreeMobileOriginatedCall ((v->a.mobileOriginatedCall));
    Asn1Free ((v->a.mobileOriginatedCall));

    break;

       case CALLEVENTDETAIL_MOBILETERMINATEDCALL:
    FreeMobileTerminatedCall ((v->a.mobileTerminatedCall));
    Asn1Free ((v->a.mobileTerminatedCall));

    break;

       case CALLEVENTDETAIL_SUPPLSERVICEEVENT:
    FreeSupplServiceEvent ((v->a.supplServiceEvent));
    Asn1Free ((v->a.supplServiceEvent));

    break;

       case CALLEVENTDETAIL_SERVICECENTREUSAGE:
    FreeServiceCentreUsage ((v->a.serviceCentreUsage));
    Asn1Free ((v->a.serviceCentreUsage));

    break;

       case CALLEVENTDETAIL_GPRSCALL:
    FreeGprsCall ((v->a.gprsCall));
    Asn1Free ((v->a.gprsCall));

    break;

       case CALLEVENTDETAIL_CONTENTTRANSACTION:
    FreeContentTransaction ((v->a.contentTransaction));
    Asn1Free ((v->a.contentTransaction));

    break;

       case CALLEVENTDETAIL_LOCATIONSERVICE:
    FreeLocationService ((v->a.locationService));
    Asn1Free ((v->a.locationService));

    break;

       case CALLEVENTDETAIL_MESSAGINGEVENT:
    FreeMessagingEvent ((v->a.messagingEvent));
    Asn1Free ((v->a.messagingEvent));

    break;

       case CALLEVENTDETAIL_MOBILESESSION:
    FreeMobileSession ((v->a.mobileSession));
    Asn1Free ((v->a.mobileSession));

    break;

    }
}  /* FreeCallEventDetail */




AsnLen
BEncCallEventDetailListContent PARAMS ((b, v),
BUF_TYPE b _AND_
CallEventDetailList *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    itemLen = BEncCallEventDetailContent (b, component);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncCallEventDetailListContent */

void
BDecCallEventDetailListContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
CallEventDetailList *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        CallEventDetail **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (CallEventDetail**) AsnListAppend (v);
    (*tmpVar) = (CallEventDetail*) Asn1Alloc (sizeof (CallEventDetail));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecCallEventDetailContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecCallEventDetailListContent */

void
PrintCallEventDetailList PARAMS ((f, v, indent),
FILE* f _AND_
CallEventDetailList *v _AND_
unsigned short int indent)
{
    CallEventDetail *tmp;
    if (v == NULL)
        return;
    fprintf (f,"{ -- SEQUENCE OF -- \n");
    FOR_EACH_LIST_ELMT (tmp, v)
    {
        Indent (f, indent+ stdIndentG);
        PrintCallEventDetail (f, tmp, indent + stdIndentG);
        if (tmp != (CallEventDetail*)LAST_LIST_ELMT (v))
            fprintf (f,",\n");
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintCallEventDetailList */

void
FreeCallEventDetailList PARAMS ((v),
CallEventDetailList *v)
{

    AsnListNode *l;
    AsnListNode *tmp;
    if (v == NULL)
        return;
    for (l = FIRST_LIST_NODE (v); l != NULL; )
    {
        FreeCallEventDetail ((l->data));
        tmp = l->next;
        Asn1Free (l->data);
        Asn1Free (l);
        l = tmp;
    }
}  /* FreeCallEventDetailList */




AsnLen
BEncTransferBatchContent PARAMS ((b, v),
BUF_TYPE b _AND_
TransferBatch *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->auditControlInfo)))
    {
    BEncEocIfNec (b);
    itemLen = BEncAuditControlInfoContent (b, (v->auditControlInfo));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, APPL, CONS, 15);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->callEventDetails)))
    {
    BEncEocIfNec (b);
    itemLen = BEncCallEventDetailListContent (b, (v->callEventDetails));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, APPL, CONS, 3);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->messageDescriptionInfo)))
    {
    BEncEocIfNec (b);
    itemLen = BEncMessageDescriptionInfoListContent (b, (v->messageDescriptionInfo));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, APPL, CONS, 8);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->networkInfo)))
    {
    BEncEocIfNec (b);
    itemLen = BEncNetworkInfoContent (b, (v->networkInfo));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, APPL, CONS, 6);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->accountingInfo)))
    {
    BEncEocIfNec (b);
    itemLen = BEncAccountingInfoContent (b, (v->accountingInfo));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, APPL, CONS, 5);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->batchControlInfo)))
    {
    BEncEocIfNec (b);
    itemLen = BEncBatchControlInfoContent (b, (v->batchControlInfo));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, APPL, CONS, 4);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncTransferBatchContent */

void
BDecTransferBatchContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
TransferBatch *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }

    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 4))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->batchControlInfo) = (BatchControlInfo*) Asn1Alloc (sizeof (BatchControlInfo));
    CheckAsn1Alloc ((v->batchControlInfo), env);
    BDecBatchControlInfoContent (b, tagId1, elmtLen1, (v->batchControlInfo), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 5))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->accountingInfo) = (AccountingInfo*) Asn1Alloc (sizeof (AccountingInfo));
    CheckAsn1Alloc ((v->accountingInfo), env);
    BDecAccountingInfoContent (b, tagId1, elmtLen1, (v->accountingInfo), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 6))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->networkInfo) = (NetworkInfo*) Asn1Alloc (sizeof (NetworkInfo));
    CheckAsn1Alloc ((v->networkInfo), env);
    BDecNetworkInfoContent (b, tagId1, elmtLen1, (v->networkInfo), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 8))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->messageDescriptionInfo) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->messageDescriptionInfo), env);
    BDecMessageDescriptionInfoListContent (b, tagId1, elmtLen1, (v->messageDescriptionInfo), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 3))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->callEventDetails) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->callEventDetails), env);
    BDecCallEventDetailListContent (b, tagId1, elmtLen1, (v->callEventDetails), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (APPL, CONS, 15))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->auditControlInfo) = (AuditControlInfo*) Asn1Alloc (sizeof (AuditControlInfo));
    CheckAsn1Alloc ((v->auditControlInfo), env);
    BDecAuditControlInfoContent (b, tagId1, elmtLen1, (v->auditControlInfo), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -306);
    }


    if (!seqDone)
        longjmp (env, -307);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecTransferBatchContent */

void
PrintTransferBatch PARAMS ((f, v, indent),
FILE* f _AND_
TransferBatch *v _AND_
unsigned short int indent)
{
    int nonePrinted = TRUE;

    if (v == NULL)
        return;

    fprintf (f,"{ -- SEQUENCE --\n");

    if (NOT_NULL ((v->batchControlInfo)))
    {
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"batchControlInfo ");
    PrintBatchControlInfo (f, (v->batchControlInfo), indent + stdIndentG);
    }
    if (NOT_NULL ((v->accountingInfo)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"accountingInfo ");
    PrintAccountingInfo (f, (v->accountingInfo), indent + stdIndentG);
    }
    if (NOT_NULL ((v->networkInfo)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"networkInfo ");
    PrintNetworkInfo (f, (v->networkInfo), indent + stdIndentG);
    }
    if (NOT_NULL ((v->messageDescriptionInfo)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"messageDescriptionInfo ");
    PrintMessageDescriptionInfoList (f, (v->messageDescriptionInfo), indent + stdIndentG);
    }
    if (NOT_NULL ((v->callEventDetails)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"callEventDetails ");
    PrintCallEventDetailList (f, (v->callEventDetails), indent + stdIndentG);
    }
    if (NOT_NULL ((v->auditControlInfo)))
    {
    if (!nonePrinted)
        fprintf (f,",\n");
    nonePrinted = FALSE;
    Indent (f, indent + stdIndentG);
    fprintf (f,"auditControlInfo ");
    PrintAuditControlInfo (f, (v->auditControlInfo), indent + stdIndentG);
    }
    fprintf (f,"\n");
    Indent (f, indent);
    fprintf (f,"}");
}  /* PrintTransferBatch */

void
FreeTransferBatch PARAMS ((v),
TransferBatch *v)
{

    if (v == NULL)
        return;
    if (NOT_NULL ((v->batchControlInfo)))
    {
    FreeBatchControlInfo ((v->batchControlInfo));
    Asn1Free ((v->batchControlInfo));
    }

    if (NOT_NULL ((v->accountingInfo)))
    {
    FreeAccountingInfo ((v->accountingInfo));
    Asn1Free ((v->accountingInfo));
    }

    if (NOT_NULL ((v->networkInfo)))
    {
    FreeNetworkInfo ((v->networkInfo));
    Asn1Free ((v->networkInfo));
    }

    if (NOT_NULL ((v->messageDescriptionInfo)))
    {
    FreeMessageDescriptionInfoList ((v->messageDescriptionInfo));
    Asn1Free ((v->messageDescriptionInfo));
    }

    if (NOT_NULL ((v->callEventDetails)))
    {
    FreeCallEventDetailList ((v->callEventDetails));
    Asn1Free ((v->callEventDetails));
    }

    if (NOT_NULL ((v->auditControlInfo)))
    {
    FreeAuditControlInfo ((v->auditControlInfo));
    Asn1Free ((v->auditControlInfo));
    }

}  /* FreeTransferBatch */




AsnLen
BEncDataInterChangeContent PARAMS ((b, v),
BUF_TYPE b _AND_
DataInterChange *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    switch (v->choiceId)
    {
       case DATAINTERCHANGE_TRANSFERBATCH:
    BEncEocIfNec (b);
    itemLen = BEncTransferBatchContent (b, (v->a.transferBatch));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, APPL, CONS, 1);

    totalLen += itemLen;

    break;

       case DATAINTERCHANGE_NOTIFICATION:
    BEncEocIfNec (b);
    itemLen = BEncNotificationContent (b, (v->a.notification));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, APPL, CONS, 2);

    totalLen += itemLen;

    break;

    }
    return totalLen;

}  /* BEncDataInterChangeContent */

void
BDecDataInterChangeContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
DataInterChange *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    switch (tagId0)
    {
       case MAKE_TAG_ID (APPL, CONS, 1):
        (v->choiceId) = DATAINTERCHANGE_TRANSFERBATCH;
    (v->a.transferBatch) = (TransferBatch*) Asn1Alloc (sizeof (TransferBatch));
    CheckAsn1Alloc ((v->a.transferBatch), env);
    BDecTransferBatchContent (b, tagId0, elmtLen0, (v->a.transferBatch), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (APPL, CONS, 2):
        (v->choiceId) = DATAINTERCHANGE_NOTIFICATION;
    (v->a.notification) = (Notification*) Asn1Alloc (sizeof (Notification));
    CheckAsn1Alloc ((v->a.notification), env);
    BDecNotificationContent (b, tagId0, elmtLen0, (v->a.notification), &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("ERROR - unexpected tag in CHOICE\n");
        longjmp (env, -308);
        break;
    } /* end switch */
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecDataInterChangeContent */

void
PrintDataInterChange PARAMS ((f, v, indent),
FILE* f _AND_
DataInterChange *v _AND_
unsigned short int indent)
{
    switch (v->choiceId)
    {
      case DATAINTERCHANGE_TRANSFERBATCH:
          fprintf (f,"transferBatch ");
    PrintTransferBatch (f, (v->a.transferBatch), indent + stdIndentG);
          break;

      case DATAINTERCHANGE_NOTIFICATION:
          fprintf (f,"notification ");
    PrintNotification (f, (v->a.notification), indent + stdIndentG);
          break;

    }
}  /* PrintDataInterChange */

void
FreeDataInterChange PARAMS ((v),
DataInterChange *v)
{

    if (v == NULL)
        return;
    switch (v->choiceId)
    {
       case DATAINTERCHANGE_TRANSFERBATCH:
    FreeTransferBatch ((v->a.transferBatch));
    Asn1Free ((v->a.transferBatch));

    break;

       case DATAINTERCHANGE_NOTIFICATION:
    FreeNotification ((v->a.notification));
    Asn1Free ((v->a.notification));

    break;

    }
}  /* FreeDataInterChange */




